<h3>Introduction</h3>

<p>This Ecma Standard is based on several originating technologies, the most well known being JavaScript (Netscape) and JScript (Microsoft). The language was invented by Brendan Eich at Netscape and first appeared in that company’s Navigator 2.0 browser. It has appeared in all subsequent browsers from Netscape and in all browsers from Microsoft starting with Internet Explorer 3.0.</p>

<p>The development of this Standard started in November 1996. The first edition of this Ecma Standard was adopted by the Ecma General Assembly of June 1997.</p>

<p>That Ecma Standard was submitted to ISO/IEC JTC 1 for adoption under the fast-track procedure, and approved as international standard ISO/IEC 16262, in April 1998. The Ecma General Assembly of June 1998 approved the second edition of ECMA-262 to keep it fully aligned with ISO/IEC 16262. Changes between the first and the second edition are editorial in nature.</p>

<p>The third edition of the Standard introduced powerful regular expressions, better string handling, new control statements, try/catch exception handling, tighter definition of errors, formatting for numeric output and minor changes in anticipation of forthcoming internationalisation facilities and future language growth. The third edition of the ECMAScript standard was adopted by the Ecma General Assembly of December 1999 and published as ISO/IEC 16262:2002 in June 2002.</p>

<p>Since publication of the third edition, ECMAScript has achieved massive adoption in conjunction with the World Wide Web where it has become the programming language that is supported by essentially all web browsers. Significant work was done to develop a fourth edition of ECMAScript. Although that work was not completed and not published as the fourth edition of ECMAScript, it informs continuing evolution of the language. The fifth edition of ECMAScript (published as ECMA-262 5<sup>th</sup> edition) codifies de facto interpretations of the language specification that have become common among browser implementations and adds support for new features that have emerged since the publication of the third edition. Such features include accessor properties, reflective creation and inspection of objects, program control of property attributes, additional array manipulation functions, support for the JSON object encoding format, and a strict mode that provides enhanced error checking and program security.</p>

<p>This present edition 5.1 of the ECMAScript Standard is fully aligned with third edition of the international standard ISO/IEC 16262:2011.</p>

<p>ECMAScript is a vibrant language and the evolution of the language is not complete. Significant technical enhancement will continue with future editions of this specification.</p>

<p>This Ecma Standard has been adopted by the General Assembly of June 2011.</p>

<h4>范围</h4>

<p>此标准定义了 ECMAScript 脚本语言。</p>

<h4>一致性</h4>

<p>符合标准的 ECMAScript 实现，必须提供并支持本规范描述的所有类型、值、对象、属性、函数、程序语法和语义。</p>

<p>符合标准的 ECMAScript 实现，应当能解释符合 Unic​​ode 标准3.0或更高版本，以 UCS-2 或 UTF-16 作为编码格式的 ISO/IEC 10646-1 第3级实现里的字符。如果没有额外指明采用的 ISO/IEC 10646-1 子集，则假定组号为300的 BMP 子集。如果没有额外指明采用的编码格式，则假定编码格式为 UTF-16。</p>

<p>符合标准的 ECMAScript 实现，允许提供超出本规范描述的额外类型、值、对象、属性、函数。 尤其是本规范中描述的对象，是允许提供未在本规范中描述的属性和属性值的。</p>

<p>符合标准的 ECMAScript 实现，允许支持本规范未描述的程序语法和正则表达式语法。 尤其是本规范 7.6.1.2 列出的“未来保留字”，是允许作为程序语法的。</p>



<h4>参考文献</h4>

<p>为了实现符合本规范的应用程序，下列引用文档是不可或缺的。对于标注了日期的文档，仅适用标注的那个版本。 对于未标注日期的文档，以文档的最新版为准（包括任何修订版）。</p>

<p>ISO/IEC 9899:1996, Programming Languages – C, including amendment 1 and technical corrigenda 1 and 2</p>

<p>ISO/IEC 10646-1:1993, Information Technology – Universal Multiple-Octet Coded Character Set (UCS) plus its amendments and corrigenda</p>



<h4>概述</h4>

<p>本节包含对 ECMAScript 语言非规范性的概述。</p>

<p>ECMAScript 是在宿主环境中执行计算，处理对象的面向对象编程语言。这里定义的 ECMAScript 并未打算要计算性自足；事实上，本规范没有任何针对输入外部数据或输出计算结果的条文。相反，我们期望 ECMAScript 程序的计算环境可提供本规范中描述的对象和其它设施之外的、某些特定环境下的 <i>宿主 (host)</i> 对象，除了说明宿主对象应该提供可被 ECMAScript 程序访问的某些属性，调用的某些方法外，关于它的其他描述和行为超出了本规范涉及的范围。</p>

<p><b>脚本语言 </b>是一种用于操作，自定义，自动化现有系统设施的编程语言。在这种系统中，已经可以通过一个用户界面使用可用功能，脚本语言是一种机制，暴漏这些功能给程序控制。这样，现有系统可以说给完善脚本语言能力需要的对象和设施提供了一个宿主环境。脚本语言被设计成专业和非专业程序员都能使用。</p>

<p>ECMAScript 最初被设计为 <b>Web 脚本语言 </b>，提供了一种机制，使浏览器里的网页更加活跃，成为基于 Web 的客户 - 服务器架构的一部分执行服务器计算。ECMAScript 可以为各种宿主环境提供核心的脚本功能，因此本文档为不依赖特定宿主环境的核心脚本语言作出规范。</p>

<p>ECMAScript 的一些机能和其他编程语言的类似；特别是 Java™，Self，和 Scheme。以下文献描述了他们：</p>

<p>Gosling, James, Bill Joy and Guy Steele. The Java™ Language Specification. Addison Wesley Publishing Co., 1996. </p>

<p>Ungar, David, and Smith, Randall B. Self: The Power of Simplicity. OOPSLA '87 Conference Proceedings, pp. 227–241, Orlando, FL, October 1987. </p>

<p>IEEE Standard for the Scheme Programming Language. IEEE Std 1178-1990.</p>



<h4>Web 脚本语言</h4>

<p>WEB 浏览器为引入客户端计算能力而提供 ECMAScript 宿主环境，例如，它提供的对象有：windows，menus，pop-ups，dialog boxes，text areas，anchors，frames，history，cookies 及输入 / 输出等等。进一步来说，WEB 浏览器中提供的这种宿主环境，它提供了一种方式，使得脚本代码可以去处理诸如改变焦点、页面和图片的加载、卸载、错误和放弃，选择，表单提交和鼠标交互等等事件。脚本代码出现在 HTML 中，显示出来的页面是一个用户接口元素与固定的和计算出来的文本和图片的集合。脚本代码根据用户的交互而做出反应，并不需要存在一个主程序。</p>

<p>WEB 服务器为了服务端的计算则提供了一个完全不一样的宿主环境，包括的对象有：requrests，clients，files 以及数据锁定和分享的机制。通过浏览器端脚本及服务端脚本的配合使用，在为基于 WEB 方式的应用程序提供定制的用户接口时，可以将计算分布到客户端和服务端进行。</p>

<p>每一种支持 ECMAScript 的 WEB 浏览器和服务器都将它们自身的宿主环境作为 ECMAScript 的补充，以使得 ECMAScript 的执行环境变得完整。</p>



<h4>语言概述</h4>

<p>下面是非正式的 ECMAScript 概述 -- 并未描述语言的所有部分。此概述并非标准的一部分。</p>

<p>ECMAScript 是基于对象的：基本语言和宿主设施都由对象提供，ECMAScript 程序是一组可通信的对象。ECMAScript<b> 对象 (objects)</b> 是 <b>属性 (properties)</b> 的集合，每个属性有零个或多个 <b>特性 (attributes)</b>，它确定怎样使用此属性。例如，当设置一个属性的 Writable 特性为 false 时，任何试图更改此属性值的 ECMAScript 代码的都会运行失败。属性是持有其他 <b>对象 (objects)</b>，<b> 原始值 (primitive values)</b>，<b> 函数 (functions)</b> 的容器。原始值是以下内置类型之一的成员：Undefined，Null，Boolean，Number，String；对象是剩下的内置类型 Object 的成员；函数是可调用对象 (callable object)。方法 (method) 是通过属性与对象关联的函数。</p>

<p>ECMAScript 定义一组内置对象 (built-in objects)，勾勒出 ECMAScript 实体的定义。这些内置对象包括 全局对象 (global object) ，Object 对象 ，Function 对象 ，Array 对象 ，String 对象 ，Boolean 对象 ，Number 对象 ，Math 对象 ，Date 对象 ，RegExp 对象 ，JSON 对象，和 Error 对象： Error ，EvalError ，RangeError ，ReferenceError ，SyntaxError ，TypeError ，URIError 。</p>

<p>ECMAScript 中还定义一组内置运算符 (operators)。ECMAScript 运算符包括 一元运算符 ，乘法运算符 ，加法运算符 ，按位移位运算符 ，关系运算符 ，相等运算符 ，二进制位运算符 ，二进制逻辑运算符 ，赋值运算符 ，逗号运算符。</p>

<p>ECMAScript 语法有意设计成与 Java 语法类似。ECMAScript 的语法是松散的，使其能够作为一个易于使用的脚本语言。例如，一个变量不需要有类型声明，属性也不需要与类型关联，定义的函数也不需要声明在函数调用词句的前面。</p>



<h5>对象</h5>

<p>ECMAScript 不使用诸如 C++，Smalltalk，Java 中的类。相反，对象可以通过各种方式创建，包括字面符号，或通过 <b>构造器 </b>创建对象然后运行代码初始化其全部或部分属性值，为这些属性分配初始值。每个构造器是一个拥有名为“<b>prototype</b>”的属性的函数。此属性用于实现 <b>基于原型的继承 </b>和 <b>共享属性 </b>。构造器通过 <b>new</b> 表达式创建对象：例如，<b>new Date(2009,11)</b> 创建一个新 Date 对象。不使用 new 调用一个构造器的结果，依赖构造器本身。例如，Date() 产生一个表示当前日期时间的字符串，而不是一个对象。</p>

<p>每个由构造器创建的对象，都有一个隐式引用 ( 叫做对象的原型 ) 链接到构造器的“<b>prototype</b>”属性值。再者，原型可能有一个非空 (non-null) 隐式引用链接到它自己的原型，以此类推，这叫做 <i>原型链 </i>。当向对象的一个属性提出引用，引用会指向原型链中包含此属性名的第一个对象的此属性。换句话说，首先检查直接提及的对象的同名属性，如果对象包含同名的属性，引用即指向此属性，如果该对象不包含同名的属性，则下一步检查对象的原型；以此类推。</p>

<figure>
<p><a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Special:Upload&wpDestFile=Http://es5.github.com/figure1.gif">File:Http://es5.github.com/figure1.gif</a></p>

<p>图 1 — 对象 / 原型的关系</p>
</figure>

<p>一般情况下基于类的面向对象语言的实例拥有状态，类拥有方法，并且只能继承结构和行为。在 ECMAScript 中，对象拥有状态和方法，并且结构，行为，状态全都可继承。</p>

<p>不直接包含原型中包含的特定属性的所有对象会共享此属性及属性值。图 1 说明了这一点：</p>



<p>CF 是一个构造器（也是一个对象）。五个对象已用 new 表达式创建 : cf1, cf2, cf3, cf4, cf5。每个对象都有名为 q1 和 q2 的属性。虚线表示隐式原型关系；例如：cf3 的原型是 CFp。构造器 CF 自己有名为 P1 和 P2 的两个属性 , 这对 CFp, cf1, cf2, cf3, cf4, cf5 是不可见的。CFp 的名为 CFP1 的属性共享给 cf1, cf2, cf3, cf4, cf5 ( 没有 CF), 以及在 CFp 的隐式原型链中找不到任何名为 q1, q2, 或 CFP1 的属性。 请注意 ，CF 和 CFp 之间没有隐式原型链接。</p>

<p>不同于基于类的对象语言，属性可以通过赋值的方式动态添加给对象。也就是说，构造器并不是非要对构造的对象的全部或任何属性命名或赋值。上图中，可以给 CFp 添加新属性值的方式为 cf1, cf2, cf3, cf4,cf5 添加一个新的共享属性。</p>



<h5>ECMAScript 的严格模式变体</h5>

<p>ECMAScript 语言认可有些用户希望限制使用语言中某些功能的可能性。他们这样做可能是为了安全考虑，避免他们认为是容易出错的功能，获得增强的错误检查，或其他原因。为了支持这种可能性，ECMAScript 中定义了语言的严格变体。语言的严格变体，排除了 ECMAScript 语言的某些特定的句法和语义特征，还修改了某些功能的详细语义。严格变体还指定了必须抛出错误异常报告的额外错误条件，即使在非严格的语言形式下这些条件不属于错误。</p>

<p>ECMAScript 的严格变体通常被称为语言的 <i>严格模式 (strict mode)</i>。严格模式选择使用的 ECMAScript 严格模式的语法和语义，明确地适用于个别 ECMAScript 代码单元级别。由于严格模式适用于选择的语法代码单元级别，严格模式仅在这个代码单元内施加有局部效果的限制。严格模式不限制或修改任何必须运行在多个代码单元的 ECMAScript 语义层面。一个 ECMAScript 程序可由严格模式和非严格模式的代码单元组成。在这种情况下，严格的模式只适用于严格模式代码单元内实际执行的代码。</p>

<p>In order to conform to this specification, an ECMAScript implementation must implement both the full unrestricted ECMAScript language and the strict mode variant of the ECMAScript language as defined by this specification. In addition, an implementation must support the combination of unrestricted and strict mode code units into a single composite program.</p>


<h4>术语定义</h4>

<p>本文档将使用下列术语和定义。</p>



<h5>类型 (type)</h5>

<p>本规范第 8 章定义数据的集合。</p>



<h5>原始值 (primitive value)</h5>

<p>在本规范的第 8 章定义的未定义，空，布尔，数字，字符串类型之一的成员。</p>

<p>注： 原始值直接代表语言实现的最底层的数据。</p>



<h5>对象 (object)</h5>

<p>对象类型的成员。</p>

<p>注： 对象是属性的集合，并有一个原型对象。原型可以是空值。</p>



<h5>构造器 (constructor)</h5>

<p>创建和初始化对象的函数对象。</p>

<p>注： 构造器的“prototype”属性值是一个原型对象，它用来实现继承和共享属性。</p>



<h5>原型 (prototype)</h5>

<p>为其他对象提供共享属性的对象。</p>

<p>注： 当构造器创建一个对象，为了解决对象的属性引用，该对象会隐式引用构造器的“prototype”属性。通过程序表达式 constructor.prototype 可以引用到构造器的“prototype”属性，并且添加到对象原型里的属性，会通过继承与所有共享此原型的对象共享。另外，可使用 Object.create 内置函数，通过明确指定原型来创建一个新对象。</p>



<h5>原生对象 (native object)</h5>

<p>ECMAScript 实现中，并非由宿主环境，而是完全由本规范定义其语义的对象。</p>

<p>注： 标准的原生对象由本规范定义。一些原生对象是内置的，其他的可在 ECMAScript 程序执行过程中构建。</p>



<h5>内置对象 (built-in object)</h5>

<p>由 ECMAScript 实现提供，独立于宿主环境的对象，ECMAScript 程序开始执行时就存在。</p>

<p>注： 标准的内置对象由本规范定义，ECMAScript 实现可以指定和定义其他的。所有内置对象是原生对象。一个内置构造器 (built-in constructor) 是个内置对象，也是个构造器。</p>



<h5>宿主对象 (host object)</h5>

<p>由宿主环境提供的对象，用于完善 ECMAScript 执行环境。</p>

<p>注： 任何对象，不是原生对象就是宿主对象。</p>



<h5>未定义值 (undefined value)</h5>

<p>说明一个变量没有被分配值的一个原始值。</p>



<h5>未定义类型 (Undefined type)</h5>

<p>拥有唯一值“未定义值”的类型。</p>



<h5>空值 (null value)</h5>

<p>代表对象值故意留空的一个原始值。</p>



<h5>空类型 (Null type)</h5>

<p>拥有唯一值“空值”的类型。</p>



<h5>布尔值 (Boolean value)</h5>

<p>布尔类型的成员。</p>

<p>注： 只有两个布尔值，<b>true</b> 和 <b>false</b> 。</p>



<h5>布尔类型 (Boolean type)</h5>

<p>由原始值 <b>true</b> 和 <b>false</b> 组成的类型。</p>



<h5>布尔对象 (Boolean object)</h5>

<p>对象类型的成员，它是标准内置构造器 Boolean 的一个实例。</p>

<p>注： 通过使用 new 表达式，以一个布尔值作为参数调用 Boolean 构造器来创建布尔对象。由此产生的对象包含一个值为此布尔值的内部属性。一个 Boolean 对象可以强制转换为布尔值。</p>



<h5>字符串值 (String value)</h5>

<p>原始值，它是零个或多个 16 位无符号整数组成的有限有序序列。</p>

<p>注： 一个字符串值是字符串类型的成员。通常序列中的每个整数值代表 UTF-16 文本的单个 16 位单元。然而，对于其值，ECMAScript 只要求必须是 16 位无符号整数，除此之外没有任何限制或要求。</p>



<h5>字符串类型 (String type)</h5>

<p>所有可能的字符串值的集合。</p>



<h5>字符串对象 (String object)</h5>

<p>对象类型的成员，它是标准内置构造器 String 的一个实例。</p>

<p>注： 通过使用 new 表达式，以一个字符串值为参数调用 String 构造器来创建字符串对象。由此产生的对象包含一个值为此字符串值的内部属性。将 String 构造器作为一个函数来调用，可将一个字符串对象强制转换为一个字符串值（15.5.1 ）。</p>



<h5>数字值 (Number value)</h5>

<p>原始值，对应一个 64 位双精度二进制 IEEE754 值。</p>

<p>注： 一个数字值是数字类型的成员，直接代表一个数字。</p>



<h5>数字类型 (Number type)</h5>

<p>所有可能的数字值的集合，包括特殊的“Not-a-Number”(NaN) 值，正无穷，负无穷。</p>



<h5>数字对象 (Number object)</h5>

<p>对象类型的成员，它是标准内置构造器 Number 的一个实例。</p>

<p>注： 通过使用 new 表达式，以一个数字值为参数调用 Number 构造器来创建数字对象。由此产生的对象包含一个值为此数字值的内部属性。将 Number 构造器作为一个函数来调用，可将一个 Number 对象强制转换为一个数字值（15.7.1 ）。</p>



<h5>无穷 (Infinity)</h5>

<p>正无穷数字值。</p>



<h5>NaN</h5>

<p>值为 IEEE 754“Not-a-Number”的数字值</p>



<h5>函数 (function)</h5>

<p>对象类型的成员，标准内置构造器 Function 的一个实例，并且可做为子程序被调用。</p>

<p>注： 函数除了拥有命名的属性，还包含可执行代码、状态，用来确定被调用时的行为。函数的代码不限于 ECMAScript。</p>



<h5>内置函数 (built-in function)</h5>

<p>作为函数的内置对象。</p>

<p>注： 如 parseInt 和 Math.exp 就是内置函数。一个实现可以提供本规范没有描述的依赖于实现的内置函数。</p>



<h5>属性 (property)</h5>

<p>作为对象的一部分联系名和值。</p>

<p>注： 属性可能根据属性值的不同表现为直接的数据值（原始值，对象，或一个函数对象）或间接的一对访问器函数。</p>



<h5>方法 (method)</h5>

<p>作为属性值的函数。</p>

<p>注： 当一个函数被作为一个对象的方法调用，此对象将作为 this 值传递给函数。</p>



<h5>内置方法 (built-in method)</h5>

<p>作为内置函数的方法。</p>

<p>注： 标准内置方法由本规范定义，一个 ECMAScript 实现可指定，提供其他额外的内置方法。</p>



<h5>特性 (attribute)</h5>

<p>定义一个属性的一些特征的内部值。</p>



<h5>自身属性 (own property)</h5>

<p>对象直接拥有的属性。</p>



<h5>继承属性 (inherited property)</h5>

<p>不是对象的自身属性，但是是对象原型的属性 ( 原型的自身属性或继承属性 )。</p>



<h4>记法约定</h4>

<h4>句法和词法的文法</h4>


<h5>上下文无关文法</h5>

<p>一个 <i>上下文无关文法 </i>由一定数量的 <i>产生式 (productions)</i> 组成。每个产生式的 <i>左边 (left-hand side)</i> 是一个被称为非终结符 (nonterminal) 的抽象符号，<i> 右边 (right-hand side)</i> 是零或多个非终结符和 <i>终结符 (terminal symbols)</i> 的有序排列。任何文法，它的终结符都来自指定的字母集。</p>

<p>当从一个叫做 <i>目标符 (goal symbol)</i> 的特殊非终端符组成的句子起始，那么给出的上下文无关文法就表示 <i>语言 (language)</i>，即，将产生式右边序列的非终结符当作左边，进行反复替换的结果就成为可能的终结符序列集合（可能无限）。</p>



<h5>词法和正则的文法</h5>

<p>第 7 章给出了 ECMAScript 的 <i>词法文法 (lexical grammar)</i>。作为此文法的终结符字符（Unicode 代码单元）符合第 6 章定义的 <i>SourceCharacter</i> 的规则。它定义了一套产生式，从目标符 <i>InputElementDiv</i> 或 <i>InputElementRegExp</i> 起始，描述了如何将这样的字符序列翻译成一个输入元素序列。</p>

<p>空白和注释之外的输入元素构成 ECMAScript 句法文法的终结符，它们被称为 ECMAScript 的 <i>tokens</i>。这些 tokens 是，ECMAScript 语言的保留字，标识符，字面量，标点符号。此外，行结束符虽然不被视为 tokens，但会成为输入元素流的一部分，用于引导处理自动插入分号（ 7.9 ）。空白和单行注释会被简单的丢弃，不会出现在句法文法的输入元素的流中。如果一个 <i>多行注释 (MultiLineComment)</i>（即形式为“/ ... /”的注释，不管是否跨越多行）不包含行结束符也会简单地丢弃，但如果一个 <i>多行注释 </i>包含一个或多个结束符，那么，注释会被替换为一个行结束符，成为句法文法输入元素流的一部分。</p>

<p>15.10 给出了 ECMAScript 的 <i>正则文法 (RegExp grammar)</i>。此文法的终结符字符也由 <i>SourceCharacter</i> 定义。它定义了一套产生式，从目标符 <i>Pattern</i> 起始，描述了如何将这样的字符序列翻译成一个正则表达式模式。</p>

<p>两个冒号“::”作为分隔符分割词法和正则的文法产生式。词法和正则的文法共享某些产生式。</p>



<h5>数字字符串文法</h5>

<p>用于转换字符串为数字值的一种文法。此文法与词法文法的一部分（与数字字面量有关的）类似，并且有终结符 <i>SourceCharacter</i>。此文法出现在 9.3.1 。</p>

<p>三个冒号“:::”作为分隔符分割数字字符串文法的产生式。</p>



<h5>句法文法</h5>

<p>第 11，12，13，14 章给出了 ECMAScript 的 <i>句法文法 </i>。词法文法定义的 ECMAScript tokens 是此文法的终结符（ 5.1.2 ）。它定义了一组起始于 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Program&action=edit&redlink=1">Program</a> 目标符的产生式，描述了语法正确的 ECMAScript 程序应该怎样排列 tokens。</p>

<p>当一个字符流被解析为 ECMAScript 程序，它首先通过词法文法应用程序反复转换为一个输入元素流；然后再用一个句法文法应用程序解析这个输入元素流。当输入元素流没有更多 tokens 时，如果 tokens 不能解析为 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Program&action=edit&redlink=1">Program</a> 目标非终结符的单一实例，那么程序在语法上存在错误。</p>

<p>只用一个冒号“:”作为分隔符分割句法词法的产生式。</p>

<p>事实上第 11，12，13 和 14 章给出的句法语法，并不能完全说明一个正确的 ECMAScript 程序能接受的 token 序列。一些额外的 token 序列也被接受，即某些特殊位置（如行结束符前）加入分号可以被文法接受。此外，文法描述的某些 token 序列不被文法接受，如一个行结束符出现在“尴尬”的位置。</p>



<h5>JSON 文法</h5>

<p>JSON 文法用于将描述 ECMAScript 对象的字符串转换为实际的对象。<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=15.12.1&action=edit&redlink=1">15.12.1</a> 给出了 JSON 文法 。</p>

<p>JSON 文法由 JSON 词法文法和 JSON 句法文法组成。JSON 词法文法用于将字符序列转换为 tokens，类似 ECMAScript 词法文法。JSON 句法文法说明 JSON 词法文法给出怎样的 tokens 序列才能转换为语法上是正确的 JSON 对象。</p>

<p>两个冒号“::”作为分隔符分割 JSON 词法文法的产生式。JSON 词法文法使用某些 ECMAScript 词法文法的产生式。JSON 句法文法与 ECMAScript 句法文法类似。JSON 句法文法产生式被一个冒号“:”作为分隔符分割。</p>



<h5>文法标记法</h5>

<p>词法文法和字符串文法的终结符，以及一些句法文法的终结符，无论是在文法的产生式还是贯穿本规范的所有文本直接给出的终结符，都用 <b>等宽 (fixed width)</b> 字体显示。他们表示程序书写正确。所有以这种方式指定的终结符字符，可以理解为 Unicode 字符的完整的 ASCII 范围，不是任何其他类似的 Unicode 范围字符。</p>

<p>非终结符以 <i>斜体 (italic)</i> 显示。一个非终结符的定义由非终结符名称和其后定义的一个或多个冒号给出。（冒号的数量表示产生式所属的文法。）非终结符的右侧有一个或多个替代子紧跟在下一行。 例如，句法定义：</p>

<pre> <i>WhileStatement</i> :

   <b>while</b> ( <i>Expression</i> ) <i>Statement</i></pre>

<p>表示这个非终结符 <i>WhileStatement</i> 代表 <b>while</b> token，其后跟左括号 token，其后跟 Expression，其后跟右括号 token，其后跟 <i>Statement</i>。这里出现的 <i>Expression</i> 和 <i>Statement</i> 本身是非终结符。另一个例子，句法定义：</p>

<pre> <i>ArgumentList</i> :

   <i>AssignmentExpression</i>
   <i>ArgumentList</i> , <i>AssignmentExpression</i></pre>

<p>表示这个 <i>ArgumentList</i> 可以代表一个 <i>AssignmentExpression</i>，或 <i>ArgumentList</i>，其后跟一个逗号，其后跟一个 <i>AssignmentExpression</i>。这个 <i>ArgumentList</i> 的定义是递归的，也就是说，它定义它自身。其结果是，一个 <i>ArgumentList</i> 可能包含用逗号隔开的任意正数个参数，每个参数表达式是一个 <i>AssignmentExpression</i>。这样，非终结符共用了递归的定义。</p>

<p>终结符或非终结符可能会出现后缀下标“ <sub>opt</sub> ”，表示它是可选符号。实际上包含可选符号的替代子包含两个右边，一个是省略可选元素的，另一个是包含可选元素的。这意味着：</p>

<pre> <i>VariableDeclaration</i> :

   <i>Identifier</i> <i>Initialiser</i><sub>opt</sub></pre>

<p>是以下的一种缩写：</p>

<pre> <i>VariableDeclaration</i> :

   <i>Identifier</i>
   <i>Identifier</i> <i>Initialiser</i></pre>

<p>并且：</p>

<pre> <i>IterationStatement</i> :

   <b>for</b> <b>(</b> <i>ExpressionNoIn</i><sub>opt</sub> <b>;</b> <i>Expression</i><sub>opt</sub> <b>;</b> <i>Expression</i><sub>opt</sub> <b>)</b> <i>Statement</i></pre>

<p>是以下的一种缩写：</p>

<pre> <i>IterationStatement</i> :

   <b>for</b> <b>(</b> <b>;</b> <i>Expression</i><sub>opt</sub> <b>;</b> <i>Expression</i><sub>opt</sub> <b>)</b> <i>Statement</i>
   <b>for</b> <b>(</b> <i>ExpressionNoIn</i> <b>;</b> <i>Expression</i><sub>opt</sub> <b>;</b> <i>Expression</i><sub>opt</sub> <b>)</b> <i>Statement</i></pre>

<p>是以下的一种缩写 :</p>

<pre> <b>IterationStatement</b> :

   <b>for</b> <b>(</b> <b>;</b> <b>;</b> <i>Expression</i><sub>opt</sub> <b>)</b> <i>Statement</i>
   <b>for</b> <b>(</b> <b>;</b> <i>Expression</i> <b>;</b> <i>Expression</i><sub>opt</sub><b>)</b> <i>Statement</i>
   <b>for</b> <b>(</b> <i>ExpressionNoIn</i> <b>;</b> <b>;</b> <i>Expression</i><sub>opt</sub><b>)</b> <i>Statement</i>
   <b>for</b> <b>(</b> <i>ExpressionNoIn</i> <b>;</b> <i>Expression</i> <b>;</b> <i>Expression</i><sub>opt</sub><b>)</b> <i>Statement</i></pre>

<p>是以下的一种缩写：</p>

<pre> IterationStatement :

   <b>for</b> <b>(</b> <b>;</b> <b>;</b> <b>)</b> <i>Statement</i>
   <b>for</b> <b>(</b> <b>;</b> <b>;</b> <i>Expression</i> <b>)</b> <i>Statement</i>
   <b>for</b> <b>(</b> <b>;</b> <i>Expression</i> <b>;</b> <b>)</b> <i>Statement</i>
   <b>for</b> <b>(</b> <b>;</b> <i>Expression</i> <b>;</b> <i>Expression</i> <b>)</b> <i>Statement</i>
   <b>for</b> <b>(</b> <i>ExpressionNoIn</i> <b>;</b> <b>;</b> <b>)</b> <i>Statement</i>
   <b>for</b> <b>(</b> <i>ExpressionNoIn</i> <b>;</b> <b>;</b> <i>Expression</i> <b>)</b> <i>Statement</i>
   <b>for</b> <b>(</b> <i>ExpressionNoIn</i> <b>;</b> <i>Expression</i> <b>;</b> <b>)</b> <i>Statement</i>
   <b>for</b> <b>(</b> <i>ExpressionNoIn</i> <b>;</b> <i>Expression</i> <b>;</b> <i>Expression</i> <b>)</b> <i>Statement</i></pre>

<p>因此，非终结 <i>IterationStatement</i> 实际上有 8 个右侧变体。</p>

<p>如果文法定义的冒号后面出现文字“one of”，那么其后一行或多行出现的每个终结符都是一个选择定义。例如，ECMAScript 包含的词法文法生产器：
</p>
<pre>
NonZeroDigit :: one of
1 2 3 4 5 6 7 8 9
</pre>

<p>这仅仅下面写法的一种缩写：</p>
<pre>
NonZeroDigit ::
1
2
3
4
5
6
7
8
9
</pre>
<p>如果产生式的右侧是出现“[empty]”，它表明，产生式的右侧不包含终结符或非终结符。</p>

<p>如果产生式的右侧出现“[lookahead ∉ set]”，它表明，给定 set 的成员不得成为产生式紧随其后的 token。这个 set 可以写成一个大括号括起来的终结符列表。为方便起见，set 也可以写成一个非终结符，在这种情况下，它代表了这个非终结符 set 可扩展所有终结符。例如，给出定义</p>

<pre> <i>DecimalDigit</i> :: <b>one of</b>

   <b>0 1 2 3 4 5 6 7 8 9</b></pre>

<pre> <i>DecimalDigits</i> ::

   <i>DecimalDigit</i>
   <i>DecimalDigits</i> <i>DecimalDigit</i></pre>

<p>在定义</p>

<pre> <i>LookaheadExample</i> ::

   <b>n</b> [lookahead ∉ {<b>1</b> , <b>3</b> , <b>5</b> , <b>7</b> , <b>9</b>}]<i>DecimalDigits</i>
   <i>DecimalDigit</i> [lookahead ∉ <i>DecimalDigit</i> ]</pre>

<p>能匹配字母 <b>n</b> 后跟随由偶数起始的一个或多个十进制数字，或一个十进制数字后面跟随一个非十进制数字。</p>

<p>如果产生式的右侧出现“<i>[no LineTerminator here]</i>”，那么它表示此产生式是个受限的产生式：如果 <i>LineTerminator</i> 在输入流的指定位置出现，那么此产生式将不会被适用。例如，产生式：</p>

<pre>ThrowStatement :
    throw [no LineTerminator here] Expression ;</pre>

<p>表示如果程序中 <b>return</b> token 和 <i>Expression</i> 之间的出现 <i>LineTerminator</i>，那么不得使用此产生式。</p>

<p><i>LineTerminator</i> 除了禁止出现在受限的产生式，可以在输入元素流的任何两个 tokens 之间出现任意次数，而不会影响程序的句法验证。</p>

<p>当一个词法文法产生式或数字字符串文法中出现多字符 token，它表示此字符序列将注册一个 token。</p>

<p>使用词组“<b>but not</b>“可以指定某些不允许在产生式右侧的扩展，它说明排除这个扩展。例如，产生式：</p>

<pre> <i>Identifier</i> ::

   <i>IdentifierName</i> <b>but not</b> <i>ReservedWord</i></pre>

<p>此非终结符 <i>Identifier</i> 可以由可替换成 <i>IdentifierName</i> 的字符序列替换，相同的字符序列不能替换 <i>ReservedWord</i>。</p>

<p>最后，对于实际上不可能列出全部可变元的少量非终结符，我们用普通字体写出描述性的短语来描述它们：</p>

<pre> <i>SourceCharacter</i> ::

   any Unicode code unit</pre>


<h4>算法约定</h4>

<p>此规范通常使用带编号的列表来指定算法的步骤。这些算法是用来精确地指定 ECMAScript 语言结构所需的语义。该算法无意暗示任何具体实现使用的技术。在实践中，也许可用更有效的算法实现一个给定功能。</p>

<p>为了方便其使用本规范的多个部分，叫做 <i>抽象操作 (abstract operations)</i> 的一些算法编写成带名称的可传参函数化形式，所以在其他算法里可以通过名称引用它们。</p>

<p>当一个算法产生返回值 ，“<i>return x</i>” 指令说明该算法的返回值是 <i>x</i>，并且算法应该终止。“第 <i>n</i> 步的结果”的简写是 Result(<i>n</i>) 。</p>

<p>为了表达清晰，算法的步骤可细分为有序的子步骤。子步骤被缩进，可以将自身进一步划分为缩进子步骤。大纲编号约定用于识别分步骤，第一层次的子步骤适用小写字母标记，第二层次的子步骤使用小写罗马数字标记。如果需要超过三个层次，则重复这些规则，第四层次使用数字标记。例如 :</p>

<ol>
  <li>
    <p>Top-level step</p>

    <ol>
      <li>
        <p>Substep.</p>
      </li>

      <li>
        <p>Substep</p>

        <ol>
          <li>
            <p>Subsubstep.</p>
          </li>

          <li>
            <p>Subsubstep.</p>

            <ol>
              <li>
                <p>Subsubsubstep</p>

                <ol>
                  <li>
                    <p>Subsubsubsubstep</p>
                  </li>
                </ol>
              </li>
            </ol>
          </li>
        </ol>
      </li>
    </ol>
  </li>
</ol>

<p>一个步骤或子步骤可写“if”谓词作为它的子步骤的条件。在这种情况下，当谓词为真时子步骤才适用。如果一个步骤或子步骤由单词“else”开始，那么它是一个谓词，否定前面的同一层级的“if”谓词。</p>

<p>一个步骤可以表示其子步骤的迭代应用可能指定其子步的迭代应用程序。</p>

<p>A step may assert an invariant condition of its algorithm. Such assertions are used to make explicit algorithmic invariants that would otherwise be implicit. Such assertions add no additional semantic requirements and hence need not be checked by an implementation. They are used simply to clarify algorithms.</p>

<p>数学运算，如加法，减法，取反，乘法，除法，还有稍后在本节中定义的数学函数应该总是被理解为对数学实数计算精确的数学结果，其中不包括无穷大，不包括负零区别于正零。本标准中的浮点运算算法模型，包括明确的步骤，在必要情况下处理无穷大和有符号零和执行四舍五入。如果一个数学运算或函数应用一个浮点数，它应该被应用为代表此浮点数的确切的数学值，一个浮点数必须是有限的 ，如果是 <b>+0</b> 或 <b>-0</b> ，则相应的数学值就是 <b>0</b>。</p>

<p>数学函数 <i>abs(x)</i> 产生 <i>x</i> 的绝对值，如果 <i>x</i> 是负数（小于零），它是这是 - <i>x</i>，否则是 <i>X</i> 本身。</p>

<p>如果 <i>x</i> 是正数，数学函数 <i>sign (x)</i> 产生 1，如果 <i>x</i> 是负数产生 - <i>1</i>。此标准中 x 为零的情况下不使用 sign 函数。</p>

<p>符号 “<i>x modulo y</i>” (y 必须有限且非零 ) 计算一个满足以下条件的 k 值 ，与 y 同号 ( 或是零 ) ，abs(k) < abs(y) ，对一些整数 q 满足 x−k = q × y。</p>

<p>数学函数 floor(x) 产生不大于 x 的最大整数（最大可为正无穷）。</p>

<div>
<p><b>note</b> floor(x) = x−(x modulo 1).</p>

<p>如果算法定义“抛出一个异常”，算法的执行将被终止，且没有返回结果。已调用的算法也被终止，直到算法步骤使用术语“如果一个异常被抛出 ...”明确指出异常处理。一旦遇到这种算法步骤，异常将不再被视已发生过。</p>

</div>

<h4>源代码文本</h4>

<p>用 3.0 或更高版本 Unicode 字符编码的一个字符序列来表示 ECMAScript 源文本。该文本预期已经正常化为 Unicode Technical Report #15 中描述的 Unicode 正常化形式 C（canonical composition）。符合 ECMAScript 的实现不要求对文本执行正常化，也不要求将其表现为像执行了正常化一样。为了目的，此规范 ECMAScript 的源文本被假定为一个 16 位代码单元，本规范的目的序列。这样的包含 16 位代码单元序列的源文本可能不是有效的的 UTF-16 字符编码。如果实际的源文本没有用 16 位代码单元形式编码，那么必须把它看作已经转换为 UTF-16 一样处理。</p>

<p>语法</p>
<pre> <i>SourceCharacter</i> ::

   any Unicode code unit</pre>

<p>贯穿本文档，短语“代码单元 (code unit)”和单词“字符 (character)”特指表示文本的单个 16 位单元的 16 位无符号值。短语“Unicode 字符 (Unicode character)”特指单个 Unicode 标量值（这可能大于 16 位，因此它可能代表多个代码单位）表示的语言或排版上的抽象单位。短语“代码点 (code point)”是指这样一个 Unicode 标量值。“Unicode 字符”仅指由单一的 Unicode 标量值表示的实体：组合字符序列的每个组成部分都是单个“Unicode 字符”，尽管用户可能会认为整个序列是单个字符。</p>

<p>在字符串字面量，正则表达式字面量，标识符中的任意字符（代码单元），可以是由六个字符组成的 Unicode 转义序列，即 <b>\u</b> 加上四个 16 进制数字。在注释中，这样的转义序列被当作注释的一部分忽略掉。在字符串字面量或正则表达式字面量中，Unicode 转义序列会给字面量值贡献一个字符。在标识符中，转义序列给标识符贡献一个字符。</p>

<p><b>note</b> 虽然本文档有时会提到“字符串 (string)”里的“字符 (character)”和代表字符代码单元的 16 位无符号整数间的“变换 (transformation)”。事实上并没有变换，因为实际上就是用 16 位无符号值代表“字符串”里的“字符”。</p>

<p>ECMAScript 与 Java 编程语言对 Unicode 转义序列有不同的解释。在 Java 程序中，如果 Unicode 转义序列 <b>\u000A</b> 出现在单行注释中，它会被解释成行终止符（Unicode 字符<b>000A</b> 是换行），因此接下来的一个字符不是注释的一部分。与此类似，如果 Java 程序中的字符串字面量里出现 Unicode 转义序列 <b>\u000A</b>，它同样会被解释成行终止符，字符串字面量里不允许出现行终止符，不得不将作为字符串字面量字符值的换行符的 <b>\u000A</b> 替换成 <b>\n</b>。在 ECMAScript 程序中，始终不会解释注释里出现的 Unicode 转义序列，因此无法给注释贡献终止符。与此类似，如果 ECMAScript 程序中的字符串字面量里出现 Unicode 转义序列，它始终会贡献一个字符给字面量值，并且始终不会解释成有可能终止字符串字面量的行终止符或引号标记。</p>



<h4>词法</h4>

<p>ECMAScript 程序的源文本首先转换成一个输入元素序列；tokens，行终止符，注释，空白构成输入元素序列。从左到右扫描源文本，反复获取作为下一个输入元素的尽可能长的字符序列。</p>

<p>词法文法有两个目标符。<i>InputElementDiv</i> 目标符用在允许除法 (<b>/</b>) 或除赋值 (<b>/=</b>) 运算符开始的句法文法上下文中。<i>InputElementRegExp</i> 目标符用在其他句法文法上下文。</p>

<div><p>注： 没有允许除法或除赋值运算符开头，同时又允许 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=RegularExpressionLiteral&action=edit&redlink=1">RegularExpressionLiteral</a> 开头的句法文法上下文。这不会被分号插入（见 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=7.9&action=edit&redlink=1">7.9</a>）影响；如下面的例子：</p>

<pre> a = b 
 /hi/g.exec(c).map(d);</pre>

<p>其中 <i>LineTerminator</i> 后的第一个非空白，非注释字符是斜线（<b>/</b>），并且这个句法上下文允许除法或除赋值运算符，所以不会在这个 <i>LineTerminator</i> 位置插入分号。也就是说，上面的例子解释为：</p>

<pre> a = b / hi / g.exec(c).map(d);</pre>
</div>

<p>语法：</p>

<pre> InputElementDiv ::

   WhiteSpace
   LineTerminator
   Comment
   Token
   DivPunctuator</pre>

<pre> InputElementRegExp ::

   WhiteSpace
   LineTerminator
   Comment
   Token
   RegularExpressionLiteral</pre>


<h4>Unicode 格式控制字符</h4>

<p>Unicode 格式控制字符（即，Unicode 字符数据库中“Cf”分类里的字符，如“左至右符号 (left-to-right mark)”或“右至左符号 (left-to-right mark)”）是用来控制被更高层级协议（如标记语言）忽略的文本范围的格式的控制代码。</p>

<p>允许在源文本中出现控制字符是有用的，以方便编辑和显示。所有格式控制字符可写入到注释，字符串字面量，正则表达式字面量中。</p>

<p>在某些语言中和控制字符用于创建必要的的分隔符分割词或短语。在 ECMAScript 源文本里，和还可以用在一个标识符后的第一个字符。</p>

<p>控制字符主要出现的文本的开头，标记它是 Unicode，并允许检测文本的编码和字节顺序。用于这一目的字符，有时也可能出现在文本开始的后面，例如，一个合并的文件。字符被视为空白字符（见 [7.2]）。</p>

<p>表 1 总结了一些在注释，字符串字面量，正则表达式字面量之外被特殊对待的格式控制字符。</p>

<div>
<p>Table 1 - Format-Control Character Usage</p>

<p>Code Unit Value
  <br />Name

  <br />Formal Name

  <br />Usage</p>

<p>\u200C
  <br />Zero width non-joiner

  <br /><ZWNJ>

  <br /><i>IdentifierPart</i></p>

<p>\u200D
  <br />Zero width joiner

  <br /><ZWJ>

  <br /><i>IdentifierPart</i></p>

<p>\uFEFF
  <br />Byte Order Mark

  <br /><BOM>

  <br /><i>Whitespace</i></p>

</div>

<h4>空白字符</h4>

<p>空白字符用来改善源文本的可读性和分割 tokens（不可分割的词法单位），此外就无关紧要。空白字符可以出现的两个 token 之间还可以出现在输入的开始或结束位置。空白字符，还可以出现在字符串 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=%E5%AD%97%E9%9D%A2%E9%87%8F_(StringLiteral)&action=edit&redlink=1">字面量 (StringLiteral)</a> 或正则 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%97%E9%9D%A2%E9%87%8F_(RegularExpressionLiteral)&action=edit&redlink=1">表达式字面量 (RegularExpressionLiteral)</a>( 在这里它表示组成字面量的字符 ) 或 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=%E6%B3%A8%E9%87%8A_(Comment)&action=edit&redlink=1">注释 (Comment)</a> 中，但是不能出现的其他任何 token 内。</p>

<p>表 2 中列出了 ECMAScript 空白字符。</p>

<div>

<p>Table 2 — Whitespace Characters</p>

<p>Code Unit Value
  <br />Name

  <br />Formal Name</p>

<p>\u0009
  <br />Tab

  <br /><TAB></p>

<p>\u000B
  <br />Vertical Tab

  <br /><VT></p>

<p>\u000C
  <br />Form Feed

  <br /><FF></p>

<p>\u0020
  <br />Space

  <br /><SP></p>

<p>\u00A0
  <br />No-break space

  <br /><NBSP></p>

<p>\uFEFF </p>

<p>Other category "Zs"</p>

<p>Byte Order Mark </p>

<p>Any other Unicode “space separator”</p>

<p><BOM> </p>

<p><USP></p></div>

<p>ECMAScript 实现必须认可 Unicode 3.0 中定义的所有空白字符。后续版本的 Unicode 标准可能定义其他空白字符。ECMAScript 实现可以认可更高版本 Unicode 标准里的空白字符。</p>

<p>语法：</p>

<pre> WhiteSpace ::

   <TAB>
   <VT>
   <FF>
   <SP>
   <NBSP>
   <BOM>
   <USP></pre>


<h4>行终止符</h4>

<p>像空白字符一样，行终止字符用于改善源文本的可读性和分割 tokens（不可分割的词法单位）。然而，不像空白字符，行终止符对句法文法的行为有一定的影响。一般情况下，行终止符可以出现在任何两个 token 之间，但也有少数地方，句法文法禁止这样做。行终止符也影响自动插入分号过程（<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=7.9&action=edit&redlink=1">7.9</a>）。行终止符不能出现在 <i><a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=StringLiteral&action=edit&redlink=1">StringLiteral</a></i> 之外的任何 token 内。行终止符只能出现在作为 <i>LineContinuation</i> 一部分的 <i><a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=StringLiteral&action=edit&redlink=1">StringLiteral</a></i> token 里。</p>

<p>行终止符可以出现在 <i>MultiLineComment</i>（<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=7.4&action=edit&redlink=1">7.4</a>）内，但不能出现在 <i>SingleLineComment</i> 内。</p>

<p>正则表达式的 <b>\s</b> 类匹配的空白字符集中包含行终止符。</p>

<p>表 3 列出了 ECMAScript 的行终止字符。</p>

<div>
<p>Table 3 — Line Terminator Characters</p>

<p>Code Unit Value
  <br />Name

  <br />Formal Name</p>

<p>\u000A
  <br />Line Feed

  <br /><LF></p>

<p>\u000D
  <br />Carriage Return

  <br /><CR></p>

<p>\u2028
  <br />Line separator

  <br /><LS></p>

<p>\u2029
  <br />Paragraph </p>

<p>separator</p>

<p><PS></p></div>

<p>只有表 3 中的字符才被视为行终止符。其他新行或折行字符被视为空白，但不作为行终止符。字符序列 <CR><LF> 作一个行终止符。计算行数时它应该被视为一个字符。</p>

<p>语法：</p>

<pre> LineTerminator ::

   <LF>
   <CR>
   <LS>
   <PS></pre>

<pre> LineTerminatorSequence ::

   <LF>
   <CR> [lookahead ∉  ]
   <LS>
   <PS>
   <CR> <LF></pre>


<h4>注释</h4>

<p>注释可以是单行或多行。多行注释不能嵌套。</p>

<p>因为单行注释可以包含除了 <i>LineTerminator</i> 字符之外的任何字符，又因为有一般规则：一个 token 总是尽可能匹配更长，所以一个单行注释总是包含从 <b>//</b> 到行终止符之间的所有字符。然而，在该行末尾的 <i>LineTerminator</i> 不被看成是单行注释的一部分，它被词法文法识别成句法文法输入元素流的一部分。这一点非常重要，因为这意味着是否存在单行注释都不影响自动分号插入进程（见 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=7.9&action=edit&redlink=1">7.9</a>）。</p>

<p>像空白一样，注释会被句法文法简单丢弃，除了 <i>MultiLineComment</i> 包含行终止符字符的情况，这种情况下整个注释会当作一个 <i>LineTerminator</i> 提供给句法文法解析。</p>

<p>语法：</p>

<pre> Comment ::

   MultiLineComment
   SingleLineComment</pre>

<pre> MultiLineComment ::

   <b>/*</b> MultiLineCommentChars<sub>opt</sub><b>*/</b></pre>

<pre> MultiLineCommentChars ::

   MultiLineNotAsteriskChar MultiLineCommentChars<sub>opt</sub>
   <b>*</b> PostAsteriskCommentChars<sub>opt</sub></pre>

<pre> PostAsteriskCommentChars ::

   MultiLineNotForwardSlashOrAsteriskChar MultiLineCommentChars<sub>opt</sub>
   <b>*</b> PostAsteriskCommentChars<sub>opt</sub></pre>

<pre> MultiLineNotAsteriskChar ::

   SourceCharacter <b>but not</b> asterisk <b>*</b></pre>

<pre> MultiLineNotForwardSlashOrAsteriskChar ::

   SourceCharacter <b>but not</b> forward-slash <b>/</b> <b>or</b> asterisk <b>*</b></pre>

<pre> SingleLineComment ::

   <b>//</b> SingleLineCommentChars<sub>opt</sub></pre>

<pre> SingleLineCommentChars ::

   SingleLineCommentChar SingleLineCommentChars<sub>opt</sub></pre>

<pre> SingleLineCommentChar ::

   SourceCharacter <b>but not</b> LineTerminator</pre>


<h4>Tokens</h4>

<p>语法：</p>

<pre> Token ::

   IdentifierName
   Punctuator
   NumericLiteral
   StringLiteral</pre>

<p>注： DivPunctuator 和 RegularExpressionLiteral 产生式定义 tokens ，但 Token 的产生式不包含它们。</p>



<h4>标识符名和标识符</h4>

<p>标识符名是 tokens，Unicode 标准第 5 章的“标识符”节给出的文法加入了一些小的修改来解释它。<i>Identifier</i> 是一个 <i>IdentifierName</i> 但不是一个 <i>ReservedWord</i>( 见 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=7.6.1&action=edit&redlink=1">7.6.1</a>)。Unicode 标识符文法基于 Unicode 标准指出的 normative 和 informative 字符分类。所有符合 ECMAScript 的实现必须能够正确处理 Unicode 标准 3.0 版本中指定的分类里的字符的分类。</p>

<p>本标准增加了个别字符：在 <i>IdentifierName</i> 的任何位置允许出现美元符（$）和下划线（_）。</p>

<p><i>IdentifierName</i> 还允许出现 Unicode 转义序列，它们被 <i>UnicodeEscapeSequence</i> 的 CV 计算成单个字符贡献给 <i>IdentifierName</i>（见 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=7.8.4&action=edit&redlink=1">7.8.4</a>）。<i>UnicodeEscapeSequence</i> 前面的 \ 不给<i>IdentifierName</i> 贡献字符。<i>UnicodeEscapeSequence</i> 不能提供单个字符给将要成为非法字符的 <i>IdentifierName</i>。换句话说，如果一个 \ <i>UnicodeEscapeSequence</i> 序列被<i>UnicodeEscapeSequence</i> 的 CV 替换，结果必须仍是有效的包含与原 <i>IdentifierName</i> 精确相同字符序列的 <i>IdentifierName</i>。本规范说明的所有标识符是根据它的实际字符，不管转义序列贡献特定字符与否。</p>

<p>根据 Unicode 标准两个规范的 IdentifierName 相等，是说除非他们的代码单元序列准确相等，否则不同（换句话说，符合 ECMAScript 的实现只需要按位比较 IdentifierName 值）。其目的是为了传入编译器之前就把源文本转换为正常化形式 C。</p>

<p>ECMAScript 实现可以识别后续版本 Unicode 标准定义的标识符字符。如果考虑可移植性，程序员应该只采用 Unicode 3.0 中定义的标识符字符。</p>

<p>语法：</p>

<pre> Identifier ::

   IdentifierName <b>but not</b> ReservedWord</pre>

<pre> IdentifierName ::

   IdentifierStart
   IdentifierName IdentifierPart</pre>

<pre> IdentifierStart ::

   UnicodeLetter
   $
   _
   \ UnicodeEscapeSequence</pre>

<pre>  IdentifierPart ::

   IdentifierStart
   UnicodeCombiningMark
   UnicodeDigit
   UnicodeConnectorPunctuation
   <ZWNJ>
   <ZWJ></pre>

<pre> UnicodeLetter

   any character in the Unicode categories 
   “Uppercase letter (Lu)”, “Lowercase letter (Ll)”, 
   “Titlecase letter (Lt)”, “Modifier letter (Lm)”,
   “Other letter (Lo)”,or “Letter number (Nl)”.</pre>

<pre> UnicodeCombiningMark

   any character in the Unicode categories “Non-spacing mark (Mn)”\\\
   or “Combining spacing mark (Mc)”</pre>

<pre> UnicodeDigit

   any character in the Unicode category “Decimal number (Nd)”</pre>

<pre> UnicodeConnectorPunctuation

   any character in the Unicode category “Connector punctuation (Pc)”</pre>

<pre> UnicodeEscapeSequence

   see 7.8.4.</pre>


<h5>保留字</h5>

<p>保留字不能作为 Identifier 的 IdentifierName。</p>

<p>语法</p>

<pre> ReservedWord ::

   Keyword
   FutureReservedWord
   NullLiteral
   BooleanLiteral</pre>


<h6>关键词</h6>

<p>下列 token 是 ECMAScript 的关键词，不能用作 ECMAScript 程序的 <i>Identifiers</i>。</p>

<p>语法</p>

<pre> Keyword :: one of

    break      do         instanceof        typeof

    case       else       new               var

    catch      finally    return            void

    continue   for        switch            while

    debugger   function   this              with

    default    if         throw             delete

    in         try</pre>


<h6>未来保留字</h6>

<p>下列词被用作建议扩展关键字，因此保留，以便未来可能采用这些扩展。</p>

<p>语法</p>

<pre> FutureReservedWord :: one of

    class      enum       extends       super

    const      export     import</pre>

<p>当下列 tokens 出现在 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E4%BB%A3%E7%A0%81_(strict_mode_code_)&action=edit&redlink=1">严格模式代码 (strict mode code )</a>（见 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=10.1.1&action=edit&redlink=1">10.1.1</a>）里，将被当成是 <i>FutureReservedWords</i>。任意这些 tokens 出现在任意上下文中的严格模式代码 (strict mode code) 中，如果 <i>FutureReservedWord</i> 出现的位置会产生错误，那么必须抛出对应的异常：</p>

<pre> implements      let         private       public      yield

 interface       package     protected     static</pre>


<h4>标点符号</h4>

<p>语法</p>

<pre> Punctuator :: one of
   {       }       (       )       [       ]
   .  ;       ,       <       >       <=
   >=      ==  !=      ===  !==
   +       -       *  %       ++      --
   <<      >>      >>>     &       |       ^  !       ~       &&      ||  ?  :
   =       +=      -=      *=  %=      <<=
   >>=     >>>=    &=      |=      ^=</pre>

<pre> DivPunctuator :: one of
   /       /=</pre>


<h4>字面量</h4>

<p>语法</p>

<pre> Literal ::
   NullLiteral
   BooleanLiteral
   NumericLiteral
   StringLiteral 
   RegularExpressionLiteral</pre>


<h5>空值字面量</h5>

<p>语法：</p>

<pre> NullLiteral ::
   <b>null</b></pre>

<p>语义：</p>

<p>空值字面量的值 null，是 Null 类型的唯一值。</p>



<h5>布尔值字面量</h5>

<p>语法：</p>

<pre> BooleanLiteral ::
   <b>true</b>
   <b>false</b></pre>

<p>语义：</p>

<p>布尔值字面量的值 true 是个布尔类型值 ，即 true。 </p>
<p>布尔值字面量的值 false 是个布尔类型值 ，即 false。</p>



<h5>数值字面量</h5>

<p>语法：</p>

<pre> NumericLiteral ::
   DecimalLiteral
   HexIntegerLiteral</pre>

<pre> DecimalLiteral ::
   DecimalIntegerLiteral . DecimalDigits<sub>opt</sub> ExponentPart<sub>opt</sub>
   <b>.</b> DecimalDigits ExponentPart<sub>opt</sub>
   DecimalIntegerLiteral ExponentPart<sub>opt</sub></pre>

<pre> DecimalIntegerLiteral ::
   <b>0</b>
   NonZeroDigit DecimalDigits<sub>opt</sub></pre>

<pre> DecimalDigits ::
   DecimalDigit
   DecimalDigits DecimalDigit</pre>

<pre> DecimalDigit :: one of
  <b> 0 1 2 3 4 5 6 7 8 9</b></pre>

<pre> NonZeroDigit :: one of
   <b>1 2 3 4 5 6 7 8 9</b></pre>

<pre> ExponentPart ::
   ExponentIndicator SignedInteger</pre>

<pre> ExponentIndicator :: one of
   <b>e E</b></pre>

<pre> SignedInteger ::
   DecimalDigits
   <b>+</b> DecimalDigits
   <b>-</b> DecimalDigits</pre>

<pre> HexIntegerLiteral ::
   <b>0x</b> HexDigit
   <b>0X</b> HexDigit
   HexIntegerLiteral HexDigit</pre>

<pre> HexDigit :: one of
   <b>0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F</b></pre>

<p>源字符中的 <i>NumericLiteral</i> 后面不允许紧跟着 <i>IdentifierStart</i> 或 <i>DecimalDigit</i>。</p>

<div>
<p>注： 例如： </p>

<p>3in</p>

<p>是错误的，不存在两个输入元素 3 和 in。</p></div>

<p>语义：</p>

<p>一个数值字面量代表一个 Number 类型的值。此值取决于两个步骤：第一，由字面量得出的数学值 (mathematical value)（MV）；第二，这个数学值按照后面描述的规则舍入。</p>

<ul>
  <li>NumericLiteral::DecimalLiteral 的 MV 是 DecimalLiteral 的 MV。</li>



  <li>NumericLiteral :: HexIntegerLiteral 的 MV 是 HexIntegerLiteral 的 MV。</li>



  <li>DecimalLiteral :: DecimalIntegerLiteral . 的 MV 是 DecimalIntegerLiteral 的 MV 是。</li>



  <li>DecimalLiteral :: DecimalIntegerLiteral . DecimalDigits 的 MV 是 DecimalIntegerLiteral 的 MV 加上 (DecimalDigits 的 MV 乘 10-n), 这里的 n 是 DecimalDigits 的字符个数。</li>



  <li>DecimalLiteral :: DecimalIntegerLiteral . ExponentPart 的 MV 是 DecimalIntegerLiteral 的 MV 乘 10e, 这里的 e 是 ExponentPart 的 MV。</li>



  <li>DecimalLiteral :: DecimalIntegerLiteral . DecimalDigits ExponentPart 的 MV 是 (DecimalIntegerLiteral 的 MV 加 (DecimalDigits 的 MV 乘 10-n)) 乘 10e, 这里的 n 是 DecimalDigits 的字符个数，e 是 ExponentPart 的 MV。</li>



  <li>DecimalLiteral ::. DecimalDigits 的 MV 是 DecimalDigits 的 MV 乘 10-n, 这里的 n 是 DecimalDigits 的字符个数。</li>



  <li>DecimalLiteral ::. DecimalDigits ExponentPart 的 MV 是 DecimalDigits 的 MV 乘 10e-n, 这里的 n 是 DecimalDigits 的字符个数，e 是 ExponentPart 的 MV。</li>



  <li>DecimalLiteral :: DecimalIntegerLiteral 的 MV 是 DecimalIntegerLiteral 的 MV。</li>



  <li>DecimalLiteral :: DecimalIntegerLiteral ExponentPart 的 MV 是 DecimalIntegerLiteral 的 MV 乘 10e, 这里的 e 是 ExponentPart 的 MV。</li>



  <li>DecimalIntegerLiteral :: 0 的 MV 是 0。</li>



  <li>DecimalIntegerLiteral :: NonZeroDigit DecimalDigits 的 MV 是 (NonZeroDigit 的 MV 乘 10n) 加 DecimalDigits 的 MV, 这里的 n 是 DecimalDigits 的字符个数。</li>



  <li>DecimalDigits :: DecimalDigit 的 MV 是 DecimalDigit 的 MV。</li>



  <li>DecimalDigits :: DecimalDigits DecimalDigit 的 MV 是 (DecimalDigits 的 MV 乘 10) 加 DecimalDigit 的 MV。</li>



  <li>ExponentPart :: ExponentIndicator SignedInteger 的 MV 是 SignedInteger 的 MV。</li>



  <li>SignedInteger :: DecimalDigits 的 MV 是 DecimalDigits 的 MV。</li>



  <li>SignedInteger :: + DecimalDigits 的 MV 是 DecimalDigits 的 MV。</li>



  <li>SignedInteger :: - DecimalDigits 的 MV 是 DecimalDigits 的 MV 取负。</li>



  <li>DecimalDigit :: 0 或 HexDigit :: 0 的 MV 是 0。</li>



  <li>DecimalDigit :: 1 或 NonZeroDigit :: 1 或 HexDigit :: 1 的 MV 是 1。</li>



  <li>DecimalDigit :: 2 或 NonZeroDigit :: 2 或 HexDigit :: 2 的 MV 是 2。</li>



  <li>DecimalDigit :: 3 或 NonZeroDigit :: 3 或 HexDigit :: 3 的 MV 是 3。</li>



  <li>DecimalDigit :: 4 或 NonZeroDigit :: 4 或 HexDigit :: 4 的 MV 是 4。</li>



  <li>DecimalDigit :: 5 或 NonZeroDigit :: 5 或 HexDigit :: 5 的 MV 是 5。</li>



  <li>DecimalDigit :: 6 或 NonZeroDigit :: 6 或 HexDigit :: 6 的 MV 是 6。</li>



  <li>DecimalDigit :: 7 或 NonZeroDigit :: 7 或 HexDigit :: 7 的 MV 是 7。</li>



  <li>DecimalDigit :: 8 或 NonZeroDigit :: 8 或 HexDigit :: 8 的 MV 是 8。</li>



  <li>DecimalDigit :: 9 或 NonZeroDigit :: 9 或 HexDigit :: 9 的 MV 是 9。</li>



  <li>HexDigit :: a 或 HexDigit :: A 的 MV 是 10。</li>



  <li>HexDigit :: b 或 HexDigit :: B 的 MV 是 11。</li>



  <li>HexDigit :: c 或 HexDigit :: C 的 MV 是 12。</li>



  <li>HexDigit :: d 或 HexDigit :: D 的 MV 是 13。</li>



  <li>HexDigit :: e 或 HexDigit :: E 的 MV 是 14。</li>



  <li>HexDigit :: f 或 HexDigit :: F 的 MV 是 15。</li>



  <li>HexIntegerLiteral :: 0x HexDigit 的 MV 是 HexDigit 的 MV。</li>



  <li>HexIntegerLiteral :: 0X HexDigit 的 MV 是 HexDigit 的 MV。</li>



  <li>HexIntegerLiteral :: HexIntegerLiteral HexDigit 的 MV 是 (HexIntegerLiteral 的 MV 乘 16) 加 HexDigit 的 MV。</li>
</ul>

<p>数值字面量的确切 MV 值一旦被确定，它就会舍入成 Number 类型的值。如果 MV 是 0，那么舍入值是 +0；否则，舍入值必须是 MV 对应的准确数字值（8.5 中定义），除非此字面量是有效数字超过 20 位的 <i>DecimalLiteral</i>，这种情况下，数字值可以用下面两种方式产生的 MV 值确定：一，将 20 位后的每个有效数字用 0 替换后产生的 MV，二，将 20 位后的每个有效数字用 0 替换，并且递增第 20 位有效数字位置的字面量值，产生的 MV。如果一个数字是 <i>ExponentPart</i> 的一部分，并且：</p>

<ul>
  <li>它不是 0；或</li>
  <li>它的左侧是非零数字，它的右侧是不在 <i>ExponentPart</i> 的非零数字。</li>
</ul>

<p>符合标准的实现，在处理严格模式代码（见 10.1.1）时，按照 B.1.1 的描述，不得扩展 <i>NumericLiteral</i> 包含 <i>OctalIntegerLiteral</i> 的语法。</p>



<h5>字符串字面量</h5>

<p>一个字符串字面量是关闭的单引号或双引号里的零个或多个字符。每个字符都可以用一个转义序列代表。除了闭合银行字符，反斜杠，回车，行分隔符，段落分隔符，换行符之外的所有字符都可以直接出现的字符串字面量里。任何字符都可以通过转移序列的形式出现。</p>

<p>语法</p>

<pre> StringLiteral ::
   <b>"</b> DoubleStringCharacters<sub>opt</sub> <b>"</b>
   <b>'</b> SingleStringCharacters<sub>opt</sub> <b>'</b></pre>

<pre> DoubleStringCharacters ::
   DoubleStringCharacter DoubleStringCharacters<sub>opt</sub></pre>

<pre> SingleStringCharacters ::
   SingleStringCharacter SingleStringCharacters<sub>opt</sub></pre>

<pre> DoubleStringCharacter ::
   SourceCharacter <b>but not</b> double-quote <b>" or</b> backslash <b>\ or</b> LineTerminator
   <b>\</b> EscapeSequence
   LineContinuation</pre>

<pre> SingleStringCharacter ::
   SourceCharacter <b>but not</b> single-quote <b>' or</b> backslash <b>\ or</b> LineTerminator
   <b>\</b> EscapeSequence
   LineContinuation</pre>

<pre> LineContinuation ::
   <b>\</b> LineTerminatorSequence</pre>

<pre> EscapeSequence ::
   CharacterEscapeSequence
   <b>0</b> [lookahead ∉ DecimalDigit]
   HexEscapeSequence
   UnicodeEscapeSequence</pre>

<pre> CharacterEscapeSequence ::
   SingleEscapeCharacter
   NonEscapeCharacter</pre>

<pre> SingleEscapeCharacter :: <b>one of</b>
   <b>' " \ b f n r t v</b></pre>

<pre> NonEscapeCharacter ::
   SourceCharacter <b>but not</b> EscapeCharacter <b>or</b> LineTerminator</pre>

<pre> EscapeCharacter ::
   SingleEscapeCharacter
   DecimalDigit
   <b>x</b>
   <b>u</b></pre>

<pre> HexEscapeSequence ::
   <b>x</b> HexDigit HexDigit</pre>

<pre> UnicodeEscapeSequence ::
   <b>u</b> HexDigit HexDigit HexDigit HexDigit</pre>

<p><a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=7.6&action=edit&redlink=1">7.6</a> 给出了 HexDigit 非终结符的定义。<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=%E7%AC%AC_6_%E7%AB%A0&action=edit&redlink=1"> 第 6 章 </a>定义了 SourceCharacter。</p>

<p>语义</p>

<p>一个字符串字面量代表一个 String 类型的值。字面量的字符串值 (SV) 由字符串字面量各部分贡献的字符值 (CV) 描述。作为这一过程的一部分，字符字面量里的某些字符字符会被解释成包含数学值 (MV)，如 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=7.8.3&action=edit&redlink=1">7.8.3</a> 和下面描述的。</p>

<ul>
  <li>StringLiteral :: "" 的 SV 是空字符序列。</li>



  <li>StringLiteral :: <i>的 SV 是空字符序列。</i></li>



  <li>StringLiteral :: " DoubleStringCharacters " 的 SV 是 DoubleStringCharacters 的 SV。</li>



  <li>StringLiteral :: ' SingleStringCharacters ' 的 SV 是 SingleStringCharacters 的 SV。</li>



  <li>DoubleStringCharacters :: DoubleStringCharacter 的 SV 是包含一个字符的序列，此字符的 CV 是 DoubleStringCharacter 的 CV。</li>



  <li>DoubleStringCharacters :: DoubleStringCharacter DoubleStringCharacters 的 SV 是 （DoubleStringCharacter 的 CV 后面跟着 DoubleStringCharacters 的 SV 里所有字符的）序列。</li>



  <li>SingleStringCharacters :: SingleStringCharacter 的 SV 是包含一个字符的序列，此字符的 CV 是 SingleStringCharacter 的 CV。</li>



  <li>SingleStringCharacters :: SingleStringCharacter SingleStringCharacters 的 SV 是（SingleStringCharacter 的 CV 后面跟着 SingleStringCharacters 的 SV 里所有字符的）序列。</li>



  <li>LineContinuation :: \ LineTerminatorSequence 的 SV 是空字符序列。</li>



  <li>DoubleStringCharacter :: SourceCharacter but not double-quote " or backslash \ or LineTerminator 的 CV 是 SourceCharacter 字符自身。</li>



  <li>DoubleStringCharacter :: \ EscapeSequence 的 CV 是 EscapeSequence 的 CV。</li>



  <li>DoubleStringCharacter :: LineContinuation 的 CV 是空字符序列。</li>



  <li>SingleStringCharacter :: SourceCharacter but not single-quote ' or backslash \ or LineTerminator 的 CV 是 SourceCharacter 字符自身。</li>



  <li>SingleStringCharacter :: \ EscapeSequence 的 CV 是 EscapeSequence 的 CV。</li>



  <li>SingleStringCharacter :: LineContinuation 的 CV 是空字符序列。</li>



  <li>EscapeSequence :: CharacterEscapeSequence 的 CV 是 CharacterEscapeSequence 的 CV。</li>



  <li>EscapeSequence :: 0 [lookahead ∉ DecimalDigit] 的 CV 是 <NUL> 字符（Unicode 值 0000）。</li>



  <li>EscapeSequence :: HexEscapeSequence 的 CV 是 HexEscapeSequence 的 CV。</li>



  <li>EscapeSequence :: UnicodeEscapeSequence 的 CV 是 UnicodeEscapeSequence 的 CV。</li>



  <li>CharacterEscapeSequence ::SingleEscapeCharacter 的 CV 是表格 4 里的 SingleEscapeCharacter 确定的代码单元值字符：

<div>
<p>Table 4 - String Single Character Escape Sequences</p>

<p>Escape Sequence
  <br />Code Unit Value

  <br />Name

  <br />Symbol</p>

<p>\b
  <br />\u0008

  <br />backspace

  <br /><BS></p>

<p>\t
  <br />\u0009

  <br />horizontal tab

  <br /><HT></p>

<p>\n
  <br />\u000A

  <br />line feed (new line)

  <br /><LF></p>

<p>\v
  <br />\u000B

  <br />vertical tab

  <br /><VT></p>

<p>\u00A0
  <br />No-break space

  <br /><NBSP></p>

<p>\f
  <br />\u000C

  <br />form feed

  <br /><FF></p>

<p>\r
  <br />\u000D

  <br />carriage return

  <br /><CR></p>

<p>\"
  <br />\u0022

  <br />double quote

  <br />"</p>

<p>\'
  <br />\u0027

  <br />single quote

  <br />'</p>

<p>\\
  <br />\u005C

  <br />backslash

  <br />\</p>
</div></li>

  <li>CharacterEscapeSequence :: NonEscapeCharacter 的 CV 是 NonEscapeCharacter 的 CV.</li>

  <li>NonEscapeCharacter :: SourceCharacter but not EscapeCharacter or LineTerminator 的 CV 是 SourceCharacter 字符自身 .</li>

  <li>HexEscapeSequence :: x HexDigit HexDigit 的 CV 是 ((16 乘第一个 HexDigit 的 MV) 加第二个 HexDigit 的 MV) 代码单元确定的字符。</li>

  <li>UnicodeEscapeSequence :: u HexDigit HexDigit HexDigit HexDigit 的 CV 是 (4096 乘第一个 HexDigit 的 MV) 加 (256 乘第二个 HexDigit 的 MV) 加 (16 乘第三个 HexDigit 的 MV) 加 ( 第四个 HexDigit 的 MV) 代码单元确定的字符。</li>
</ul>

<p>符合标准的实现，在处理严格模式代码（见 10.1.1）时，按照 B.1.2 的描述，不得扩展 <i>EscapeSequence</i> 包含 <i>OctalEscapeSequence</i> 的语法。</p>

<p>注： 行终止符不能出现在字符串字面量里，除非它成为 LineContinuation 的一部分产生空字符序列。让字符串字面量的字符串值包含行终止符的正确方法是使用转义序列，如 <b>\n</b>或 <b>\u000A</b>。</p>



<h5>正则表达式字面量</h5>

<p>正则表达式字面量是输入元素，每当字面量被评估时会转换为 RegExp 对象（见 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=15.10&action=edit&redlink=1">15.10</a>）。当一个程序中有两个正则表达式字面量评估成正则表达式对象，不能用 === 比较他们是否相等，即使两个字面量包含相同内容。RegExp 对象也可以在运行时使用 <b>new RegExp</b>（见 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=15.10.4&action=edit&redlink=1">15.10.4</a>）或以函数方式调用 <b>RegExp</b> 构造器来创建（见 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=15.10.3&action=edit&redlink=1">15.10.3</a>）。</p>

<p>下面的产生式描述了正则表达式字面量的语法，输入元素扫描器还用它搜索正则表达式字面量的结束位置。<i>RegularExpressionBody</i> 和 <i>RegularExpressionFlags</i> 包含的字符组成的字符串会直接传递给正则表达式构造器，在那里用更严格文法进行解析。一个实现可以扩展正则表达式构造器的文法。但它不能扩展 <i>RegularExpressionBody</i> 和 <i>RegularExpressionFlags</i> 产生式或使用这些产生式的产生式。</p>

<p>语法</p>

<pre> RegularExpressionLiteral ::
   <b>/</b> RegularExpressionBody <b>/</b> RegularExpressionFlags</pre>

<pre> RegularExpressionBody ::
   RegularExpressionFirstChar RegularExpressionChars</pre>

<pre> RegularExpressionChars ::
   [empty]
   RegularExpressionChars RegularExpressionChar</pre>

<pre> RegularExpressionFirstChar ::
   RegularExpressionNonTerminator <b>but not *or \or / or [</b>
   RegularExpressionBackslashSequence
   RegularExpressionClass</pre>

<pre> RegularExpressionChar ::
   RegularExpressionNonTerminator <b>but not \or / or [</b>
   RegularExpressionBackslashSequence
   RegularExpressionClass</pre>

<pre> RegularExpressionBackslashSequence ::
   <b>\</b> RegularExpressionNonTerminator</pre>

<pre> RegularExpressionNonTerminator ::
   SourceCharacter <b>but not</b> LineTerminator</pre>

<pre> RegularExpressionClass ::
   <b>[</b> RegularExpressionClassChars <b>]</b></pre>

<pre> RegularExpressionClassChars ::
   [empty]</pre>

<pre> RegularExpressionClassChars RegularExpressionClassChar
   RegularExpressionClassChar ::
   RegularExpressionNonTerminator <b>but not ]or \</b>
   RegularExpressionBackslashSequence</pre>

<pre> RegularExpressionFlags ::
   [empty]
   RegularExpressionFlags IdentifierPart</pre>

<p>注： 正则表达式字面量不能为空；并不是说正则表达式字面量不能代表空，字符 <b>//</b> 会启动一个单行注释。要指定一个空正则，使用：<b>/(?:)/</b> 。</p>

<p>语义</p>

<p>正则表达式字面量会评估为一个 Object 类型值，它是标准内置构造器 RegExp 的一个实例。此值取决于两个步骤：首先，展开组成正则表达式产生式 <i>RegularExpressionBody</i> 和<i>RegularExpressionFlags</i> 的字符，将其以未解析形式分别存成两个字符串 Pattern 和 Flags。然后，在每次评估字面量时创建新对象，仿佛使用 <b>new RegExp(Pattern, Flags)</b> 一样，这里的 RegExp 是标准内置构造器名。新构造的对象将成为 RegularExpressionLiteral 的值。如果调用 <b>new RegExp</b> 会产生 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=15.10.4.1&action=edit&redlink=1">15.10.4.1</a> 指定的错误，那么必须把错误当作是早期错误 ( 见 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=%E7%AC%AC_16_%E7%AB%A0&action=edit&redlink=1">第 16 章 </a>)。</p>



<h4>自动分号插入</h4>

<p>必须用分号终止某些 ECMAScript 语句 ( 空语句 , 变量声明语句 , 表达式语句 , <b>do-while</b> 语句 , <b>continue</b> 语句 , <b>break</b> 语句 , <b>return</b> 语句 ,<b>throw</b> 语句 )。这些分号总是明确的显示在源文本里。然而，为了方便起见，某些情况下这些分号可以在源文本里省略。描述这种情况会说：这种情况下给源代码的 token 流自动插入分号。</p>



<h5>自动分号插入规则</h5>

<p>分号插入有三个基本规则：</p>

<ol>
  <li>左到右解析程序，当遇到一个不符合任何文法产生式的 token（叫做 <i>违规 token(offending token)</i>），那么只要满足下面条件之一就在违规 token 前面自动插入分号。 

    <ul>
      <li>至少一个 <i>LineTerminator</i> 分割了违规 token 和前一个 token。 </li>

      <li>违规 token 是 <b>}</b>。</li>
    </ul>
  </li>

  <li>左到右解析程序，tokens 输入流已经结束，当解析器无法将输入 token 流解析成单个完整 ECMAScript<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=%E7%A8%8B%E5%BA%8F&action=edit&redlink=1"> 程序 </a>，那么就在输入流的结束位置自动插入分号。 </li>

  <li>左到右解析程序，遇到一个某些文法产生式允许的 token，但是此产生式是受限产生式，受限产生式的里紧跟在 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=No_LineTerminator_here&action=edit&redlink=1">no LineTerminator here</a> 后的第一个终结符或非终结符的 token 叫做受限的 token，当至少一个 <i>LineTerminator</i> 分割了受限的 token 和前一个 token，那么就在受限 token 前面自动插入分号。</li>
</ol>

<p>然而，上述规则有一个附加的优先条件：如果插入分号后解析结果是空语句，或如果插入分号后它成为 <b>for</b> 语句头部的两个分号之一（见 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=12.6.3&action=edit&redlink=1">12.6.3</a>），那么不会自动插入分号。</p>

<p>注： 文法里的受限产生式只限以下：</p>

<pre> PostfixExpression :
   LeftHandSideExpression [no LineTerminator here] <b>++</b> 
   LeftHandSideExpression [no LineTerminator here] <b>--</b></pre>

<pre> ContinueStatement :
   <b>continue</b> [no LineTerminator here] Identifier<b>;</b></pre>

<pre> BreakStatement :
   <b>break</b> [no LineTerminator here] Identifier<b>;</b></pre>

<pre> ReturnStatement :
   <b>return</b> [no LineTerminator here] Expression<b>;</b></pre>

<pre> ThrowStatement :
   <b>throw</b> [no LineTerminator here] Expression<b>;</b></pre>

<p>这些受限产生式的实际效果如下：</p>

<p>当遇到的 ++ 或 --token 将要被解析器当作一个后缀运算符，并且至少有一个 LineTerminator 出现 ++ 或 --token 和它之前的 token 之间，那么在 ++ 或 --token 前面自动插入一个分号。</p>

<p>当遇到 <b>continue</b>, <b>break</b>, <b>return</b>, <b>throw</b> token，并且在下一个 token 前面遇到 <i>LineTerminator</i>，那么在 <b>continue</b>, <b>break</b>, <b>return</b>, <b>throw</b> token 后面自动插入一个分号。</p>

<p>这对 ECMAScript 程序员的实际影响是：</p>

<p>后缀运算符 ++ 或 -- 和它的操作数应该出现在同一行。</p>

<p>return 或 throw 语句的表达式开始位置应该和 return 或 throw token 同一行。</p>

<p>break 或 continue 语句的标示符应该和 break 或 continue token 同一行。</p>



<h5>自动分号插入的例子</h5>

<p>源代码：</p>

<pre> { 1 2 } 3</pre>

<p>即使在自动分号插入规则下，它也不符合 ECMAScript 文法。做为对比，源代码：</p>

<pre> { 1
 2 } 3</pre>

<p>它还是不符合 ECMAScript 文法，但是它会被自动分号插入成为一下形式：</p>

<pre> { 1  ;2 ;} 3;</pre>

<p>这符合 ECMAScript 文法。</p>

<p>源代码：</p>

<pre> for (a; b
 )</pre>

<p>不符合 ECMAScript 文法，并且不会被自动分号插入所更改，因为 <b>for</b> 语句头部需要分号。自动分号插入从来不会插入成 <b>for</b> 语句头部的两个分号之一。</p>

<p>源代码：</p>

<pre> return
 a + b</pre>

<p>会被自动分号插入转换成以下形式：</p>

<pre> return;
 a + b;</pre>

<p>注： 表达式 a + b 不会被当做是 return 语句要返回的值，因为有一个 <i>LineTerminator</i> 分割了它和 return token。</p>

<p>源代码：</p>

<pre> a = b
 ++c</pre>

<p>会被自动分号插入转换成以下形式：</p>

<pre> a = b;
 ++c;</pre>

<p>注：++token 不会被当做应用于变量 b 的后缀运算符，因为 b 和 ++ 之间出现了一个 <i>LineTerminator</i>。</p>

<p>源代码：</p>

<pre> if (a > b)
 else c = d</pre>

<p>它不符合 ECMAScript 文法 ，else token 前面不会被自动分号插入改变，即使没有文法产生式适用这一位置，因为自动插入分号后会解析成空语句。</p>

<p>源代码：</p>

<pre> a = b + c
 (d + e).print()</pre>

<p>它不会被自动分号插入改变，因为第二行开始位置的括号表达式可以解释成函数调用的参数列表：</p>

<pre> a = b + c(d + e).print()</pre>

<p>在赋值语句必须用左括号开头的情况下，程序员在前面语句的结束位置明确的提供一个分号是个好主意，而不是依赖于自动分号插入。</p>



<h4>类型</h4>

<p>本规范的算法操作各个有类型的值，可处理的类型在算法相关叙述中定义。类型又再分为 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/类型#language-type">ECMAScript 语言类型 </a>与 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/类型#specification-type">规范类型 </a>。</p>

<p><b>ECMAScript 语言类型 </b>是 ECMAScript 程序员使用 ECMAScript 语言直接操作的值对应的类型。ECMAScript 语言类型包括 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Undefined&action=edit&redlink=1">未定义 </a>（Undefined）、<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Null&action=edit&redlink=1"> 空值 </a>（Null）、<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Boolean&action=edit&redlink=1"> 布尔值</a>（Boolean）、<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=String&action=edit&redlink=1"> 字符串 </a>（String）、<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Number&action=edit&redlink=1"> 数值 </a>（Number）、<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Object&action=edit&redlink=1"> 对象 </a>（Object）。</p>

<p><b>规范类型 </b>是描述 ECMAScript 语言构造与 ECMAScript 语言类型语意的算法所用的元值对应的类型。规范类型包括 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Reference&action=edit&redlink=1">引用 </a>、<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=List&action=edit&redlink=1"> 列表 </a>、<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Completion&action=edit&redlink=1"> 完结 </a>、<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Property-descriptor&action=edit&redlink=1"> 属性描述式 </a>、<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Property-identifier&action=edit&redlink=1"> 属性标示 </a>、<a href="http://www.w3.org/html/ig/zh/wiki/ES5/类型#lexical-environment"> 词法环境（Lexical Environment）</a>、<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Environment-record&action=edit&redlink=1"> 环境纪录（Environment Record）</a>。规范类型的值是不一定对应 ECMAScript 实现里任何实体的虚拟对象。规范类型可用来描述 ECMAScript 表式运算的中途结果，但是这些值不能存成对象的变量或是 ECMAScript 语言变量的值。</p>

<p>在本规范中，我们将「<var>x</var> 的类型」简写为 <b><code>Type(<var>x</var>)</code></b> ，而类型指的就是上述的 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/类型#language-type">ECMAScript 语言类型 </a>与 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/类型#specification-type">规范类型 </a>。</p>



<h4>Undefined 类型</h4>

<p>Undefined 类型有且只有一个值，称为 <var>undefined</var> 。任何没有被赋值的变量都有 <var>undefined</var> 值。</p>



<h4>Null 类型</h4>

<p>Null 类型有且只有一个值，称为 <var>null</var> 。</p>



<h4>Boolean 类型</h4>

<p>Boolean 类型表示逻辑实体，有两个值，称为 <var>true</var> 和 <var>false</var>。</p>



<h4>String 类型</h4>

<p>字符串类型是所有有限的零个或多个 16 位无符号整数值（“元素”）的有序序列。在运行的 ECMAScript 程序中，字符串类型常被用于表示文本数据，此时字符串中的每个元素都被视为一个代码点（参看 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/类型#x6">章节 6</a>）。 每个元素都被认为占有此序列中的一个位置。用非负数值索引这些位置。任何时候，第一个元素（若存在）在位置 0，下一个元素（若存在）在位置 1，依此类推。字符串的长度即其中元素的个数（比如，16 位值）。空字符串长度为零，因而不包含任何元素。</p>

<p>若一个字符串包含实际的文本数据，每个元素都被认为是一个单独的 UTF-16 单元。无论这是不是 String 实际的存储格式，String 中的字符都被当作表示为 UTF-16 来计数。除非特别声明，作用在字符串上的所有操作都视它们为无差别的 16 位无符号整数；这些操作不保证结果字符串仍为常规化的形式，也不保证语言敏感结果。</p>

<p>注： 这些决议背后的原理是尽可能地保持字符串的实现简单而高效。这意味着，在运行中的程序读到从外部进入执行环境的文本数据（即，用户输入，从文件读取文本 ，或从网络上接收文本，等等）之前，它们已被转为 Unicode 常规化形式 C。通常情况下，这个转化在进入的文本被从其原始字符编码转为 Unicode 的同时进行（且强制去除头部附加信息）。因此，建议 ECMAScript 程序源代码为常规化形式 C，（如果保证源代码文本是常规化的）保证字符串常量是常规化的，即便它们不包含任何 Unicode 转义序列。</p>



<h4>Number 类型</h4>

<p>精确地，数值类型拥有 18437736874454810627（即，2<sup>64</sup>-2<sup>53</sup> +3）个值，表示为 IEEE-754 格式 64 位双精度数值（IEEE 二进制浮点数算术中描述了它），除了 IEEE 标准中的 9007199254740990（即，2<sup>53</sup>-2）个明显的“非数字 ”值；在 ECMAScript 中，它们被表示为一个单独的特殊值：<var>NaN</var>。（请注意，NaN 值由程序表达式 NaN 产生，并假设执行程序不能调整定义的全局变量 <var>NaN</var>。） 在某些实现中，外部代码也许有能力探测出众多非数字值之间的不同，但此类行为依赖于具体实现；对于 ECMAScript 代码而言，<var>NaN</var> 值相互之间无法区别。</p>

<p>还有另外两个特殊值，称为正无穷和负无穷。为简洁起见，在说明目的时，用符号 +∞ 和 -∞ 分别代表它们。（请注意，两个无限数值由程序表达式 <var>+Infinity</var>（简作<var>Infinity</var>） 和 <var>-Infinity</var> 产生，并假设执行程序不能调整定义的全局变量 <var>Infinity</var>。）</p>

<p>另外 18437736874454810624（即，2<sup>64</sup>-2<sup>53</sup>） 个值被称为有限数值。其中的一半是正数，另一半是负数，对于每个正数而言，都有一个与之对应的、相同规模的负数。</p>

<p>请注意，还有一个 <var>正零 </var>和一个 <var>负零 </var>。为简洁起见，类似地，在说明目的时，分别用用符号 <var>+0</var> 和 <var>-0</var> 代表这些值。（请注意，这两个数字零由程序表达式 <var>+0</var>（简作 <var>0</var>） 和<var>-0</var> 产生。）</p>

<p>这 18437736874454810622（即，2<sup>64</sup>-2<sup>53</sup>-2） 个有限非零值分为两种：</p>

<p>其中 18428729675200069632（即，2<sup>64</sup>-2<sup>54</sup>） 个是常规值，形如</p>

<pre>   s * m * 2e</pre>

<p>这里的 s 是 +1 或 -1，m 是一个小于 2<sup>53</sup> 但不小于 2<sup>52</sup> 的正整数，e 是一个闭区间 -1074 到 971 中的整数。</p>

<p>剩下的 9007199254740990（即，2<sup>53</sup>-2）个值是非常规的，形如</p>

<pre>   s * m * 2e</pre>

<p>这里的 s 是 +1 或 -1，m 是一个小于 2<sup>52</sup> 的 正整数，<i>e</i> 为 -1074</p>

<p>请注意，所有规模不超过 2<sup>53</sup> 的正整数和负整数都可被数值类型表示（不过，整数 0 有两个呈现形式，+0 和 0）。</p>

<p>如果一个有限的数值非零且用来表达它（上文两种形式之一）的整数 m 是奇数，则该数值有 奇数标记 (odd significand)。否则，它有 偶数标记 (even significand)。</p>

<p>在本规范中，当 x 表示一个精确的非零实数数学量（甚至可以是无理数，比如 π）时，短语 "the number value for x" 意为，以下面的方式选择一个数字 值。考虑数值类型的所有有限值的集合（不包括 -0 和两个被加入在数值类型中但不可呈现的值，即 21024（即 +1 * 2<sup>53</sup> * 2<sup>971</sup>）和 -2<sup>1024</sup> （那是 -1 * 2<sup>53</sup> * 2<sup>971</sup>）。选择此集合 中值最接近 x 的一员，若集合中的两值近似相等，那么选择有偶数标记的那个；为此，2<sup>1024</sup> 和 -2<sup>1024</sup> 这两个超额值被认为有偶数标记。最终，若选择 2<sup>1024</sup> ，用 +∞替换它；若选择 -2<sup>1024</sup> ，用 -∞替换它；若选择 +0，有且只有 x 小于零时，用 -0 替换它；其它任何被选取的值都不用改变。结果就是 x 的数字值。（此过程正是 IEEE-754"round to nearest" 模式对应的行为。）</p>

<p>某些 ECMAScript 运算符仅涉及闭区间 -2<sup>31</sup> 到 2<sup>31</sup>-1 的整数，或闭区间 0 到 2<sup>32</sup>-1。这些运算符接受任何数值类型的值，不过，数值首先被转换为 2<sup>32</sup> 个整数值中的一个。参见<a href="http://www.w3.org/html/ig/zh/wiki/ES5/类型#x9.5">ToInt32</a> 和 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/类型#x9.6">ToUint32</a> 的 描述，分别在 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/类型#x9.5">章节 9.5</a> 和 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/类型#x9.6">9.6</a> 中。</p>



<h4>Object 类型</h4>

<p>Object 是一个属性的集合。每个属性既可以是一个命名的数据属性，也可以是一个命名的访问器属性，或是一个内部属性：</p>

<ul>
  <li>命名的数据属性（<i>named data property</i>）由一个名字与一个 ECMAScript 语言值和一个 Boolean 属性集合组成</li>

  <li>命名的访问器属性（<i>named accessor property</i>）由一个名字与一个或两个访问器函数，和一个 Boolean 属性集合组成。访问器函数用于存取一个与该属性相关联的 ECMAScript 语言值</li>

  <li>内部属性（<i>internal property</i>）没有名字，且不能直接通过 ECMAScript 语言操作。内部属性的存在纯粹为了规范的目的。</li>
</ul>

<p>有两种带名字的访问器属性（非内部属性）：<i>get</i> 和 <i>put</i>，分别对应取值和赋值。</p>



<h5>Property 特性</h5>

<p>本规范中的特性（Attributes）用于定义和解释命名属性（properties）的状态。命名的数据属性由一个名字关联到一个下表中列出的特性 (attributes)</p>
<div>
<p>表 5：命名的数据属性的特性</p>

<p><i>特性名称</i>

  <br /><i>取值范围</i>

  <br /><i>描述</i></p>

<p>[[Value]]
  <br />任何 ECMAScript 语言类型

  <br />通过读 property 来取到该值</p>

<p>[[Writable]]
  <br />Boolean

  <br />如果为 false，试图通过 ECMAScript 代码 [[Put]] 去改变该属性的 [[Value]]，将会失败</p>

<p>[[Enumerable]]
  <br />Boolean

  <br />如果为 true，则该属性可被 for-in 枚举出来（参见 12.6.4），否则，该属性不可枚举。</p>

<p>[[Configurable]]
  <br />Boolean

  <br />如果为 false，试图删除该属性，改变该属性为访问器属性，或改变它的 attributes（和 [[Value]] 不同），都会失败。</p>
</div>
<p>命名的访问器属性由一个名字关联到一个下表中列出的特性 (attributes)</p>

<div>
<p>表 6：命名的访问器属性的特性</p>

<p><i>特性名称</i>

  <br /><i>取值范围</i>

  <br /><i>描述</i></p>

<p>[[Get]]
  <br />Object 或 Undefined

  <br />如果该值为一个 Object 对象，那么它必须是一个函数对象。每次有对该属性进行 get 访问时，该函数的内部方法 [[Call]]（8.6.2）会被一个空参数列表调用，以返回该属性值</p>

<p>[[Set]]
  <br />Object 或 Undefined

  <br />如果该值为一个 Object 对象，那么它必须是一个函数对象。每次有对该属性进行 set 访问时，该函数的内部方法 [[Call]]（8.6.2）会被一个参数列表调用，这个参数列表包含分配的值作为唯一的参数。property 的内部方法 [[Set]] 产生的影响可能会，但不是必须的，对随后的 property 内部方法 [[Get]] 的调用返回结果产生影响。</p>

<p>[[Enumerable]]
  <br />Boolean

  <br />如果为 true，则该属性可被 for-in 枚举出来（参见 12.6.4），否则，该属性不可枚举。</p>

<p>[[Configurable]]
  <br />Boolean

  <br />如果为 false，试图删除该属性，改变该属性为访问器属性，或改变它的 attributes（和 [[Value]] 不同），都会失败。</p>
</div>
<p>如果某个命名属性的特征值没有在此规范中明确给出，那么它的默认值将使用下表的定义。</p>
<div>
<p>表 7：默认特征值</p>

<p><i>特性名称</i>

  <br /><i>默认值</i></p>

<p>[[Value]]
  <br />undefined</p>

<p>[[Get]]
  <br />undefined</p>

<p>[[Set]]
  <br />undefined</p>

<p>[[Writable]]
  <br />false</p>

<p>[[Enumerable]]
  <br />false</p>

<p>[[Configurable]]
  <br />false</p>
</div>


<h5>Object 内部属性及方法</h5>

<p>本规范使用各种内部属性来定义对象值的语义。这些内部属性不是 ECMAScript 语言的一部分。本规范中纯粹是以说明为目的定义它们。ECMAScript 实现必须表现为仿佛它被这里描述的内部属性产生和操作。内部属性的名字用闭合双方括号 括起来。如果一个算法使用一个对象的一个内部属性，并且此对象没有实现需要的内部属性，那么抛出<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=TypeError&action=edit&redlink=1">TypeError</a> 异常。</p>

<p>表 8 总结了本规范中适用于所有 ECMAScript 对象的内部属性。表 9 总结了本规范中适用于某些 ECMAScript 对象的内部属性。这些表中的描述如果没有特别指出是特定的原生 ECMAScript 对象，那么就说明了其在原生 ECMAScript 对象中的行为。宿主对象的内部属性可以支持任何依赖于实现的行为，只要其与本文档说的宿主对象的个别限制一直。</p>

<p>下面表的“值的类域”一列定义了内部属性关联值的类型。类型名称参考第 8 章定义的类型，作为增强添加了一下名称：“any”指值可以是任何 ECMAScript<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=%E8%AF%AD%E8%A8%80%E7%B1%BB%E5%9E%8B&action=edit&redlink=1"> 语言类型</a>；“primitive”指 Undefined, Null, Boolean, String, , Number；“SpecOp”指内部属性是一个内部方法，一个抽象操作规范定义一个实现提供它的步骤。“SpecOp”后面跟着描述性参数名的列表。如果参数名和类型名一致那么这个名字用于描述参数的类型。如果“SpecOp”有返回值，那么这个参数列表后跟着“→”符号和返回值的类型。</p>
<div>
<p>表 8 - 所有对象共有的内部属性</p>

<p><i>内部属性</i>

  <br /><i>值的类型范围</i>

  <br /><i>说明</i></p>

<p>[[Prototype]]
  <br />Object 或 Null

  <br />此对象的原型</p>

<p>[[Class]]
  <br />String

  <br />说明规范定义的对象分类的一个字符串值</p>

<p>[[Extensible]]
  <br />Boolean

  <br />如果是 true，可以向对象添加自身属性。</p>

<p>[[Get]]
  <br />SpecOp(propertyName) → any

  <br />返回命名属性的值</p>

<p>[[GetOwnProperty]]
  <br />SpecOp (propertyName) → Undefined 或 Property Descriptor

  <br />返回此对象的自身命名属性的属性描述，如果不存在返回 undefined</p>

<p>[[GetProperty]]
  <br />SpecOp (propertyName) → Undefined 或 Property Descriptor

  <br />返回此对象的完全填入的自身命名属性的属性描述，如果不存在返回 undefined</p>

<p>[[Put]]
  <br />SpecOp (propertyName, any, Boolean)

  <br />将指定命名属性设为第二个参数的值。flog 控制失败处理。</p>

<p>[[CanPut]]
  <br />SpecOp (propertyName) → Boolean

  <br />返回一个 Boolean 值，说明是否可以在 PropertyName 上执行 [[Put]] 操作。</p>

<p>[[HasProperty]]
  <br />SpecOp (propertyName) → Boolean

  <br />返回一个 Boolean 值，说明对象是否含有给定名称的属性。</p>

<p>[[Delete]]
  <br />SpecOp (propertyName, Boolean) → Boolean

  <br />从对象上删除指定的自身命名属性。flog 控制失败处理。</p>

<p>[[DefaultValue]]
  <br />SpecOp (Hint) → primitive

  <br />Hint 是一个字符串。返回对象的默认值</p>

<p>[[DefineOwnProperty]]
  <br />SpecOp (propertyName, PropertyDescriptor, Boolean) → Boolean

  <br />创建或修改自身命名属性为拥有属性描述里描述的状态。flog 控制失败处理。</p>
</div>

<p>所有对象（包括宿主对象）必须实现表 8 中列出的所有内部属性。然而，对某些对象的 [[DefaultValue]] 内部方法，可以简单的抛出 TypeError 异常。</p>

<p>所有对象都有一个叫做 [[Prototype]] 的内部属性。此对象的值是 null 或一个对象，并且它用于实现继承。一个原生属性是否可以把宿主对象作为它的 [[Prototype]] 取决于实现。所有 [[Prototype]] 链必须是有限长度（即，从任何对象开始，递归访问 [[Prototype]] 内部属性必须最终到头，并且值是 null）。从 [[Prototype]] 对象继承来的命名数据属性（作为子对象的属性可见）是为了 get 请求，但无法用于 put 请求。命名访问器属性会把 get 和 put 请求都继承。</p>

<p>所有 ECMASCript 对象都有一个 Boolean 值的 [[Extensible]] 内部属性，它控制是否可以给对象添加命名属性。如果 [[Extensible]] 内部属性的值是 false 那么不得给对象添加命名属性。此外，如果 [[Extensible]] 是 false 那么不得更改对象的 [[Class]] 和 [[Prototype]] 内部属性的值。一旦 [[Extensible]] 内部属性的值设为 false 之后无法再更改为 true。</p>

<p>注： 本规范的定义中没有 ECMAScript 语言运算符或内置函数允许一个程序更改对象的 [[Class]] 或 [[Prototype]] 内部属性或把 [[Extensible]] 的值从 false 更改成 true。实现中修改 [[Class]], [[Prototype]], [[Extensible]] 的个别扩展必须不违反前一段定义的不变量。</p>

<p>本规范的每种内置对象都定义了 [[Class]] 内部属性的值。宿主对象的 [[Class]] 内部属性的值可以是除了 "Arguments", "Array", "Boolean", "Date", "Error", "Function", "JSON", "Math", "Number", "Object", "RegExp", "String" 的任何字符串。[[Class]] 内部属性的值用于内部区分对象的种类。注，本规范中除了通过 Object.prototype.toString ( 见 15.2.4.2) 没有提供任何手段使程序访问此值。</p>

<p>除非特别指出，原生 ECMAScrpit 对象的公共内部方法的行为描述在 8.12。Array 对象的 [[DefineOwnProperty]] 内部方法有稍不同的实现（见 15.4.5.1），又有 String 对象的 [[GetOwnProperty]] 内部方法有稍不同的实现（见 15.5.5.2）。Arguments 对象（10.6）的 [[Get]]，[[GetOwnProperty]]，[[DefineOwnProperty]]，[[Delete]] 有不同的实现。Function 对象（15.3）的 [[Get]] 的有不同的实现。</p>

<p>除非特别指出，宿主对象可以以任何方式实现这些内部方法，一种可能是一个特别的宿主对象的 [[Get]] 和 [[Put]] 确实可以存取属性值，但 [[HasProperty]] 总是产生 false。然而，如果任何对宿主对象内部属性的操作不被实现支持，那么当试图操作时必须抛出 TypeError 异常。</p>

<p>宿主对象的 [[GetOwnProperty]] 内部方法必须符合宿主对象每个属性的以下不变量 ：</p>

<ul>
  <li>如果属性是描述过的数据属性，并随着时间的推移，它可能返回不同的值，那么即使没有暴露提供更改值机制的其他内部方法，[[Writable]] 和 [[Configurable]] 之一或全部必须是 true。 </li>

  <li>如果属性是描述过的数据属性，并且其 [[Writable]] 和 [[Configurable]] 都是 false。那么所有对 [[GetOwnProperty]] 的呼出，必须返回作为属性 [[Value]] 特性的<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=SameValue&action=edit&redlink=1">SameValue</a>(9.12)。 </li>

  <li>如果 [[Writable]] 特性可以从 false 更改为 true，那么 [[Configurable]] 特性必须是 true。 </li>

  <li>当 ECMAScript 代码监测到宿主对象的 [[Extensible]] 内部属性值是 false。那么如果调用 [[GetOwnProperty]] 描述一个属性是不存在，那么接下来所有调用这个属性必须也描述为不存在。</li>
</ul>

<p>如果 ECMAScript 代码监测到宿主对象的 [[Extensible]] 内部属性是 false，那么这个宿主对象的 [[DefineOwnProperty]] 内部方法不允许向宿主对象添加新属性。</p>

<p>如果 ECMAScript 代码监测到宿主对象的 [[Extensible]] 内部属性是 false，那么它以后必须不能再改为 true。</p>
<div>
<p>表 9 - 只在某些对象中定义的内部属性</p>

<p><i>内部属性</i>

  <br /><i>值的类型范围</i>

  <br /><i>说明</i></p>

<p>[[PrimitiveValue]]
  <br />primitive

  <br />与此对象的内部状态信息关联。对于标准内置对象只能用 Boolean, Date, Number, String 对象实现 [[PrimitiveValue]]。</p>

<p>[[Construct]]
  <br />SpecOp(a List of any) → Object

  <br />通过 new 运算符调，创建对象。SpecOp 的参数是通过 new 运算符传的参数。实现了这个内部方法的对象叫做 <i>构造器 </i>。</p>

<p>[[Call]]
  <br />SpecOp(any, a List of any) → any or Reference

  <br />运行与此对象关联的代码。通过函数调用表达式调用。SpecOp 的参数是一个 this 对象和函数调用表达式传来的参数组成的列表。实现了这个内部方法的对象是 <i>可调用 </i>的。只有作为宿主对象的可调用对象才可能返回 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=%E5%BC%95%E7%94%A8&action=edit&redlink=1">引用 </a>值。</p>

<p>[[HasInstance]]
  <br />SpecOp(any) → Boolean

  <br />返回一个表示参数对象是否可能是由本对象构建的布尔值。在标准内置 ECMAScript 对象中只有 Function 对象实现 [[HasInstance]]。</p>

<p>[[Scope]]
  <br />Lexical Environment

  <br />一个定义了函数对象执行的环境的词法环境。在标准内置 ECMAScript 对象中只有 Function 对象实现 [[Scope]]。</p>

<p>[[FormalParameters]]
  <br />List of Strings

  <br />一个包含 Function 的 <i>FormalParameterList</i> 的标识符字符串的可能是空的列表。在标准内置 ECMAScript 对象中只有 Function 对象实现 [[FormalParameterList]]。</p>

<p>[[Code]]
  <br />ECMAScript code

  <br />函数的 ECMAScript 代码。在标准内置 ECMAScript 对象中只有 Function 对象实现 [[Code]]。</p>

<p>[[TargetFunction]]
  <br />Object

  <br />使用标准内置的 Function.prototype.bind 方法创建的函数对象的目标函数。只有使用 Function.prototype.bind 创建的 ECMAScript 对象才有 [[TargetFunction]] 内部属性。</p>

<p>[[BoundThis]]
  <br />any

  <br />使用标准内置的 Function.prototype.bind 方法创建的函数对象的预绑定的 this 值。只有使用 Function.prototype.bind 创建的 ECMAScript 对象才有 [[BoundThis]] 内部属性。</p>

<p>[[BoundArguments]]
  <br />List of any

  <br />使用标准内置的 Function.prototype.bind 方法创建的函数对象的预绑定的参数值。只有使用 Function.prototype.bind 创建的 ECMAScript 对象才有 [[BoundArguments]] 内部属性。</p>

<p>[[Match]]
  <br />SpecOp(String, index) → MatchResult

  <br />测试正则匹配并返回一个 MatchResult 值（见 15.10.2.1）。在标准内置 ECMAScript 对象中只有 RegExp 对象实现 [[Match]]。</p>

<p>[[ParameterMap]]
  <br />Object

  <br />提供参数对象的属性和函数关联的形式参数之间的映射。只有参数对象才有 [[ParameterMap]] 内部属性。</p>
</div>


<h4>引用规范类型</h4>

<p>引用类型用来说明 delete，typeof，赋值运算符这些运算符的行为。例如，在赋值运算中左边的操作数期望产生一个引用。通过赋值运算符左侧运算子的语法案例分析可以但不能完全解释赋值行为，还有个难点：函数调用允许返回引用。承认这种可能性纯粹是为了宿主对象。本规范没有定义返回引用的内置 ECMAScript 函数，并且也不提供返回引用的用户定义函数。（另一个不使用语法案列分析的原因是，那样将会影响规范的很多地方，冗长并且别扭。）</p>

<p>一个 <b>引用 (Reference)</b> 是个已解决的命名绑定。一个引用由三部分组成，<i> 基 (base)</i> 值，<i> 引用名称（referenced name）</i> 和布尔值 <i>严格引用 (strict reference)</i> 标志。基值是 undefined, 一个 Object, 一个 Boolean, 一个 String, 一个 Number, 一个 environment record 中的任意一个。基值是 undefined 表示此引用可以不解决一个绑定。引用名称是一个字符串。</p>

<p>本规范中使用以下抽象操作接近引用的组件：</p>

<ul>
  <li>GetBase(V)。 返回引用值 V 的基值组件。 </li>

  <li>GetReferencedName(V)。 返回引用值 V 的引用名称组件。 </li>

  <li>IsStrictReference(V)。 返回引用值 V 的严格引用组件。 </li>

  <li>HasPrimitiveBase(V)。 如果基值是 Boolean, String, Number，那么返回 true。 </li>

  <li>IsPropertyReference(V)。 如果基值是个对象或 HasPrimitiveBase(V) 是 true，那么返回 true；否则返回 false。 </li>

  <li>IsUnresolvableReference(V)。 如果基值是 undefined 那么返回 true，否则返回 false。</li>
</ul>

<p>本规范使用以下抽象操作来操作引用：</p>



<h5>GetValue(v)</h5>

<ol>
  <li>如果 Type(V) 不是引用 , 返回 V。 </li>

  <li>令 base 为调用 GetBase(V) 的返回值。 </li>

  <li>如果 IsUnresolvableReference(V), 抛出一个 ReferenceError 异常。 </li>

  <li>如果 IsPropertyReference(V), 那么 
    <ol>
      <li>如果 HasPrimitiveBase(V) 是 false, 那么令 get 为 base 的 [[Get]] 内部方法 , 否则令 get 为下面定义的特殊的 [[Get]] 内部方法。 </li>

      <li>将 base 作为 this 值，传递 GetReferencedName(V) 为参数，调用 get 内部方法，返回结果。</li>
    </ol>
  </li>

  <li>否则 , base 必须是一个 environment record。 </li>

  <li>传递 GetReferencedName(V) 和 IsStrictReference(V) 为参数调用 base 的 GetBindingValue( 见 10.2.1) 具体方法，返回结果。</li>
</ol>

<p>GetValue 中的 V 是原始基值的 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=%E5%B1%9E%E6%80%A7%E5%BC%95%E7%94%A8&action=edit&redlink=1">属性引用 </a>时使用下面的 [[Get]] 内部方法。它用 base 作为他的 this 值，其中属性 P 是它的参数。采用以下步骤：</p>

<ol>
  <li>令 O 为 ToObject(base)。 </li>

  <li>令 desc 为用属性名 P 调用 O 的 [[GetProperty]] 内部方法的返回值。 </li>

  <li>如果 desc 是 undefined，返回 undefined。 </li>

  <li>如果 IsDataDescriptor(desc) 是 true，返回 desc.[[Value]]。 </li>

  <li>否则 IsAccessorDescriptor(desc) 必须是 true，令 getter 为 desc.[[Get]]。 </li>

  <li>如果 getter 是 undefined，返回 undefined。 </li>

  <li>提供 base 作为 this 值，无参数形式调用 getter 的 [[Call]] 内部方法，返回结果。</li>
</ol>

<p>注： 上述方法之外无法访问在第一步创建的对象。实现可以选择不真的创建这个对象。使用这个内部方法给实际属性访问产生可见影响的情况只有在调用访问器函数时。</p>



<h5>PutValue(v,w)</h5>

<ol>
  <li>如果 Type(V) 不是引用，抛出一个 ReferenceError 异常。 </li>

  <li>令 base 为调用 GetBase(V) 的结果。 </li>

  <li>如果 IsUnresolvableReference(V)，那么 
    <ol>
      <li>如果 IsStrictReference(V) 是 true，那么 
        <ol>
          <li>抛出 ReferenceError 异常。</li>
        </ol>
      </li>

      <li>用 GetReferencedName(V)，W，false 作为参数调用全局对象的 [[Put]] 内部方法。</li>
    </ol>
  </li>

  <li>否则如果 IsPropertyReference(V)，那么 
    <ol>
      <li>如果 HasPrimitiveBase(V) 是 false，那么令 put 为 base 的 [[Put]] 内部方法，否则令 put 为下面定义的特殊的 [[Put]] 内部方法。 </li>

      <li>用 base 作为 this 值，用 GetReferencedName(V)，W，IsStrictReference(V) 作为参数调用 put 内部方法。</li>
    </ol>
  </li>

  <li>否则 base 必定是 environment record 作为 base 的引用。所以， 
    <ol>
      <li>用 GetReferencedName(V), W, IsStrictReference(V) 作为参数调用 base 的 SetMutableBinding (10.2.1) 具体方法。</li>
    </ol>
  </li>

  <li>返回。</li>
</ol>

<p>PutValue 中的 V 是原始基值的属性引用时使用下面的 [[Put]] 内部方法。用 base 作为 this 值，用属性 P，值 W，布尔标志 Throw 作为参数调用它。采用以下步骤：</p>

<ol>
  <li>令 O 为 ToObject(base)。 </li>

  <li>如果用 P 作为参数调用 O 的 [[CanPut]] 内部方法的结果是 false，那么 
    <ol>
      <li>如果 Throw 是 true，那么抛出一个 TypeError 异常。 </li>

      <li>否则返回。</li>
    </ol>
  </li>

  <li>令 ownDesc 为用 P 作为参数调用 O 的 [[GetOwnProperty]] 内部方法的结果。 </li>

  <li>如果 IsDataDescriptor(ownDesc) 是 true，那么 
    <ol>
      <li>如果 Throw 是 true，那么抛出一个 TypeError 异常。 </li>

      <li>否则返回。</li>
    </ol>
  </li>

  <li>令 desc 为用 P 作为参数调用 O 的 [[GetProperty]] 内部方法的结果。这可能是一个自身或继承的访问器属性描述或是一个继承的数据属性描述。 </li>

  <li>如果 IsAccessorDescriptor(desc) 是 true，那么 
    <ol>
      <li>令 setter 为 desc.Set，他不能是 undefined。 </li>

      <li>用 base 作为 this 值，用只由 W 组成的列表作为参数调用 setter 的 [[Call]] 内部方法。</li>
    </ol>
  </li>

  <li>否则，这是要在临时对象 O 上创建自身属性的请求。 
    <ol>
      <li>如果 Throw 是 true，抛出一个 TypeErroe 异常。</li>
    </ol>
  </li>

  <li>返回。</li>
</ol>

<p>注： 上述方法之外无法访问在第一步创建的对象。实现可以选择不真的创建这个临时对象。使用这个内部方法给实际属性访问产生可见影响的情况只有在调用访问器函数时，或 Throw 未通过提前错误检查。当 Throw 是 true，试图在这个临时对象上创建新属性的任何属性分配操作会抛出一个错误。</p>



<h4>列表规范类型</h4>

<p>列表类型用于说明 new 表达式，函数调用，其他需要值的简单列表的算法 -- 里的参数列表的计算。列表类型的值是简单排序的一些值的序列。此序列可以是任意长度。</p>



<h4>完结规范类型</h4>

<p>完结类型用于说明执行将控制转移到外部的声明 (break, continue, return, throw) 的行为。完结类型的值是由三部分组成，形如（type，value，target），其中 type 是 normal, break, continue, return, throw 之一，value 是任何 ECMASCript 语言值或 empty，target 是任何 ECMAScript 标识符或 empty。</p>

<p>术语“突然完结（abrupt completion）”是指任何非正常完成的完成类型。</p>



<h4>属性描述符及属性标识符规范类型</h4>

<p>属性描述符类型是用来解释命名属性的具体的操作的特性集。属性描述符类型的值是记录项，由命名字段组成，每个字段的名称是一个特性名并且它的值是一个相应的特性值，这些特性指定在 8.6.1。此外，任何字段都可能存在或不存在。</p>

<p>根据是否存在或使用了某些字段，属性描述符的值可进一步划分为数据属性描述符和访问器属性描述符。一个数据属性描述符 里包括叫做 [[Value]] 或 [[Writable]] 的字段。一个访问器属性描述符里包括叫做 [[Get]] 或 [[Set]] 的字段。任何属性描述都可能有名为 [[Enumerable]] 和 [[Configurable]] 的字段。一个属性描述符不能同时是数据属性描述符和访问器属性描述符；但是，它可能二者都不是。一个通用属性描述符是，既不是数据属性描述符也不是访问器属性描述符的属性描述符值。一个完全填充属性描述符是访问器属性描述符或数据属性描述符，并且拥有 8.6.1 Table 5 或 Table 6 里定义的所有属性特性对应的字段。</p>

<p>本规范中为了便于标记，使用一种类似对象字面量的语法来定义属性描述符。例如，属性描述符 {[[Value]]: 42, [[Writable]]: false, [[Configurable]]: true}，就定义了一个数据属性描述符。字段名称的顺序并不重要。任何没有明确列出的字段被认为是不存在的。</p>

<p>在规范中的文本和算法里，可用点符号来指明一个属性描述符的特定字段。例如，如果 D 是一个属性描述符，那么 D.[[Value]] 是“D 的 [[Value]] 字段”的简写。</p>

<p>属性标识符类型用于关联属性名称与属性描述符。属性标识符类型的值是 (name, descriptor) 形式的一对值，其中 name 是一个字符串和 descriptor 是一个属性描述符值。</p>

<p>在本规范中使用以下的抽象操作来操作属性描述符值：</p>



<h5>IsAccessorDescriptor (Desc)</h5>

<p>当用属性描述 Desc 调用抽象操作 IsAccessorDescriptor，采用以下步骤：</p>

<ol>
  <li>如果 Desc 是 undefined，那么返回 false。 </li>

  <li>如果 Desc.[[Get]] 和 Desc.[[Set]] 都不存在，则返回 false。 </li>

  <li>返回 true。</li>
</ol>


<h5>IsDataDescriptor (Desc)</h5>

<p>当用属性描述 Desc 调用抽象操作 IsDataDescriptor，采用以下步骤：</p>

<ol>
  <li>如果 Desc 是 undefined，那么返回 false。 </li>

  <li>如果 Desc.[[Value]] 和 Desc.[[Writable]] 都不存在，则返回 false。 </li>

  <li>返回 true。</li>
</ol>


<h5>IsGenericDescriptor (Desc)</h5>

<p>当用属性描述 Desc 调用抽象操作 IsDataDescriptor，采用以下步骤：</p>

<ol>
  <li>如果 Desc 是 undefined，那么返回 false。 </li>

  <li>如果 IsAccessorDescriptor(Desc) 和 IsDataDescriptor(Desc) 都是 false, 则返回 true。 </li>

  <li>返回 false。</li>
</ol>


<h5>FromPropertyDescriptor (Desc)</h5>

<p>当用属性描述 Desc 调用抽象操作 FromPropertyDescriptor，采用以下步骤：</p>

<p>假定以下算法的 Desc 是 [[GetOwnProperty]]( 见 8.12.1) 返回的完全填充的 属性描述。</p>

<ol>
  <li>如果 Desc 是 undefined，那么返回 false。 </li>

  <li>令 obj 为仿佛使用 new Object() 表达式创建的新对象，这里的 Object 是标准内置构造器名。 </li>

  <li>如果 IsDataDescriptor(Desc) 是 true，则 
    <ol>
      <li>用参数 "value", 属性描述符 {[[Value]]: Desc.[[Value]], [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, false 调用 obj 的 [[DefineOwnProperty]] 内部方法。 </li>

      <li>用参数 "writable", 属性描述符 {[[Value]]: Desc.[[Writable]], [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, false 调用 obj 的 [[DefineOwnProperty]] 内部方法。</li>
    </ol>
  </li>

  <li>否则，IsAccessorDescriptor(Desc) 必定是 true，所以 
    <ol>
      <li>用参数 "get", 属性描述符 {[[Value]]: Desc.[[Get]], [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, false 调用 obj 的 [[DefineOwnProperty]] 内部方法。 </li>

      <li>用参数 "set", 属性描述符 {[[Value]]: Desc.[[Set]], [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, false 调用 obj 的 [[DefineOwnProperty]] 内部方法。</li>
    </ol>
  </li>

  <li>用参数 "enumerable", 属性描述符 {[[Value]]: Desc.[[Enumerable]], [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, false 调用 obj 的 [[DefineOwnProperty]] 内部方法。 </li>

  <li>用参数 "configurable", 属性描述符 {[[Value]]: Desc.[[Configurable]], [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, false 调用 obj 的 [[DefineOwnProperty]] 内部方法。 </li>

  <li>返回 obj。</li>
</ol>


<h5>ToPropertyDescriptor (Obj)</h5>

<p>当用对象 Desc 调用抽象操作 FromPropertyDescriptor，采用以下步骤：</p>

<ol>
  <li>如果 Type(Obj) 不是 Object，抛出一个 TypeError 异常。 </li>

  <li>令 desc 为创建初始不包含字段的新属性描述的结果。 </li>

  <li>如果用参数 "enumerable" 调用 Obj 的 [[HasProperty]] 内部方法的结果是 true，则 
    <ol>
      <li>令 enum 为用参数 "enumerable" 调用 Obj 的 [[Get]] 内部方法的结果。 </li>

      <li>设定 desc 的 [[Enumerable]] 字段为 ToBoolean(enum)。</li>
    </ol>
  </li>

  <li>如果参数 "configurable" 调用 Obj 的 [[HasProperty]] 内部方法的结果是 true，则 
    <ol>
      <li>令 conf 为用参数 "enumerable" 调用 Obj 的 [[Get]] 内部方法的结果。 </li>

      <li>设定 desc 的 [[Configurable]] 字段为 ToBoolean(conf)。</li>
    </ol>
  </li>

  <li>如果参数 "value" 调用 Obj 的 [[HasProperty]] 内部方法的结果是 true，则 
    <ol>
      <li>令 value 为用参数 "value" 调用 Obj 的 [[Get]] 内部方法的结果。 </li>

      <li>设定 desc 的 [[Value]] 字段为 value。</li>
    </ol>
  </li>

  <li>如果参数 "writable" 调用 Obj 的 [[HasProperty]] 内部方法的结果是 true，则 
    <ol>
      <li>令 writable 为用参数 "writable" 调用 Obj 的 [[Get]] 内部方法的结果。 </li>

      <li>设定 desc 的 [[Writable]] 字段为 ToBoolean(writable)。</li>
    </ol>
  </li>

  <li>如果参数 "get" 调用 Obj 的 [[HasProperty]] 内部方法的结果是 true，则 
    <ol>
      <li>令 getter 为用参数 "get" 调用 Obj 的 [[Get]] 内部方法的结果。 </li>

      <li>如果 IsCallable(getter) 是 false 并且 getter 不是 undefined，则抛出一个 TypeError 异常。 </li>

      <li>设定 desc 的 [[Get]] 字段为 getter。</li>
    </ol>
  </li>

  <li>如果参数 "set" 调用 Obj 的 [[HasProperty]] 内部方法的结果是 true，则 
    <ol>
      <li>令 setter 为用参数 "set" 调用 Obj 的 [[Get]] 内部方法的结果。 </li>

      <li>如果 IsCallable(setter) 是 false 并且 setter 不是 undefined，则抛出一个 TypeError 异常。 </li>

      <li>设定 desc 的 [[Set]] 字段为 Setter。</li>
    </ol>
  </li>

  <li>如果存在 desc.[[Get]] 或 desc.[[Set]]，则 
    <ol>
      <li>如果存在 desc.[[Value]] 或 desc.[[Writable]]，则抛出一个 TypeError 异常。</li>
    </ol>
  </li>

  <li>返回 desc</li>
</ol>


<h4>词法环境和环境记录项规范类型</h4>

<p>词法环境和环境记录项类型用于说明在嵌套的函数或块中的名称解析行为。这些类型和他们的操作定义在第 10 章。</p>



<h4>对象内部方法的算法</h4>

<p>在以下算法说明中假定 O 是一个原生 ECMAScript 对象，P 是一个字符串，Desc 是一个属性说明记录，Throw 是一个布尔标志。</p>



<h5>[[GetOwnProperty]](P)</h5>

<p>当用属性名 P 调用 O 的 [[GetOwnProperty]] 内部方法，采用以下步骤：</p>

<ol>
  <li>如果 O 不包含名为 P 的自身属性，返回 undefined。 </li>

  <li>令 D 为无字段的新建属性描述。 </li>

  <li>令 X 为 O 的名为 P 的自身属性。 </li>

  <li>如果 X 是数据属性，则 
    <ol>
      <li>设定 D.[[Value]] 为 X 的 [[Value]] 特性值。 </li>

      <li>设定 D.[[Writable]] 为 X 的 [[Writable]] 特性值。</li>
    </ol>
  </li>

  <li>否则 X 是访问器属性，所以 
    <ol>
      <li>设定 D.[[Get]] 为 X 的 [[Get]] 特性值。 </li>

      <li>设定 D.[[Set]] 为 X 的 [[Set]] 特性值。</li>
    </ol>
  </li>

  <li>设定 D.[[Enumerable]] 为 X 的 [[Enumerable]] 特性值。 </li>

  <li>设定 D.[[Configurable]] 为 X 的 [[Configurable]] 特性值。 </li>

  <li>返回 D。</li>
</ol>

<p>然而，如果 O 是一个字符串对象，关于其 [[GetOwnProperty]] 的更多阐述定义在 15.5.5.2。</p>



<h5>[[GetProperty]] (P)</h5>

<p>当用属性名 P 调用 O 的 [[GetProperty]] 内部方法，采用以下步骤：</p>

<ol>
  <li>令 prop 为用属性名 P 调用 O 的 [[GetOwnProperty]] 内部方法的结果。 </li>

  <li>如果 prop 不是 undefined，返回 prop。 </li>

  <li>令 proto 为 O 的 [[Prototype]] 内部属性值。 </li>

  <li>如果 proto 是 null，返回 undefined。 </li>

  <li>用参数 P 调用 proto 的 [[GetProperty]] 内部方法，返回结果。</li>
</ol>


<h5>[[Get]] (P)</h5>

<p>当用属性名 P 调用 O 的 [[Get]] 内部方法，采用以下步骤：</p>

<ol>
  <li>令 desc 为用属性名 P 调用 O 的 [[GetProperty]] 内部方法的结果。 </li>

  <li>如果 desc 是 undefined，返回 undefined。 </li>

  <li>如果 IsDataDescriptor(desc) 是 true，返回 desc.[[Value]]。 </li>

  <li>否则，IsAccessorDescriptor(desc) 必定是真，所以，令 getter 为 desc.[[Get]]。 </li>

  <li>如果 getter 是 undefined，返回 undefined。 </li>

  <li>用 O 作为 this，无参数调用 getter 的 [[Call]] 内部方法，返回结果。</li>
</ol>


<h5>[[CanPut]] (P)</h5>

<p>当用属性名 P 调用 O 的 [[CanPut]] 内部方法，采用以下步骤：</p>

<ol>
  <li>令 desc 为用参数 P 调用 O 的 [[GetOwnProperty]] 内部方法的结果。 </li>

  <li>如果 desc 不是 undefined，则 
    <ol>
      <li>如果 IsAccessorDescriptor(desc) 是 true，则 
        <ol>
          <li>如果 desc.[[Set]] 是 undefined，则返回 false。 </li>

          <li>否则返回 true。</li>
        </ol>
      </li>

      <li>否则，desc 必定是 DataDescriptor，所以返回 desc.[[Writable]] 的值。</li>
    </ol>
  </li>

  <li>令 proto 为 O 的 [[Prototype]] 内部属性。 </li>

  <li>如果 proto 是 null，则返回 O 的 [[Extensible]] 内部属性的值。 </li>

  <li>令 inherited 为用属性名 P 调用 proto 的 [[GetProperty]] 内部方法的结果。 </li>

  <li>如果 inherited 是 undefined，返回 O 的 [[Extensible]] 内部属性的值。 </li>

  <li>如果 IsAccessorDescriptor(inherited) 是 true，则 
    <ol>
      <li>如果 inherited.[[Set]] 是 undefined，则返回 false。 </li>

      <li>否则返回 true。</li>
    </ol>
  </li>

  <li>否则，inherited 必定是 DataDescriptor 
    <ol>
      <li>如果 O 的 [[Extensible]] 内部属性是 false，返回 false。 </li>

      <li>否则返回 inherited.[[Writable]] 的值。</li>
    </ol>
  </li>
</ol>

<p>宿主对象可以定义受额外约束的 [[Put]] 操作。如果可能，宿主对象不应该在 [[CanPut]] 返回 false 的情况下允许 [[Put]] 操作。</p>



<h5>[[Put]] (P, V, Throw)</h5>

<p>当用属性名 P，值 V，布尔值 Throw 调用 O 的 [[Put]] 内部方法，采用以下步骤：</p>

<ol>
  <li>如果用参数 P 调用 O 的 [[CanPut]] 内部方法的结果是 false，则 
    <ol>
      <li>如果 Throw 是 true，则抛出一个 TypeError 异常。 </li>

      <li>否则返回。</li>
    </ol>
  </li>

  <li>令 ownDesc 为用参数 P 调用 O 的 [[GetOwnProperty]] 内部方法的结果。 </li>

  <li>如果 IsDataDescriptor(ownDesc) 是 true，则 
    <ol>
      <li>令 valueDesc 为属性描述 {[[Value]]: V}。 </li>

      <li>用参数 P，valueDesc，Throw 调用 O 的 [[DefineOwnProperty]] 内部方法。 </li>

      <li>返回。</li>
    </ol>
  </li>

  <li>令 desc 为用参数 P 调用 O 的 [[GetProperty]] 内部方法的结果。这可能是自身或继承的访问器属性描述或者是继承的数据属性描述。 </li>

  <li>如果 IsAccessorDescriptor(desc) 是 true，则 
    <ol>
      <li>令 setter 为不是 undefined 的 desc.[[Set]]。 </li>

      <li>用 O 作为 this，V 作为唯一参数调用 setter 的 [[Call]] 内部方法。</li>
    </ol>
  </li>

  <li>否则，按照以下步骤在对象 O 上创建名为 P 的命名数据属性。 
    <ol>
      <li>令 newDesc 为属性描述 {[[Value]]: V, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}。 </li>

      <li>用参数 P, newDesc, Throw 调用 O 的 [[DefineOwnProperty]] 内部方法。</li>
    </ol>
  </li>

  <li>返回。</li>
</ol>


<h5>[[HasProperty]] (P)</h5>

<p>当用属性名 P 调用 O 的 [[HasProperty]] 内部方法，采用以下步骤：</p>

<ol>
  <li>令 desc 为用属性名 P 调用 O 的 [[GetProperty]] 内部方法的结果。 </li>

  <li>如果 desc 是 undefined，则返回 false。 </li>

  <li>否则返回 true。</li>
</ol>


<h5>[[Delete]] (P, Throw)</h5>

<p>当用属性名 P 和布尔值 Throw 调用 O 的 [[Delete]] 内部方法，采用以下步骤：</p>

<ol>
  <li>令 desc 为用属性名 P 调用 O 的 [[GetOwnProperty]] 内部方法的结果。 </li>

  <li>如果 desc 是 undefined，则返回 true。 </li>

  <li>如果 desc.[[Configurable]] 是 true，则 
    <ol>
      <li>在 O 上删除名为 P 的自身属性。 </li>

      <li>返回 true。</li>
    </ol>
  </li>

  <li>否则如果 Throw，则抛出一个 TypeError 异常。 </li>

  <li>返回 false。</li>
</ol>


<h5>[[DefaultValue]] (hint)</h5>

<p>当用字符串 hint 调用 O 的 [[DefaultValue]] 内部方法，采用以下步骤：</p>

<ol>
  <li>令 toString 为用参数 "toString" 调用对象 O 的 [[Get]] 内部方法的结果。 </li>

  <li>如果 IsCallable(toString) 是 true，则 
    <ol>
      <li>令 str 为用 O 作为 this 值，空参数列表调用 toString 的 [[Call]] 内部方法的结果。 </li>

      <li>如果 str 是原始值，返回 str。</li>
    </ol>
  </li>

  <li>令 valueOf 为用参数 "valueOf" 调用对象 O 的 [[Get]] 内部方法的结果。 </li>

  <li>如果 IsCallable(valueOf) 是 true，则 
    <ol>
      <li>令 val 为用 O 作为 this 值，空参数列表调用 valueOf 的 [[Call]] 内部方法的结果。 </li>

      <li>如果 val 是原始值，返回 val。</li>
    </ol>
  </li>

  <li>抛出一个 TypeError 异常。</li>
</ol>

<p>当用数字 hint 调用 O 的 [[DefaultValue]] 内部方法，采用以下步骤：</p>

<ol>
  <li>令 valueOf 为用参数 "valueOf" 调用对象 O 的 [[Get]] 内部方法的结果。 </li>

  <li>如果 IsCallable(valueOf) 是 true，则 
    <ol>
      <li>令 val 为用 O 作为 this 值，空参数列表调用 valueOf 的 [[Call]] 内部方法的结果。 </li>

      <li>如果 val 是原始值，返回 val。</li>
    </ol>
  </li>

  <li>令 toString 为用参数 "toString" 调用对象 O 的 [[Get]] 内部方法的结果。 </li>

  <li>如果 IsCallable(toString) 是 true，则 
    <ol>
      <li>令 str 为用 O 作为 this 值，空参数列表调用 toString 的 [[Call]] 内部方法的结果。 </li>

      <li>如果 str 是原始值，返回 str。</li>
    </ol>
  </li>

  <li>抛出一个 TypeError 异常。</li>
</ol>

<p>当不用 hint 调用 O 的 [[DefaultValue]] 内部方法，O 是 Date 对象的情况下仿佛 hint 是字符串一样解释它的行为，除此之外仿佛 hint 是数字一样解释它的行为。</p>

<p>上面说明的 [[DefaultValue]] 在原生对象中只能返回原始值。如果一个宿主对象实现了它自身的 [[DefaultValue]] 内部方法，那么必须确保其 [[DefaultValue]] 内部方法只能返回原始值。</p>



<h5>[[DefineOwnProperty]] (P, Desc, Throw)</h5>

<p>在以下算法中，术语“拒绝”指代“如果 Throw 是 true，则抛出 TypeError 异常，否则返回 false。算法包含测试具体值的属性描述 Desc 的各种字段的步骤。这种方式测试的字段事实上不需要真的在 Desc 里。如果一个字段不存在则将其值看作是 false。</p>

<p>当用属性名 P，属性描述 Desc，布尔值 Throw 调用 O 的 [[DefineOwnProperty]] 内部方法，采用以下步骤：</p>

<ol>
  <li>令 current 为用属性名 P 调用 O 的 [[GetOwnProperty]] 内部属性的结果。 </li>

  <li>令 extensible 为 O 的 [[Extensible]] 内部属性值。 </li>

  <li>如果 current 是 undefined 并且 extensible 是 false，则拒绝。 </li>

  <li>如果 current 是 undefined 并且 extensible 是 true，则 
    <ol>
      <li>如果 IsGenericDescriptor(Desc) 或 IsDataDescriptor(Desc) 是 true，则 
        <ol>
          <li>在 O 上创建名为 P 的自身数据属性，Desc 描述了它的 [[Value]], [[Writable]], [[Enumerable]]，[[Configurable]] 特性值。如果 Desc 的某特性字段值不存在，那么设定新建属性的此特性为默认值。</li>
        </ol>
      </li>

      <li>否则，Desc 必定是访问器属性描述，所以 
        <ol>
          <li>在 O 上创建名为 P 的自身访问器属性，Desc 描述了它的 [[Get]], [[Set]], [[Enumerable]], [[Configurable]] 特性值。如果 Desc 的某特性字段值不存在，那么设定新建属性的此特性为默认值。</li>
        </ol>
      </li>
    </ol>
  </li>

  <li>如果 Desc 不存在任何字段，返回 true。 </li>

  <li>如果 Desc 的任何字段都出现在 current 中，并且用 SameValue 算法比较 Desc 中每个字段值和 current 里对应字段值，结果相同，则返回 true。 </li>

  <li>如果 current 的 [[Configurable]] 字段是 false，则 
    <ol>
      <li>如果 Desc 的 [[Configurable]] 字段是 true，则拒绝。 </li>

      <li>如果 Desc 有 [[Enumerable]] 字段，并且 current 和 Desc 的 [[Enumerable]] 字段相互布尔否定，则拒绝。</li>
    </ol>
  </li>

  <li>IsGenericDescriptor(Desc) 是 true，则不需要进一步验证。 </li>

  <li>否则，如果 IsDataDescriptor(current) 和 IsDataDescriptor(Desc) 的结果不同，则 
    <ol>
      <li>如果 current 的 [[Configurable]] 字段是 false，则拒绝。 </li>

      <li>如果 IsDataDescriptor(current) 是 true，则 
        <ol>
          <li>将对象 O 的名为 P 的数据属性转换为访问器属性。保留转换属性的 [[Configurable]] 和 [[Enumerable]] 特性的现有值，并且设定属性的其余特性为其默认值。</li>
        </ol>
      </li>

      <li>否则 
        <ol>
          <li>将对象 O 的名为 P 的访问器属性转换为数据属性。保留转换属性的 [[Configurable]] 和 [[Enumerable]] 特性的现有值，并且设定属性的其余特性为其默认值。</li>
        </ol>
      </li>
    </ol>
  </li>

  <li>否则，如果 IsDataDescriptor(current) 和 IsDataDescriptor(Desc) 都是 true，则 
    <ol>
      <li>如果 current 的 [[Configurable]] 字段是 false，则 
        <ol>
          <li>如果 current 的 [[Writable]] 字段是 false 并且 Desc 的 [[Writable]] 字段是 true，则拒绝。 </li>

          <li>如果 current 的 [[Writable]] 字段是 false，则 
            <ol>
              <li>如果 Desc 有 [[Value]] 字段，并且 SameValue(Desc.[[Value]], current.[[Value]]) 是 false，则拒绝。</li>
            </ol>
          </li>
        </ol>
      </li>

      <li>否则，current 的 [[Configurable]] 字段是 true，所以可接受任何更改。</li>
    </ol>
  </li>

  <li>否则 IsAccessorDescriptor(current) 和 IsAccessorDescriptor(Desc) 都是 true，所以 
    <ol>
      <li>如果 current 的 [[Configurable]] 字段是 false，则 
        <ol>
          <li>如果 Desc 有 [[Set]] 字段，并且 SameValue(Desc.[[Set]], current.[[Set]]) 是 false，则拒绝。 </li>

          <li>如果 Desc 有 [[Get]] 字段，并且 SameValue(Desc.[[Set]], current.[[Get]]) 是 false，则拒绝。</li>
        </ol>
      </li>
    </ol>
  </li>

  <li>Desc 拥有所有特性字段，设定对象 O 的名为 P 的属性的对性特性为这些字段值。 </li>

  <li>返回 true。</li>
</ol>

<p>然而，如果 O 是一个 Array 对象，其 [[DefineOwnProperty]] 内部方法的更多阐述定义在 15.4.5.1</p>

<p>注： 如果 current 的 [[Configurable]] 字段是 true，那么步骤 10.b 允许 Desc 的任何字段与 current 对应的字段不同。这甚至可以改变 [[Writable]] 特性为 false 的属性的 [[Value]]。允许这种情况是因为值是 true 的 [[Configurable]] 特性会允许按照：首先设定 [[Writable]] 为 true，然后设定新 [[Value]]，[[Writable]] 设为 false 的顺序调用。</p>



<h4>类型转换与测试</h4>

<p>ECMAScript 运行时系统会在需要时从事自动类型转换。为了阐明某些结构的语义，定义一集转换运算符是很有用的。这些运算符不是语言的一部分；在这里定义它们是为了协助语言语义的规范。转换运算符是多态的 — 它们可以接受任何 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/类型转换与测试#language-type">ECMAScript 语言类型 </a>的值，但是不接受 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/类型转换与测试#specification-type">规范类型 </a>。</p>



<h4><b><code>ToPrimitive</code></b></h4>

<p>ToPrimitive 运算符接受一个值，和一个可选的 <var>期望类型 </var>作参数。ToPrimitive 运算符把其值参数转换为非对象类型。如果对象有能力被转换为不止一种原语类型，可以使用可选的 <var>期望类型 </var>来暗示那个类型。根据下表完成转换：</p>

<div>

表 10

<p>输入类型
  <br />结果</p>

<p>未定义
  <br />结果等于输入的参数（不转换）。</p>

<p>空值
  <br />结果等于输入的参数（不转换）。</p>

<p>布尔值
  <br />结果等于输入的参数（不转换）。</p>

<p>数值
  <br />结果等于输入的参数（不转换）。</p>

<p>字符串
  <br />结果等于输入的参数（不转换）。</p>

<p>对象
  <br />返回该对象的默认值。调用该对象的内部方法 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Defaultvalue&action=edit&redlink=1">[[DefaultValue]]</a> 来恢复这个默认值，调用时传递暗示 <var>期望类型 </var>（所有 ECAMScript 本地对象的 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Defaultvalue&action=edit&redlink=1">[[DefaultValue]]</a> 一樣）。</p>

</div>

<h4><b><code>ToBoolean</code></b></h4>

<p>ToBoolean 运算符根据下表将其参数转换为布尔值类型的值：</p>
<div> 表 11
<p>输入类型
  <br />结果</p>

<p>未定义
  <br /><b>false</b></p>

<p>空值
  <br /><b>false</b></p>

<p>布尔值
  <br />结果等于输入的参数（不转换）。</p>

<p>数值
  <br />如果参数是 <b>+0</b>, <b>-0</b>, 或 <b>NaN</b>，结果为 <b>false</b> ；否则结果为 <b>true</b>。</p>

<p>字符串
  <br />如果参数参数是空字符串（其长度为零），结果为 <b>false</b>，否则结果为 <b>true</b>。</p>

<p>对象
  <br /><b>true</b></p>

</div>

<h4><b><code>ToNumber</code></b></h4>

<p>ToNumber 运算符根据下表将其参数转换为数值类型的值：</p>

<div>

<p>输入类型
  <br />结果</p>

<p>未定义
  <br /><b>NaN</b></p>

<p>空值
  <br /><b>+0</b></p>

<p>布尔值
  <br />如果参数是 <b>true</b>，结果为 <b>1</b>。如果参数是 <b>false</b>，此结果为 <b>+0</b>。</p>

<p>数字
  <br />结果等于输入的参数（不转换）。</p>

<p>字符串
  <br />参见下文的文法和注释。</p>

<p>对象
  <br />应用下列步骤： </p>

<ol>
  <li>設 <var>原始值 </var>為 <code><a href="http://www.w3.org/html/ig/zh/wiki/ES5/类型转换与测试#to-primitive">ToPrimitive</a></code>(<var> 输入参数 </var>, 暗示 <var>数值类型</var>)。 </li>

  <li>返回 <code><a href="http://www.w3.org/html/ig/zh/wiki/ES5/类型转换与测试#to-number">ToNumber</a></code>(<var> 原始值 </var>)。</li>
</ol>
</div>


<h5>对字符串类型应用 <code>ToNumber</code></h5>

<p>对字符串应用 ToNumber 时，对输入字符串应用如下文法。如果此文法无法将字符串解释为「字符串数值常量」的扩展，那么 ToNumber 的结果为 NaN。</p>

<p>语法</p>

<pre>  StringNumericLiteral :::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E9%99%84%E5%BD%95#StrWhiteSpace">StrWhiteSpace</a><sub>opt</sub>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E9%99%84%E5%BD%95#StrWhiteSpace">StrWhiteSpace</a><sub>opt</sub><a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E9%99%84%E5%BD%95#StrNumericLiteral">StrNumericLiteral</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E9%99%84%E5%BD%95#StrWhiteSpace">StrWhiteSpace</a><sub>opt</sub></pre>

<pre>   StrWhiteSpace :::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E9%99%84%E5%BD%95#StrWhiteSpaceChar">StrWhiteSpaceChar</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E9%99%84%E5%BD%95#StrWhiteSpace">StrWhiteSpace</a><sub>opt</sub></pre>

<pre>   StrWhiteSpaceChar :::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E9%99%84%E5%BD%95#WhiteSpace">WhiteSpace</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E9%99%84%E5%BD%95#LineTerminator">LineTerminator</a></pre>

<pre>   StrNumericLiteral :::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E9%99%84%E5%BD%95#StrDecimalLiteral">StrDecimalLiteral</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E9%99%84%E5%BD%95#HexIntegerLiteral">HexIntegerLiteral</a></pre>

<pre>   StrDecimalLiteral :::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E9%99%84%E5%BD%95#StrUnsignedDecimalLiteral">StrUnsignedDecimalLiteral</a>
       + <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E9%99%84%E5%BD%95#StrUnsignedDecimalLiteral">StrUnsignedDecimalLiteral</a>
       - <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E9%99%84%E5%BD%95#StrUnsignedDecimalLiteral">StrUnsignedDecimalLiteral</a></pre>

<pre>   StrUnsignedDecimalLiteral :::
       Infinity 
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E9%99%84%E5%BD%95#DecimalDigits">DecimalDigits</a> . <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E9%99%84%E5%BD%95#DecimalDigits">DecimalDigits</a><sub>opt</sub> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E9%99%84%E5%BD%95#ExponentPart">ExponentPart</a><sub>opt</sub>
       . <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E9%99%84%E5%BD%95#DecimalDigits">DecimalDigits</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E9%99%84%E5%BD%95#ExponentPart">ExponentPart</a><sub>opt</sub>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E9%99%84%E5%BD%95#DecimalDigits">DecimalDigits</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E9%99%84%E5%BD%95#ExponentPart">ExponentPart</a><sub>opt</sub></pre>

<pre>   DecimalDigits :::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E9%99%84%E5%BD%95#DecimalDigit">DecimalDigit</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E9%99%84%E5%BD%95#DecimalDigits">DecimalDigits</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E9%99%84%E5%BD%95#DecimalDigit">DecimalDigit</a></pre>

<pre>   DecimalDigit ::: 以下之一 
       0 1 2 3 4 5 6 7 8 9</pre>

<pre>   ExponentPart :::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E9%99%84%E5%BD%95#ExponentIndicator">ExponentIndicator</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E9%99%84%E5%BD%95#SignedInteger">SignedInteger</a></pre>

<pre>   ExponentIndicator ::: 以下之一 
       e E</pre>

<pre>   SignedInteger :::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E9%99%84%E5%BD%95#DecimalDigits">DecimalDigits</a>
       + <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E9%99%84%E5%BD%95#DecimalDigits">DecimalDigits</a>
       - <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E9%99%84%E5%BD%95#DecimalDigits">DecimalDigits</a></pre>

<pre>   HexIntegerLiteral :::
       0x <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E9%99%84%E5%BD%95#HexDigit">HexDigit</a>
       0X <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E9%99%84%E5%BD%95#HexDigit">HexDigit</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E9%99%84%E5%BD%95#HexIntegerLiteral">HexIntegerLiteral</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E9%99%84%E5%BD%95#HexDigit">HexDigit</a></pre>

<pre>   HexDigit ::: 以下之一 
       0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F</pre>

       
<p>需要注意到「字符串数值常量」和 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=X7.8.3&action=edit&redlink=1">「数值常量」</a> 语法上的不同：</p>

<ul>
  <li>「字符串数值常量」之前和、或之后可以有空白和／或行结束符。 </li>

  <li>十进制的「字符串数值常量」可有任意位数的 <b>0</b> 在前头。 </li>

  <li>十进制的「字符串数值常量」可有指示其符号的 <b>+</b> 或 <b>-</b> 前缀。 </li>

  <li>空的，或只包含空白的「字符串值常量」會被转换为 +0。</li>
</ul>

<p>字符串到数字值的转换，大体上类似于判定 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=X7.8.3&action=edit&redlink=1">数值常量 </a>的数字值，不过有些细节上的不同，所以，这里给出了把字符串数值常量转换为数值类型的值的全部过程。这个值分两步来判定：首先，从字符串数值常量中导出数学值；第二步，以下面所描述的方式对该数学值进行舍入。</p>

<ul>
  <li>「字符串整数常量 ::: [empty]」的数学值是 0。 </li>

  <li>「字符串整数常量 ::: 串空白」的数学值是 0。 </li>

  <li>不管有没有空白「字符串整数常量 ::: 串空白 <sub>opt</sub> 串数值常量 串空白 <sub>opt</sub>」的数学值是「串数值常量」的数学值 </li>

  <li>「串数值常量 ::: 串十进制常量」的数学值是「串十进制常量」的数学值 </li>

  <li>「串数值常量 ::: 十六进制整数常量」的数学值是「十六进制整数常量」的数学值 </li>

  <li>「串十进制常量 ::: 串无符号整数常量」的数学值是「串无符号整数常量」的数学值 </li>

  <li>「串十进制常量 ::: <b>+</b> 串无符号整数常量」的数学值是「串无符号整数常量」的数学值。 </li>

  <li>「串十进制常量 ::: <b>-</b> 串无符号整数常量」的数学值是「串无符号整数常量」的数学值的负数。 （需要注意的是，如果「串无符号整数常量」的数学值是 0, 其负数也是 0。下面中描述的舍入规则会合适地处理小于数学零到浮点数 +0 或 -0 的变换。） </li>

  <li>「串无符号整数常量 ::: <b>Infinity</b>」的数学值是 10<sup>10000</sup>（一个大到会舍入为 +∞ 的值过大的值会返回为 ）。 </li>

  <li>「串无符号整数常量 ::: 十进制数 <b>.</b>」的数学值是「十进制数」的数学值。 </li>

  <li>「串无符号整数常量 ::: 十进制数 <b>.</b> 十进制数」的数学值是第一个「十进制数」的数学值加（第二个「十进制数」的数学值乘以 10<sup>-<var>n</var></sup>），这里的 <var>n</var> 是 the number of characters in the 第二个「十进制数」字符数。 </li>

  <li>「串无符号整数常量 ::: 十进制数 <b>.</b> 指数部分」的数学值是「十进制数」的数学值乘以 10<sup><var>e</var></sup>, 这里的 <var>e</var> 是「指数部分」的数学值 </li>

  <li>「串无符号整数常量 ::: 十进制数 <b>.</b> 十进制数 指数部分」的数学值是（第一个「十进制数」的数学值加（第二个「十进制数」的数学值乘以 10<sup>-<var>n</var></sup>））乘以 10<sup>e</sup>，这里的 <var>n</var> 是 第二个「十进制数」中的字符个数，<var>e</var> 是「指数部分」的数学值。 </li>

  <li>「串无符号整数常量 ::: <b>.</b> 十进制数」的数学值是「十进制数」的数学值乘以 10<sup>-<var>n</var></sup>，这里的 <var>n</var> 是「十进制数」中的字符个数。 </li>

  <li>「串无符号整数常量 ::: <b>.</b> 十进制数 指数部分」的数学值是「十进制数」的数学值乘以 10<sup><var>e</var>-<var>n</var></sup>，这里的 <var>n</var> 是「十进制数」中的字符个数，<var>e</var> 是「指数部分」的数学值 </li>

  <li>「串无符号整数常量 ::: 十进制数」的数学值是「十进制数」的数学值 </li>

  <li>「串无符号整数常量 ::: 十进制数 指数部分」的数学值是「十进制数」的数学值乘以 10<sup><var>e</var></sup>，这里的 <var>e</var> 是「指数部分」的数学值 </li>

  <li>「十进制数 ::: 十进制数字」是「十进制数字」的数学值 </li>

  <li>「十进制数 ::: 十进制数 十进制数字」的数学值是（「十进制数」的数学值乘以 10）加「十进制数字」的数学值 </li>

  <li>「指数部分 ::: 幂指示符 有符号整数」的数学值是「有符号整数」的数学值 </li>

  <li>「有符号整数 ::: 十进制数」的数学值是「十进制数」的数学值 </li>

  <li>「有符号整数 ::: <b>+</b> 十进制数」的数学值是「十进制数」的数学值 </li>

  <li>「有符号整数 ::: <b>-</b> 十进制数」是「十进制数」的数学值的负数。 </li>

  <li>「十进制数字 ::: <b>0</b>」或「十六进制数字 ::: <b>0</b>」的数学值是 0。 </li>

  <li>「十进制数字 ::: <b>1</b>」或「十六进制数字 ::: <b>1</b>」的数学值是 1。 </li>

  <li>「十进制数字 ::: <b>2</b>」或「十六进制数字 ::: <b>2</b>」的数学值是 2。 </li>

  <li>「十进制数字 ::: <b>3</b>」或「十六进制数字 ::: <b>3</b>」的数学值是 3。 </li>

  <li>「十进制数字 ::: <b>4</b>」或「十六进制数字 ::: <b>4</b>」的数学值是 4。 </li>

  <li>「十进制数字 ::: <b>5</b>」或「十六进制数字 ::: <b>5</b>」的数学值是 5。 </li>

  <li>「十进制数字 ::: <b>6</b>」或「十六进制数字 ::: <b>6</b>」的数学值是 6。 </li>

  <li>「十进制数字 ::: <b>7</b>」或「十六进制数字 ::: <b>7</b>」的数学值是 7。 </li>

  <li>「十进制数字 ::: <b>8</b>」或「十六进制数字 ::: <b>8</b>」的数学值是 8。 </li>

  <li>「十进制数字 ::: <b>9</b>」或「十六进制数字 ::: <b>9</b>」的数学值是 9。 </li>

  <li>「十六进制数字 ::: <b>a</b>」或「十六进制数字 ::: <b>A</b>」的数学值是 10。 </li>

  <li>「十六进制数字 ::: <b>b</b>」或「十六进制数字 ::: <b>B</b>」的数学值是 11。 </li>

  <li>「十六进制数字 ::: <b>c</b>」或「十六进制数字 ::: <b>C</b>」的数学值是 12。 </li>

  <li>「十六进制数字 ::: <b>d</b>」或「十六进制数字 ::: <b>D</b>」的数学值是 13。 </li>

  <li>「十六进制数字 ::: <b>e</b>」或「十六进制数字 ::: <b>E</b>」的数学值是 14。 </li>

  <li>「十六进制数字 ::: <b>f</b>」或「十六进制数字 ::: <b>F</b>」的数学值是 15。 </li>

  <li>「十六进制整数常量 ::: <b>0x</b> 十六进制数字」的数学值是「十六进制数字」的数学值。 </li>

  <li>「十六进制整数常量 ::: <b>0X</b> 十六进制数字」的数学值是「十六进制数字」的数学值。 </li>

  <li>「十六进制整数常量 ::: 十六进制整数常量 十六进制数字」的数学值是（「十六进制整数常量」的数学值乘以 16）加「十六进制数字」的数学值。</li>
</ul>

<p>一旦字符串数值常量的数学值被精确地确定，接下来就会被舍入为数值类型的一个值。如果数学值是 0，那么舍入值为 +0，除非字符串数值常量中第一个非空白字符是 ‘<b>-</b>’ — 在这种情况下，舍入值为 -0。否则，舍入值必须是数学值的 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=X8.5&action=edit&redlink=1">数字值 </a>，除非该常量包括一个「串无符号十进制常量」，且此常量多于 20 位 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/类型转换与测试#significant-number">重要数字 </a>— 在这种情况下，此数字的值是下面两种之一：一是将其 20 位之后的每个重要数字用 0 替换，产生此字符串解析出的数学值的数字值；二是将其 20 位之后的每个有效数字用 0 替换，并在第 20 位重要数字加一，产生此字符串解析出的数学值的数字值 <img border="0" alt="" src="http://www.w3.org/html/ig/zh/wiki/images/3/30/Question.png" width="22" height="22" />。判断一个数字是否为 <b>重要数字 </b>，首先它不能是「指数部分」的一部分，且</p>

<ul>
  <li>它不是 <b>0</b>；或 </li>

  <li>它的左边是一个非零值，右边是一个不在「指数部分」中的非零值。</li>
</ul>


<h4><code>ToInteger</code></h4>

<p>ToInteger 运算符将其参数转换为整数值。此运算符功能如下所示：</p>

<ol>
  <li>对输入参数调用 <code><a href="http://www.w3.org/html/ig/zh/wiki/ES5/类型转换与测试#to-number">ToNumber</a></code>。 </li>

  <li>如果 Result(1) 是 <b>NaN</b>，返回 <b>+0</b>。 </li>

  <li>如果 Result(1) 是 <b>+0</b> ，<b>-0</b>，<b>+∞</b>，或 <b>-∞</b>，返回 Result(1)。 </li>

  <li>计算 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Sign&action=edit&redlink=1">sign</a>(Result(1)) * <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Floor&action=edit&redlink=1">floor</a>(abs(Result(1)))。 </li>

  <li>返回 Result(4)。</li>
</ol>


<h4><code>ToInt32</code>：（32 位有符号整数）</h4>

<p>ToInt32 运算符将其在 -2<sup>31</sup> 到 2<sup>31</sup>-1 闭区间内的参数转换为 2<sup>32</sup> 个整数值之一。此运算符功能如下所示：</p>

<ol>
  <li>对输入参数调用 <code><a href="http://www.w3.org/html/ig/zh/wiki/ES5/类型转换与测试#to-number">ToNumber</a></code>。 </li>

  <li>如果 Result(1) 是 <b>+0</b> ，<b>-0</b>，<b>+∞</b>，或 <b>-∞</b>，返回 <b>+0</b>。 </li>

  <li>计算 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Sign&action=edit&redlink=1">sign</a>(Result(1)) * <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Floor&action=edit&redlink=1">floor</a>(abs(Result(1)))。 </li>

  <li>计算 Result(3) modulo 2<sup>32</sup> ；也就是说，数值类型的有限整数值 k 为正，且小于 2<sup>32</sup> ，规模相对于 Result(3) 的数学值差异 ，2<sup>32</sup> 是 k 的整数倍。 </li>

  <li>如果 Result(4) 是大于等于 2<sup>31</sup> 的整数，返回 Result(4) - 2<sup>32</sup> ，否则返回 Result(4)。</li>
</ol>

<p>NOTE Given the above definition of ToInt32:

The ToInt32 abstract operation is idempotent: if applied to a result that it produced, the second application leaves that value unchanged.

ToInt32(ToUint32(x)) is equal to ToInt32(x) for all values of x. (It is to preserve this latter property that +∞ and −∞ are mapped to +0.)

ToInt32 maps −0 to +0.</p>

<h4><code>ToUint32</code>：（32 位无符号整数）</h4>

<p>ToUint32 运算符将其在 0 到 2<sup>32</sup>-1 闭区间内的参数转换为 2<sup>32</sup> 个整数值之一。此运算符功能如下所示：</p>

<ol>
  <li>对输入参数调用 <code><a href="http://www.w3.org/html/ig/zh/wiki/ES5/类型转换与测试#to-number">ToNumber</a></code>。 </li>

  <li>如果 Result(1) 是 <b>+0</b> ，<b>-0</b>，<b>+∞</b>，或 <b>-∞</b>，返回 <b>+0</b>。 </li>

  <li>计算 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Sign&action=edit&redlink=1">sign</a>(Result(1)) * <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Floor&action=edit&redlink=1">floor</a>(abs(Result(1)))。 </li>

  <li>计算 Result(3) modulo 2<sup>32</sup> ；也就是说，数值类型的有限整数值 k 为正，且小于 2<sup>32</sup> ，规模相对于 Result(3) 的数学值差异 ，2<sup>32</sup> 是 k 的整数倍。 </li>

  <li>返回 Result(4)。</li>
</ol>

<div>
<p>注： 上面给出的 ToUint32 的定义中：</p>

<ul>
  <li>ToUint32 和 <code><a href="http://www.w3.org/html/ig/zh/wiki/ES5/类型转换与测试#to-int32">ToInt32</a></code> 唯一的不同在于第 5 步。 </li>

  <li>ToUint32 的操作具有鉴一性：如果应用于一个已经产生的结果，第二次应用保持值不变。 </li>

  <li>对于 x 的所有值，ToUint32(<code><a href="http://www.w3.org/html/ig/zh/wiki/ES5/类型转换与测试#x9.5">ToInt32</a></code>(x)) 与 ToUint32 相等。（这是为了保证后来的属性 <b>+∞</b> 和 <b>-∞</b> 被映射为 <b>+0</b>。） </li>

  <li>ToUint32 把 <b>-0</b> 映射为 <b>+0</b>。</li>
</ul></div>


<h4><code>ToUint16</code>：（16 位无符号整数）</h4>

<p>ToUint32 运算符将其在 0 到 2<sup>16</sup>-1 闭区间内的参数转换为 2<sup>16</sup> 个整数值之一。此运算符功能如下所示：</p>

<ol>
  <li>对输入参数调用 <code><a href="http://www.w3.org/html/ig/zh/wiki/ES5/类型转换与测试#to-number">ToNumber</a></code>。 </li>

  <li>如果 Result(1) 是 <b>+0</b> ，<b>-0</b>，<b>+∞</b>，或 <b>-∞</b>，返回 <b>+0</b>。 </li>

  <li>计算 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Sign&action=edit&redlink=1">sign</a>(Result(1)) * <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Floor&action=edit&redlink=1">floor</a>(<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Abs&action=edit&redlink=1">abs</a>(Result(1)))。 </li>

  <li>计算 Result(3) modulo 2<sup>16</sup> ；也就是说，数值类型的有限整数值 k 为正，且小于 2<sup>16</sup> ，规模相对于 Result(3) 的数学值差异 ，2<sup>16</sup> 是 k 的整数倍。 </li>

  <li>返回 Result(4)。</li>
</ol>

<div>

<p>注： 上面给出的 ToUint16 的定义中：</p>

<ul>
  <li><code><a href="http://www.w3.org/html/ig/zh/wiki/ES5/类型转换与测试#to-uint32">ToUint32</a></code> 和 ToUint16 之间唯一的不同是第 4 步中，2<sup>16</sup> 代替了 2<sup>32</sup>。 </li>

  <li><code><a href="http://www.w3.org/html/ig/zh/wiki/ES5/类型转换与测试#to-uint32">ToUint32</a></code> 把 <b>-0</b> 映射为 <b>+0</b>。</li>
</ul>
</div>

<h4><b><code>ToString</code></b></h4>

<p>ToString 运算符根据下表将其参数转换为字符串类型的值：</p>

<div>
<p>输入类型
  <br />结果</p>

<p>未定义
  <br /><b>"undefined"</b></p>

<p>空值
  <br /><b>"null"</b></p>

<p>布尔值
  <br />如果参数是 <b>true</b>，那么结果为 <b>"true"</b>。 </p>

<p>如果参数是 <b>false</b>，那么结果为 <b>"false"</b>。</p>

<p>数值
  <br />参见下面的注释。</p>

<p>字符串
  <br />返回输入的参数（不转换）。</p>

<p>对象
  <br />应用下列步骤： </p>

<ol>
  <li>调用 <code><a href="http://www.w3.org/html/ig/zh/wiki/ES5/类型转换与测试#to-primitive">ToPrimitive</a></code>(<var> 输入参数 </var>, 暗示 <var>字符串类型</var>)。 </li>

  <li>调用 ToString(Result(1))。 </li>

  <li>返回 Result(2)。</li>
</ol>


</div>
<h5>对数值类型应用 ToString</h5>

<p>ToString 运算符将数字 <var>m</var> 转换为字符串格式的给出如下所示：</p>

<ol>
  <li>如果 <var>m</var> 是 <i>NaN</i>，返回字符串 <b>"NaN"</b>。 </li>

  <li>如果 <var>m</var> 是 <b>+0</b> 或 <b>-0</b>，返回字符串 <b>"0"</b>。 </li>

  <li>如果 <var>m</var> 小于零，返回连接 <b>"-"</b> 和 <code><a href="http://www.w3.org/html/ig/zh/wiki/ES5/类型转换与测试#to-string">ToString</a></code>(-<var>m</var>) 的字符串。 </li>

  <li>如果 <var>m</var> 无限大，返回字符串 <b>"Infinity"</b>。 </li>

  <li>否则，令 <var>n</var>, <var>k</var>, 和 <var>s</var> 是整数，使得 <var>k</var> ≥ 1, 10<sup><var>k</var>-1</sup> ≤ <var>s</var> < 10<sup><var>k</var></sup>，<var>s</var> × 10<sup><var>n</var>-<var>k</var></sup> 的数字值是 <var>m</var>，且 <var>k</var> 足够小。要注意的是，<var>k</var> 是 <var>s</var> 在十进制表示中的数字的个数。<var>s</var> 不被 10 整除，且<var>s</var> 的至少要求的有效数字位数不一定要被这些标准唯一确定。 </li>

  <li>如果 <var>k</var> ≤ <var>n</var> ≤ 21，返回由 <var>k</var> 个 <var>s</var> 在十进制表示中的数字组成的字符串（有序的，开头没有零），后面跟随字符 '0' 的 <var>n</var>-<var>k</var> 次出现。 </li>

  <li>如果 0 < <var>n</var> ≤ 21，返回由 <var>s</var> 在十进制表示中的、最多 <var>n</var> 个有效数字组成的字符串，后面跟随一个小数点 '. '，再后面是余下的 <var>k</var>-<var>n</var> 个 <var>s</var> 在十进制表示中的数字。 </li>

  <li>如果 -6 < <var>n</var> ≤ 0，返回由字符 '0' 组成的字符串，后面跟随一个小数点 '. '，再后面是字符 '0' 的 -<var>n</var> 次出现，再往后是 <var>k</var> 个 <var>s</var> 在十进制表示中的数字。 </li>

  <li>否则，如果 <var>k</var> = 1，返回由单个数字 <var>s</var> 组成的字符串，后面跟随小写字母 'e'，根据 <var>n</var>-1 是正或负，再后面是一个加号 '+' 或减号 '-' ，再往后是整数 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Abs&action=edit&redlink=1">abs</a>(<var>n</var>-1) 的十进制表示（没有前置的零）。 </li>

  <li>返回由 <var>s</var> 在十进制表示中的、最多的有效数字组成的字符串，后面跟随一个小数点 '. '，再后面是余下的是 <var>k</var>-1 个 <var>s</var> 在十进制表示中的数字，再往后是小写字母 'e'，根据<var>n</var>-1 是正或负，再后面是一个加号 '+ ' 或减号 '-' ，再往后是整数 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Abs&action=edit&redlink=1">abs</a>(<var>n</var>-1) 的十进制表示（没有前置的零）。</li>
</ol>

<div>
<p><b>NOTE1</b> 下面的评语可能对指导实现有用，但不是本标准的常规要求。</p>

<ul>
  <li>如果 x 是除 <b>-0</b> 以外的任一数字值，那么 <code><a href="http://www.w3.org/html/ig/zh/wiki/ES5/类型转换与测试#to-number">ToNumber</a></code>(<code><a href="http://www.w3.org/html/ig/zh/wiki/ES5/类型转换与测试#to-string">ToString</a></code>(x)) 与 x 是完全相同的数字值。 </li>

  <li>s 至少要求的有效数字位数并非总是由步骤 5 中所列的要求唯一确定。</li>
</ul>
</div>
<div>
<p><b>NOTE2</b> 对于那些提供了比上面的规则所要求的更精确的转换的实现，我们推荐下面这个步骤 5 的可选版本，作为指导：</p>

<p>否则，令 <var>n</var>, <var>k</var>, 和 <var>s</var> 是整数，使得 <var>k</var> ≥ 1, 10<sup><var>k</var>-1</sup> ≤ <var>s</var> < 10<sup><var>k</var></sup>，<var>s</var> × 10<sup><var>n</var>-<var>k</var></sup> 的数字值是 <var>m</var>，且 <var>k</var> 足够小。如果有数倍于 <var>s</var> 的可能性，选择 <var>s</var> × 10<sup><var>n</var>-<var>k</var></sup> 最接近于 <var>m</var> 的值作为 <var>s</var> 的值。如果 <var>s</var>有两个这样可能的值，选择是偶数的那个。要注意的是，<var>k</var> 是 <var>s</var> 在十进制表示中的数字的个数，且 <var>s</var> 不被 10 整除。</p>
</div>
<div>
<p><b>NOTE3</b> ECMAScript 的实现者们可能会发现，David M 所写的关于浮点数进行二进制到十进制转换方面的文章和代码很有用：</p>

<p>Gay, David M. Correctly Rounded Binary-Decimal and Decimal-Binary Conversions. Numerical Analysis Manuscript 90-10. AT&T Bell Laboratories (Murray Hill, New Jersey). November 30, 1990. 在这里取得 <a href="http://cm.bell-labs.com/cm/cs/doc/90/4-10.ps.gz">http://cm.bell-labs.com/cm/cs/doc/90/4-10.ps.gz</a> 。有关的代码在这里 <a href="http://cm.bell-labs.com/netlib/fp/dtoa.c.gz">http://cm.bell-labs.com/netlib/fp/dtoa.c.gz</a> 还有 <a href="http://cm.bell-labs.com/netlib/fp/g_fmt.c.gz">http://cm.bell-labs.com/netlib/fp/g_fmt.c.gz</a> 。这些都可在众多的 netlib 镜像站点上找到。</p>
</div>


<h4><b><code>ToObject</code></b></h4>

<p>ToObject 运算符根据下表将其参数转换为对象类型的值：</p>

<div>
<p>输入类型
  <br />结果</p>

<p>未定义
  <br />抛出 <b>TypeError</b> 异常。</p>

<p>空值
  <br />抛出 <b>TypeError</b> 异常。</p>

<p>布尔值
  <br />创建一个新的 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=X15.6&action=edit&redlink=1">Boolean</a> 对象，其 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Primitivevalue&action=edit&redlink=1">[[PrimitiveValue]]</a> 属性被设为该布尔值的值。</p>

<p>数值
  <br />创建一个新的 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=X15.7&action=edit&redlink=1">Number</a> 对象，其 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Primitivevalue&action=edit&redlink=1">[[PrimitiveValue]]</a> 属性被设为该布尔值的值。</p>

<p>字符串
  <br />创建一个新的 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=X15.8&action=edit&redlink=1">String</a> 对象，其 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Primitivevalue&action=edit&redlink=1">[[PrimitiveValue]]</a> 属性被设为该布尔值的值。</p>

<p>对象
  <br />结果是输入的参数（不转换）。</p>

</div>

<h4>CheckObjectCoercible</h4>

<p>根据表 15 定义，抽象操作 CheckObjectCoercible 在其参数无法用 ToObject 转换成对象的情况下抛出一个异常：</p>

<div>
<p>表 15 -- CheckObjectCoercible 结果</p>

<p>输入类型
  <br />结果</p>

<p>未定义
  <br />抛出一个 <b>TypeError</b> 异常</p>

<p>空值
  <br />抛出一个 <b>TypeError</b> 异常</p>

<p>布尔值
  <br />返回</p>

<p>数值
  <br />返回</p>

<p>字符串
  <br />返回</p>

<p>对象
  <br />返回</p>

</div>

<h4>IsCallable</h4>

<p>根据表 16，抽象操作 IsCallable 确定其必须是 ECMAScript 语言值的参数是否是一个可调用对象：</p>

<div>
<p>表 16 -- CheckObjectCoercible 结果</p>

<p>输入类型
  <br />结果</p>

<p>未定义
  <br />返回 false。</p>

<p>空值
  <br />返回 false。</p>

<p>布尔值
  <br />返回 false。</p>

<p>数值
  <br />返回 false。</p>

<p>字符串
  <br />返回 false。</p>

<p>对象
  <br />如果参数对象包含一个 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Call&action=edit&redlink=1">Call</a> 内部方法，则返回 true，否则返回 false</p>

</div>

<h4><b><code>SameValue</code></b> 算法</h4>

<p>内部严格比较操作 SameValue(<var>x</var>,<var>y</var>)，<var>x</var> 和 <var>y</var> 为 ECMAScript 语言中的值，需要产出 <b>true</b> 或 <b>false</b><img border="0" alt="" src="http://www.w3.org/html/ig/zh/wiki/images/c/cc/Note.png" width="16" height="16" />。比较过程如下：</p>

<ol>
  <li>如果 <code><a href="http://www.w3.org/html/ig/zh/wiki/ES5/类型转换与测试#type">Type(<var>x</var>)</a></code> 与 <code><a href="http://www.w3.org/html/ig/zh/wiki/ES5/类型转换与测试#type">Type(<var>y</var>)</a></code> 的结果不一致，返回 <b>false</b>，否则 </li>

  <li>如果 <code><a href="http://www.w3.org/html/ig/zh/wiki/ES5/类型转换与测试#type">Type(<var>x</var>)</a></code> 结果为 Undefined，返回 <b>true</b></li>

  <li>如果 <code><a href="http://www.w3.org/html/ig/zh/wiki/ES5/类型转换与测试#type">Type(<var>x</var>)</a></code> 结果为 Null，返回 <b>true</b></li>

  <li>如果 <code><a href="http://www.w3.org/html/ig/zh/wiki/ES5/类型转换与测试#type">Type(<var>x</var>)</a></code> 结果为 Number，则 

    <ol>
      <li>如果 <var>x</var> 为 <b>NaN</b>，且 <var>y</var> 也为 <b>NaN</b>，返回 <b>true</b></li>

      <li>如果 <var>x</var> 为 <b>+0</b>，<var>y</var> 为 <b>-0</b>，返回 <b>false</b></li>

      <li>如果 <var>x</var> 为 <b>-0</b>，<var>y</var> 为 <b>+0</b>，返回 <b>false</b></li>

      <li>如果 <var>x</var> 与 <var>y</var> 为同一个数字，返回 <b>true</b></li>

      <li>返回 <b>false</b></li>
    </ol>
  </li>

  <li>如果 <code><a href="http://www.w3.org/html/ig/zh/wiki/ES5/类型转换与测试#type">Type(<var>x</var>)</a></code> 结果为 String，如果 <var>x</var> 与 <var>y</var> 为完全相同的字符序列（相同的长度和相同的字符对应相同的位置），返回 <b>true</b>，否则，返回 <b>false</b></li>

  <li>如果 <code><a href="http://www.w3.org/html/ig/zh/wiki/ES5/类型转换与测试#type">Type(<var>x</var>)</a></code> 结果为 Boolean，如果 <var>x</var> 与 <var>y</var> 都为 <b>true</b> 或 <b>false</b>，则返回 <b>true</b>，否则，返回 <b>false</b></li>

  <li>如果 <var>x</var> 和 <var>y</var> 引用到同一个 Object 对象，返回 <b>true</b>，否则，返回 <b>false</b></li>
</ol>

<h4>可执行代码与执行环境</h4>

<h4>可执行代码类型</h4>

<p>一共有 3 种 ECMA 脚本可执行代码：</p>

<ul>
  <li><i>全局代码 </i>是指被作为 ECMA 脚本 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#x14">程序 </a>处理的源代码文本。一个特定 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#x14">程序 </a>的全局代码不包括作为 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#x13">函数体 </a>被解析的源代码文本。 </li>

  <li><i>Eval 代码 </i>是指提供给 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#x15.1.2.1">eval</a> 内置函数的源代码文本。更精确地说，如果传递给 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#x15.1.2.1">eval</a> 内置函数的参数为一个字符串，该字符串将被作为 ECMA 脚本 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#x14">程序 </a>进行处理。在特定的一次对 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#15.1.2.1">eval</a> 的调用过程中，eval 代码作为该 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#14">程序 </a>的 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#global-code">#global-code</a> 部分。 </li>

  <li><i>函数代码 </i>是指作为 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#x13">函数体 </a>被解析的源代码文本。一个 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#x13">函数体 </a>的 <i>函数代码 </i>不包括作为其嵌套函数的 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#x13">函数体 </a>被解析的源代码文本。<i> 函数代码 </i>同时还特指 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#x15.3.2">以构造器方式调用 Function 内置对象 </a>时所提供的源代码文本。更精确地说，调用 <b>Function</b> 构造器时传递的最后一个参数将被转换为字符串并作为 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#x13">函数体 </a>使用。如果调用 <b>Function</b> 构造器时，传递了一个以上的参数，除最后一个参数以外的其他参数都将转换为字符串，并以逗号作为分隔符连接在一起成为一个字符串，该字符串被解析为 <i>形参列表 </i>供由最后一个参数定义的 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#x13">函数体 </a>使用。初始化 <b>Function</b> 对象时所提供的函数代码，并不包括作为其嵌套函数的 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#x13">函数体 </a>被解析的源代码文本。</li>
</ul>


<h6>严格模式下的代码</h6>

<p>一个 ECMA 脚本程序的语法单元可以使用非严格或严格模式下的语法及语义进行处理。当使用严格模式进行处理时，以上三种代码将被称为严格全局代码、严格 eval 代码和严格函数代码。当符合以下条件时，代码将被解析为严格模式下的代码：</p>

<ul>
  <li>当 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#global-code">全局代码 </a>以指令序言开始，且该指令序言包含一个使用严格模式的指令序言（参考 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#x14.1">14.1 章 </a>）时，即为严格全局代码。 </li>

  <li>当 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#eval-code">全局代码 </a>以指令序言开始，且该指令序言包含一个使用严格模式的指令序言时；或者在 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#x10.1.1">严格模式下的代码 </a>中通过直接调用 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#x15.1.2.1">eval 函数 </a>（参考 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#x15.1.2.1.1">15.1.2.1.1 章 </a>）时，即为严格 eval 代码。 </li>

  <li>当一个 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#x13">函数声明 </a>、<a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#x13"> 函数表达式 </a>或 <i>函数赋值 </i>访问器处在一段 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#x10.1.1">严格模式下的代码 </a>中，或其函数代码以指令序言开始，且该指令序言包含一个使用严格模式的指令序言时，该<a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#function-code">函数代码 </a>即为严格函数代码。 </li>

  <li>当调用内置的 Function 构造器时，如果最后一个参数所表达的字符串在作为 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#x13">函数体 </a>处理时以指令序言开始，且该指令序言包含一个使用严格模式的指令序言，则该 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#function-code">函数代码</a>即为严格函数代码。</li>
</ul>


<h4>词法环境</h4>

<p><i>词法环境 </i>是一个用于定义特定变量和函数标识符在 ECMAScript 代码的词法嵌套结构上关联关系的规范类型。一个词法环境由一个环境记录项和可能为空的外部词法环境引用构成。通常词法环境会与特定的 ECMAScript 代码诸如 FunctionDeclaration,WithStatement 或者 TryStatement 的 Catch 块这样的语法结构相联系，且类似代码每次执行都会有一个新的语法环境被创建出来。</p>

<p>环境记录项记录了在它的关联词法环境域内创建的标识符绑定情形。</p>

<p>外部词法环境引用用于表示词法环境的逻辑嵌套关系模型。（内部）词法环境的外部引用是逻辑上包含内部词法环境的词法环境。外部词法环境自然也可能有多个内部词法环境。例如，如果一个 FunctionDeclaration 包含两个嵌套的 FunctionDeclaration，那么每个内嵌函数的词法环境都是外部函数本次执行所产生的词法环境。</p>

<p>词法环境和环境记录项是纯粹的规范机制，而不需要 ECMAScript 的实现保持一致。ECMAScript 程序不可能直接访问或者更改这些值。</p>



<h5>环境记录项</h5>

<p>在本标准中，共有 2 类环境记录项：<i> 声明式环境记录项 </i>和 <i>对象式环境记录项 </i>。声明式环境记录项用于定义那些将 <b>标识符 </b>与语言值直接绑定的 ECMA 脚本语法元素，例如 <i>函数定义 </i>，<i> 变量定义 </i>以及 <i>Catch</i> 语句。对象式环境记录项用于定义那些将 <b>标识符 </b>与具体对象的属性绑定的 ECMA 脚本元素，例如 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#x14">程序 </a>以及 <i>With 表达式 </i>。</p>

<p>出于标准规范的目的，可以将环境记录项理解为面向对象中的一个简单继承结构，其中环境记录项是一个抽象类花前月下有 2 个具体实现类，分别为声明式环境记录项和对象式环境记录项。抽象类包含了表 17 所描述的抽象方法定义，针对每一个具体实现类，每个抽象方法都有不同的具体算法。</p>

<div>
<p><b>表 17 - 环境记录项的抽象方法</b></p>


<p>方法
  <br />作用</p>

<p>HasBinding(N)
  <br />判断环境记录项是否包含对某个标识符的绑定。如果包含该绑定则返回 <b>true</b>，反之返回 <b>false</b>。其中字符串 <i>N</i> 是标识符文本。</p>

<p>CreateMutableBinding(N, D)
  <br />在环境记录项中创建一个新的可变绑定。其中字符串 <i>N</i> 指定绑定名称。如果可选参数 <i>D</i> 的值为 <b>true</b>，则该绑定在后续操作中可以被删除。</p>

<p>SetMutableBinding(N,V, S)
  <br />在环境记录项中设置一个已经存在的绑定的值。其中字符串 <i>N</i> 指定绑定名称。<i>V</i> 用于指定绑定的值，可以是任何 ECMA 脚本 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#language-type">语言的类型 </a>。<i>S</i> 是一个布尔类型的标记，当 <i>S</i> 为 <b>true</b> 并且该绑定不允许赋值时，则抛出一个 <b>TypeError</b> 异常。<i>S</i> 用于指定是否为严格模式。</p>

<p>GetBindingValue(N,S)
  <br />返回环境记录项中一个已经存在的绑定的值。其中字符串 <i>N</i> 指定绑定的名称。<i>S</i> 用于指定是否为严格模式。如果 <i>S</i> 的值为 <b>true</b> 并且该绑定不存在或未初始化，则抛出一个 <b>ReferenceError</b> 异常。</p>

<p>DeleteBinding(N)
  <br />从环境记录项中删除一个绑定。其中字符串 <i>N</i> 指定绑定的名称。如果 <i>N</i> 指定的绑定存在，将其删除并返回 <b>true</b>。如果绑定存在但无法删除则返回<b>false</b>。如果绑定不存在则返回 <b>true</b>。</p>

<p>ImplicitThisValue()
  <br />当从该环境记录项的绑定中获取一个函数对象并且调用时，该方法返回该函数对象使用的 <b>this</b> 对象的值。</p>
</div>


<h6>声明式环境记录项</h6>

<p>每个声明式环境记录项都与一个包含变量和（或）函数声明的 ECMA 脚本的程序作用域相关联。声明式环境记录项用于绑定作用域内定义的一系列标识符。</p>

<p>除了所有环境记录项都支持的可变绑定外，声明式环境记录项还提供不可变绑定。在不可变绑定中，一个标识符与它的值之间的关联关系建立之后，就无法改变。创建和初始化不可变绑定是两个独立的过程，因此类似的绑定可以处在已初始化阶段或者未初始化阶段。除了环境记录项定义的抽象方法外，声明式环境记录项还支持表 18 中列出的方法：</p>

<div>
<p><b>表 18 - 声明式环境记录项的额外方法</b></p>

<p>方法
  <br />作用</p>

<p><a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#x10.2.1.1.7">CreateImmutableBinding</a>(N)

  <br />在环境记录项中创建一个未初始化的 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#immutable-binding">不可变绑定 </a>。其中字符串 <i>N</i> 指定绑定名称。</p>

<p><a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#x10.2.1.1.8">InitializeImmutableBinding</a>(N,V)

  <br />在环境记录项中设置一个已经创建但未初始化的 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#immutable-binding">不可变绑定 </a>的值。其中字符串 <i>N</i> 指定绑定名称。<i>V</i> 用于指定绑定的值，可以是任何 ECMA 脚本<a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#language-type">语言的类型 </a>。</p>

</div>

<p>环境记录项定义的方法的具体行为将由以下算法给予描述。</p>



<h6>HasBinding (N)</h6>

<p>声明式环境记录项的 HasBinding 具体方法用于简单地判断作为参数的标识符是否是当前对象绑定的标识符之一：</p>

<ol>
  <li>令 <i>envRec</i> 为函数调用时对应的声明式环境记录项。 </li>

  <li>如果 <i>envRec</i> 有一个名称为 <i>N</i> 的绑定，返回 <b>true</b>。 </li>

  <li>如果没有该绑定，返回 <b>false</b>。</li>
</ol>


<h6>CreateMutableBinding (N, D)</h6>

<p>声明式环境记录项的 CreateMutableBinding 具体方法会创建一个名称为 <i>N</i> 的绑定，并初始化其值为 <b>undefined</b>。方法调用时，当前环境记录项中不能存在 <i>N</i> 的绑定。如果调用时提供了布尔类型的参数 <i>D</i> 且其值为 <b>true</b>，则新建的绑定被标记为可删除。</p>

<ol>
  <li>令 <i>envRec</i> 为函数调用时对应的声明式环境记录项。 </li>

  <li>执行断言：<i>envRec</i> 没有 <i>N</i> 的绑定。 </li>

  <li>在 <i>envRec</i> 中为 <i>N</i> 创建一个可变绑定，并将绑定的值设置为 <b>undefined</b>。如果 <i>D</i> 为 <b>true</b> 则新创建的绑定可在后续操作中通过调用 DeleteBinding 删除。</li>
</ol>


<h6>SetMutableBinding (N,V,S)</h6>

<p>声明式环境记录项的 SetMutableBinding 具体方法尝试将当前名称为参数 <i>N</i> 的绑定的值修改为参数 <i>V</i> 指定的值。方法调用时，必须存在 <i>N</i> 的绑定。如果该绑定为不可变绑定，并且 <i>S</i> 的值为 <b>true</b>，则抛出一个 <b>TypeError</b> 异常。</p>

<ol>
  <li>令 <i>envRec</i> 为函数调用时对应的声明式环境记录项。 </li>

  <li>执行断言：<i>envRec</i> 必须有 <i>N</i> 的绑定。 </li>

  <li>如果 <i>envRec</i> 中 <i>N</i> 的绑定为可变绑定，则将其值修改为 <i>V</i>。 </li>

  <li>否则该操作会尝试修改一个不可变绑定的值，因此如果 <i>S</i> 的值为 <b>true</b>，则抛出一个 <b>TypeError</b> 异常。</li>
</ol>


<h6>GetBindingValue (N,S)</h6>

<p>声明式环境记录项的 GetBindingValue 具体方法简单地返回名称为参数 <i>N</i> 的绑定的值。方法调用时，该绑定必须存在。如果 <i>S</i> 的值为 <b>true</b> 且该绑定是一个未初始化的不可变绑定，则抛出一个 <b>ReferenceError</b> 异常。</p>

<ol>
  <li>令 <i>envRec</i> 为函数调用时对应的声明式环境记录项。 </li>

  <li>执行断言：<i>envRec</i> 必须有 <i>N</i> 的绑定。 </li>

  <li>如果 <i>envRec</i> 中 <i>N</i> 的绑定是一个未初始化的不可变绑定，则： 

    <ol>
      <li>如果 <i>S</i> 为 <b>false</b>，返回 <b>undefined</b>，否则抛出一个 <b>ReferenceError</b> 异常。</li>
    </ol>
  </li>

  <li>否则返回 <i>envRec</i> 中与 <i>N</i> 绑定的值。</li>
</ol>


<h6>DeleteBinding (N)</h6>

<p>声明式环境记录项的 DeleteBinding 具体方法只能删除显示指定可被删除的那些绑定。</p>

<ol>
  <li>令 <i>envRec</i> 为函数调用时对应的声明式环境记录项。 </li>

  <li>如果 <i>envRec</i> 不包含名称为 <i>N</i> 的绑定，返回 <b>true</b>。 </li>

  <li>如果 <i>envRec</i> 中 <i>N</i> 的绑定不能删除，返回 <b>false</b>。 </li>

  <li>移除 <i>envRec</i> 中 <i>N</i> 的绑定。 </li>

  <li>返回 <b>true</b>。</li>
</ol>


<h6>ImplicitThisValue()</h6>

<p>声明式环境记录项永远将 <b>undefined</b> 作为其 ImplicitThisValue 返回。</p>

<ol>
  <li>返回 <b>undefined</b>。</li>
</ol>


<h6>CreateImmutableBinding (N)</h6>

<p>声明式环境记录项的 CreateImmutableBinding 具体方法会创建一个不可变绑定，其名称为 <i>N</i> 且初始化其值为 <b>undefined</b>。调用方法时，该环境记录项中不得存在 <i>N</i> 的绑定。</p>

<ol>
  <li>令 <i>envRec</i> 为函数调用时对应的声明式环境记录项。 </li>

  <li>执行断言：<i>envRec</i> 不存在 <i>N</i> 的绑定。 </li>

  <li>在 <i>envRec</i> 中为 <i>N</i> 创建一个不可变绑定，并记录为未初始化。</li>
</ol>


<h6>InitializeImmutableBinding (N,V)</h6>

<p>声明式环境记录项的 InitializeImmutableBinding 具体方法用于将当前名称为参数 <i>N</i> 的绑定的值修改为参数 <i>V</i> 指定的值。方法调用时，必须存在 <i>N</i> 对应的未初始化的不可变绑定。</p>

<ol>
  <li>令 <i>envRec</i> 为函数调用时对应的声明式环境记录项。 </li>

  <li>执行断言：<i>envRec</i> 存在一个与 <i>N</i> 对应的未初始化的不可变绑定。 </li>

  <li>在 <i>envRec</i> 中将 <i>N</i> 的绑定的值设置为 <i>V</i>。 </li>

  <li>在 <i>envRec</i> 中将 <i>N</i> 的不可变绑定记录为已初始化。</li>
</ol>


<h6>对象式环境记录项</h6>

<p>每一个对象式环境记录项都有一个关联的对象，这个对象被称作 <i>绑定对象 </i>。对象式环境记录项直接将一系列标识符与其绑定对象的属性名称建立一一对应关系。不符合<i>IdentifierName</i> 的属性名不会作为绑定的标识符使用。无论是对象自身的，还是继承的属性都会作为绑定，无论该属性的 [[Enumerable]] 特性的值是什么。由于对象的属性可以动态的增减，因此对象式环境记录项所绑定的标识符集合也会隐匿地变化，这是增减绑定对象的属性而产生的副作用。通过以上描述的副作用而建立的绑定，均被视为可变绑定，即使该绑定对应的属性的 Writable 特性的值为 <b>false</b>。对象式环境记录项没有不可变绑定。</p>

<p>对象式环境记录项可以通过配置的方式，将其绑定对象合为函数调用时的隐式 this 对象的值。这一功能用于规范 With 表达式（<a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#x12.10">12.10 章 </a>）引入的绑定行为。该行为通过对象式环境记录项中布尔类型的 <i>provideThis</i> 值控制，默认情况下，<i>provideThis</i> 的值为 <b>false</b>。</p>

<p>环境记录项定义的方法的具体行为将由以下算法给予描述。</p>



<h6>HasBinding(N)</h6>

<p>对象式环境记录项的 HasBinding 具体方法判断其关联的绑定对象是否有名为 <i>N</i> 的属性：</p>

<ol>
  <li>令 <i>envRec</i> 为函数调用时对应的声明式环境记录项。 </li>

  <li>令 <i>bindings</i> 为 <i>envRec</i> 的绑定对象。 </li>

  <li>以 <i>N</i> 为属性名，调用 <i>bindings</i> 的 [[HasProperty]] 内部方法，并返回调用的结果。</li>
</ol>


<h6>CreateMutableBinding (N, D)</h6>

<p>对象式环境记录项的 CreateMutableBinding 具体方法会在其关联的绑定对象上创建一个名称为 <i>N</i> 的属性，并初始化其值为 <b>undefined</b>。调用方法时，绑定对象不得包含名称为 <i>N</i>的属性。如果调用方法时提供了布尔类型的参数 <i>D</i> 且其值为 <b>true</b>，则设置新创建的属性的 [[Configurable]] 特性的值为 <b>true</b>，否则设置为 <b>false</b>。</p>

<ol>
  <li>令 <i>envRec</i> 为函数调用时对应的声明式环境记录项。 </li>

  <li>令 <i>bindings</i> 为 <i>envRec</i> 的绑定对象。 </li>

  <li>执行断言：以 <i>N</i> 为属性名，调用 <i>bindings</i> 的 [[HasProperty]] 内部方法，调用的结果为 <b>false</b>。 </li>

  <li>如果 <i>D</i> 的值为 <b>true</b>，则令 <i>configValue</i> 的值为 <b>true</b>，否则令 <i>configValue</i> 的值为 <b>false</b>。 </li>

  <li>以 <i>N</i>、属性描述符 {[[Value]]:<b>undefined</b>, [[Writable]]: <b>true</b>, [[Enumerable]]: <b>true</b> , [[Configurable]]: <i>configValue</i>} 和布尔值 <b>true</b> 为参数，调用 <i>bindings</i> 的 [[DefineOwnProperty]] 内部方法。</li>
</ol>


<h6>SetMutableBinding (N,V,S)</h6>

<p>对象式环境记录项的 SetMutableBinding 具体方法会尝试设置其关联的绑定对象中名为 <i>N</i> 的属性的值为 <i>V</i>。方法调用时，绑定对象中应当存在该属性，如果该属性不存在或属性不可写，则根据 <i>S</i> 参数的值来执行错误处理。</p>

<ol>
  <li>令 <i>envRec</i> 为函数调用时对应的声明式环境记录项。 </li>

  <li>令 <i>bindings</i> 为 <i>envRec</i> 的绑定对象 </li>

  <li>以 <i>N</i>、<i>V</i> 和 <i>S</i> 为参数，调用 <i>bindings</i> 的 [[Put]] 内部方法。</li>
</ol>


<h6>GetBindingValue(N,S)</h6>

<p>对象式环境记录项的 GetBindingValue 具体方法返回其关联的绑定对象中名为 <i>N</i> 的属性的值。方法调用时，绑定对象中应当存在该属性，如果该属性不存在，则方法的返回值由 <i>S</i>参数决定：</p>

<ol>
  <li>令 <i>envRec</i> 为函数调用时对应的声明式环境记录项。 </li>

  <li>令 <i>bindings</i> 为 <i>envRec</i> 的绑定对象 </li>

  <li>以 <i>N</i> 为属性名，调用 <i>bindings</i> 的 [[HasProperty]] 内部方法，并令 <i>value</i> 为调用的结果。 </li>

  <li>如果 <i>value</i> 的值为 <b>false</b>，则： 

    <ol>
      <li>如果 <i>S</i> 的值为 <b>false</b>，则返回 <b>undefined</b>，否则抛出一个 <b>ReferenceError</b> 异常。</li>
    </ol>
  </li>

  <li>以 <i>N</i> 为参数，调用 <i>bindings</i> 的 [[Get]] 内部方法，并返回调用的结果。</li>
</ol>


<h6>DeleteBinding (N)</h6>

<p>对象式环境记录项的 DeleteBinding 具体方法只能用于删除其关联的绑定对象上 [[Configurable]] 特性的值为 <b>true</b> 的属性所对应的绑定。</p>

<ol>
  <li>令 <i>envRec</i> 为函数调用时对应的声明式环境记录项。 </li>

  <li>令 <i>bindings</i> 为 <i>envRec</i> 的绑定对象 </li>

  <li>以 <i>N</i> 和布尔值 <b>false</b> 为参数，调用 <i>bindings</i> 的 [[Delete]] 内部方法。</li>
</ol>


<h6>ImplicitThisValue()</h6>

<p>对象式环境记录项的 ImplicitThisValue 通常返回 <b>undefined</b>，除非其 <i>provideThis</i> 标识的值为 <b>true</b>。</p>

<ol>
  <li>令 <i>envRec</i> 为函数调用时对应的声明式环境记录项。 </li>

  <li>如果 <i>envRec</i> 的 <i>provideThis</i> 标识的值为 <b>true</b>，返回 <i>envRec</i> 的绑定对象。 </li>

  <li>否则返回 <b>undefined</b>。</li>
</ol>


<h5>词法环境的运算</h5>

<p>在本标准中，以下抽象运算将被用于操作环境记录项：</p>



<h6>GetIdentifierReference (lex, name, strict)</h6>

<p>当调用 GetIdentifierReference 抽象运算时，需要指定一个 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#x10.2">词法环境 </a><i>lex</i>，一个标识符字符串 <i>name</i> 以及一个布尔型标识 <i>strict</i>。<i>lex</i> 的值可以为 <b>null</b>。当调用该运算时，按以下步骤进行：</p>

<ol>
  <li>如果 <i>lex</i> 的值为 <b>null</b>，则： 

    <ol>
      <li>返回一个类型为 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#x8.7">引用 </a>的对象，其基值为 <b>undefined</b>，引用的名称为 <i>name</i>，严格模式标识的值为 <i>strict</i>。</li>
    </ol>
  </li>

  <li>令 <i>envRec</i> 为 <i>lex</i> 的环境数据。 </li>

  <li>以 <i>name</i> 为参数 <i>N</i>，调用 <i>envRec</i> 的 HasBinding(<i>N</i>) 具体方法，并令 <i>exists</i> 为调用的结果。 </li>

  <li>如果 <i>exists</i> 为 <b>true</b>，则： 

    <ol>
      <li>返回一个类型为 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#x8.7">引用 </a>的对象，其基值为 <i>envRec</i>，引用的名称为 <i>name</i>，严格模式标识的值为 <i>strict</i>。</li>
    </ol>
  </li>

  <li>否则： 
    <ol>
      <li>令 <i>outer</i> 为 <i>lex</i> 的 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#outer-environment-reference">外部环境引用 </a>。 </li>

      <li>以 <i>outer</i>、<i>name</i> 和 <i>struct</i> 为参数，调用 GetIdentifierReference，并返回调用的结果。</li>
    </ol>
  </li>
</ol>


<h6>NewDeclarativeEnvironment (E)</h6>

<p>当调用 NewDeclarativeEnvironment 抽象运算时，需指定一个 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#x10.2">词法环境 </a><i>E</i>，其值可以为 <b>null</b>，此时按以下步骤进行：</p>

<ol>
  <li>令 <i>env</i> 为一个新建的 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#x10.2">词法环境 </a>。 </li>

  <li>令 <i>envRec</i> 为一个新建的 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#declarative-environment-record">声明式环境数据 </a>，该环境数据不包含任何绑定。 </li>

  <li>令 <i>env</i> 的环境数据为 <i>envRec</i>。 </li>

  <li>令 <i>env</i> 的外部词法环境引用至 <i>E</i>。 </li>

  <li>返回 <i>env</i>。</li>
</ol>


<h6>NewObjectEnvironment (O, E)</h6>

<p>当调用 NewObjectEnvironmentis 抽象运算时，需指定一个对象 <i>O</i> 及一个 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#x10.2">词法环境 </a><i>E</i>（其值可以为 <b>null</b>），此时按以下步骤进行：</p>

<ol>
  <li>令 <i>env</i> 为一个新建的 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#x10.2">词法环境 </a>。 </li>

  <li>令 <i>envRec</i> 为一个新建的 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#object-environment-record">对象环境数据 </a>，该环境数据包含 <i>O</i> 作为绑定对象。 </li>

  <li>令 <i>env</i> 的环境数据为 <i>envRec</i>。 </li>

  <li>令 <i>env</i> 的外部词法环境引用至 <i>E</i>。 </li>

  <li>返回 <i>env</i>。</li>
</ol>


<h5>全局环境</h5>

<p><i>全局环境 </i>是一个唯一的 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#x10.2">词法环境 </a>，它在任何 ECMA 脚本的代码执行前创建。全局环境的 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#x10.2.1">环境数据 </a>是一个 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#object-environment-record">#object-environment-record</a> 对象环境数据，该环境数据使用 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#x15.1">全局对象</a>（<a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#x15.1">15.1</a>）作为 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#x10.2.1.2">绑定对象 </a>。全局环境的 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#outer-environment-reference">外部环境引用 </a>为 <b>null</b>。</p>

<p>在 ECMA 脚本的代码执行过程中，可能会向 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#x15.1">全局对象 </a>添加额外的属性，也可能修改其初始属性的值。</p>



<h4>执行环境</h4>

<p>当控制器转入 ECMA 脚本的可执行代码时，控制器会进入一个执行环境。当前活动的多个执行环境在逻辑上形成一个栈结构。该逻辑栈的最顶层的执行环境称为当前运行的执行环境。任何时候，当控制器从当前运行的执行环境相关的可执行代码转入与该执行环境无关的可执行代码时，会创建一个新的执行环境。新建的这个执行环境会推入栈中，成为当前运行的执行环境。</p>

<p>执行环境包含所有用于追踪与其相关的代码的执行进度的状态。精确地说，每个执行环境包含如表 19 列出的组件。</p>
<div>
<p>表 19 — 执行环境的状态组件</p>

<p>组件
  <br />作用目的</p>

<p>词法环境
  <br />指定一个 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#x10.2">词法环境 </a>对象，用于解析该执行环境内的代码创建的标识符引用。</p>

<p>变量环境
  <br />指定一个 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#x10.2">词法环境 </a>对象，其环境数据用于保存由该执行环境内的代码通过 <i>变量表达式 </i>和 <i>函数表达式 </i>创建的绑定。</p>

<p>This 绑定
  <br />指定该执行环境内的 ECMA 脚本代码中 <b>this</b> 关键字所关联的值。</p></div>

<p>其中执行环境的词法环境和变量环境组件始终为 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#x10.2">词法环境 </a>对象。当创建一个执行环境时，其词法环境组件和变量环境组件最初是同一个值。在该执行环境相关联的代码的执行过程中，变量环境组件永远不变，而词法环境组件有可能改变。</p>

<p>在本标准中，通常情况下，只有正在运行的执行环境（执行环境栈里的最顶层对象）会被算法直接修改。因此当遇到“词法环境”，“变量环境”和“This 绑定”这三个术语时，指的是正在运行的执行环境的对应组件。</p>

<p>执行环境是一个纯粹的标准机制，并不代表任何 ECMA 脚本实现的工件。在 ECMA 脚本程序中是不可能访问到执行环境的。</p>



<h6>标识符解析</h6>

<p>标识符解析是指使用正在运行的执行环境中的词法环境，通过一个 <i>标识符 </i>获得其对应的绑定的过程。在 ECMA 脚本代码执行过程中，<i>PrimaryExpression</i> <b>:</b> <i>Identifier</i> 这一语法产生式将按以下算法进行解释执行：</p>

<ol>
  <li>令 <i>env</i> 为正在运行的执行环境的 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#x10.x">词法环境 </a>。 </li>

  <li>如果正在解释执行的语法产生式处在 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#x10.1.1">严格模式下的代码 </a>中，则仅 <i>strict</i> 的值为 <b>true</b>，否则令 <i>strict</i> 的值为 <b>false</b>。 </li>

  <li>以 <i>env</i>，<i>Identifier</i> 和 <i>strict</i> 为参数，调用 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#x10.2.2.1">GetIdentifierReference</a> 函数，并返回调用的结果。</li>
</ol>

<p>解释执行一个标识符得到的结果必定是 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#x8.7">引用 </a>类型的对象，且其引用名属性的值与 <i>Identifier</i> 字符串相等。</p>



<h4>建立执行环境</h4>

<p>解释执行 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#global-code">全局代码 </a>或使用 eval 函数（<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=X15.1.2.1&action=edit&redlink=1">15.1.2.1</a>）输入的代码会创建并进入一个新的执行环境。每次调用 ECMA 脚本代码定义的函数（<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=13.2.1&action=edit&redlink=1">13.2.1</a>）也会建立并进入一个新的执行环境，即便函数是自身递归调用的。每一次 return 都会退出一个执行环境。抛出异常也可退出一个或多个执行环境。</p>

<p>当控制流进入一个执行环境时，会设置该执行环境的 this 绑定，定义变量环境和初始词法环境，并执行定义绑定初始化过程（<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=10.5&action=edit&redlink=1">10.5</a>）。以上这些步骤的严格执行方式由进入的代码的类型决定。</p>



<h5>进入全局代码</h5>

<p>当控制流进入 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#global-code">全局代码 </a>的执行环境时，执行以下步骤：</p>

<ol>
  <li>按 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#initialize-global-context">10.4.1.1</a> 描述的方案，使用 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#global-code">全局代码 </a>初始化执行环境。 </li>

  <li>按 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=X10.5&action=edit&redlink=1">10.5</a> 描述的方案，使用 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#global-code">全局代码 </a>执行定义绑定初始化步骤。</li>
</ol>


<h6>10.4.1.1 初始化全局执行环境</h6>

<p>以下步骤描述 ECMA 脚本的全局执行环境 <i>C</i> 的创建过程：</p>

<ol>
  <li>将变量环境设置为 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=X10.2.3&action=edit&redlink=1">全局环境 </a>。 </li>

  <li>将词法环境设置为 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=X10.2.3&action=edit&redlink=1">全局环境 </a>。 </li>

  <li>将 this 绑定设置为 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=X15.1&action=edit&redlink=1">全局对象 </a>。</li>
</ol>


<h5>进入 eval 代码</h5>

<p>当控制流进入 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#eval-code">eval 代码 </a>的执行环境时，执行以下步骤：</p>

<ol>
  <li>如果没有调用环境，或者 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#eval-code">eval 代码 </a>并非通过直接调用（<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=15.1.2.1.1&action=edit&redlink=1">15.1.2.1.1</a>）eval 函数进行评估的，则 

    <ol>
      <li>按（<a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#initialize-global-context">10.4.1.1</a>）描述的初始化全局执行环境的方案，以 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#eval-code">eval 代码 </a>作为 <i>C</i> 来初始化执行环境。</li>
    </ol>
  </li>

  <li>否则 
    <ol>
      <li>将 this 绑定设置为当前执行环境下的 this 绑定。 </li>

      <li>将词法环境设置为当前执行环境下的 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=X10.2&action=edit&redlink=1">词法环境 </a>。 </li>

      <li>将变量环境设置为当前执行环境下的变量环境。</li>
    </ol>
  </li>

  <li>如果 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#eval-code">eval 代码 </a>是 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=X10.1.1&action=edit&redlink=1">严格模式下的代码 </a>，则 

    <ol>
      <li>令 <i>strictVarEnv</i> 为以词法环境为参数调用 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=X10.2.2.2&action=edit&redlink=1">NewDeclarativeEnvironment</a> 得到的结果。 </li>

      <li>设置词法环境为 <i>strictVarEnv</i>。 </li>

      <li>设置变量环境为 <i>strictVarEnv</i>。</li>
    </ol>
  </li>

  <li>按 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=X10.5&action=edit&redlink=1">10.5</a> 描述的方案，使用 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#eval-code">eval 代码 </a>执行定义绑定初始化步骤。</li>
</ol>


<h6>严格模式下的限制</h6>

<p>如果调用环境的代码或 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#eval-code">eval 代码 </a>是 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=X10.1.1&action=edit&redlink=1">严格模式下的代码 </a>，则 eval 代码不能在调用环境的变量环境中 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=X10.5&action=edit&redlink=1">初始化变量及函数绑定 </a>。与之相对的，变量及函数绑定将在一个新的环境变量中被初始化，该环境变量仅可被 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#eval-code">eval 代码 </a>访问。</p>



<h5>进入函数代码</h5>

<p>当控制流根据一个函数对象 <i>F</i>、调用者提供的 <i>thisArg</i> 以及调用者提供的 <i>argumentList</i>，进入 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#function-code">函数代码 </a>的执行环境时，执行以下步骤：</p>

<ol>
  <li>如果 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#function-code">函数代码 </a>是 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=X10.1.1&action=edit&redlink=1">严格模式下的代码 </a>，设 this 绑定为 <i>thisArg</i>。 </li>

  <li>否则如果 <i>thisArg</i> 是 <b>null</b> 或 <b>undefined</b>，则设 this 绑定为 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=X15.1&action=edit&redlink=1">全局对象 </a>。 </li>

  <li>否则如果 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#type">Type</a>(<i>thisArg</i>) 的结果不为 Object，则设 this 绑定为 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#to-object">ToObject</a>(<i>thisArg</i>)。 </li>

  <li>否则设 this 绑定为 <i>thisArg</i>。 </li>

  <li>以 <i>F</i> 的 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Scope&action=edit&redlink=1">[[Scope]]</a> 内部属性为参数调用 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#10.2.2.2">NewDeclarativeEnvironment</a>，并令 <i>localEnv</i> 为调用的结果。 </li>

  <li>设词法环境为 <i>localEnv</i>。 </li>

  <li>设变量环境为 <i>localEnv</i>。 </li>

  <li>令 <i>code</i> 为 <i>F</i> 的 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Code&action=edit&redlink=1">[[Code]]</a> 内部属性的值。 </li>

  <li>按 [10.5](#10.5) 描述的方案，使用 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#function-code">函数代码 </a><i>code</i> 和 <i>argumentList</i> 执行定义绑定初始化步骤。</li>
</ol>


<h4>定义绑定初始化</h4>

<p>每个执行环境都有一个关联的变量环境。当在一个执行环境下评估一段 ECMA 脚本时，变量和函数定义会以绑定的形式添加到这个变量环境的 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#x10.2.1">环境记录 </a>中。对于函数 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#function-code">函数代码</a>，参数也同样会以绑定的形式添加到这个变量环境的 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#x10.2.1">环境记录 </a>中。</p>

<p>选择使用哪一个、哪一类型的 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#x10.2.1">环境记录 </a>来绑定定义，是由执行环境下执行的 ECMA 脚本的类型决定的，而其它部分的逻辑是相同的。当进入一个执行环境时，会按以下步骤在变量环境上创建绑定，其中使用到调用者提供的代码设为 <i>code</i>，如果执行的是 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#function-code">函数代码 </a>，则设 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#x8.8">参数列表 </a>为 <i>args</i>：</p>

<ol>
  <li>令 <i>env</i> 为当前运行的执行环境的环境变量的 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#x10.2.1">环境记录 </a>。 </li>

  <li>如果 <i>code</i> 是 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#eval-code">eval 代码 </a>，则令 <i>configurableBindings</i> 为 <b>true</b>，否则令 <i>configurableBindings</i> 为 <b>false</b>。 </li>

  <li>如果代码是 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#x10.1.1">严格模式下的代码 </a>，则令 <i>strict</i> 为 <b>true</b>，否则令 <i>strict</i> 为 <b>false</b>。 </li>

  <li>如果代码为 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#function-code">函数代码 </a>，则： 

    <ol>
      <li>令 <i>func</i> 为通过 [[Call]] 内部属性初始化 <i>code</i> 的执行的函数对象。令 <i>names</i> 为 <i>func</i> 的 [[FormalParameters]] 内部属性。 </li>

      <li>令 <i>argCount</i> 为 <i>args</i> 中元素的数量。 </li>

      <li>令 <i>n</i> 为数字类型，其值为 0。 </li>

      <li>按列表顺序遍历 <i>names</i>，对于每一个字符串 <i>argName</i>： 

        <ol>
          <li>令 <i>n</i> 的值为 <i>n</i> 当前值加 1。 </li>

          <li>如果 <i>n</i> 大于 <i>argCount</i>，则令 <i>v</i> 为 <b>undefined</b>，否则令 <i>v</i> 为 <i>args</i> 中的第 <i>n</i> 个元素。 </li>

          <li>以 <i>argName</i> 为参数，调用 <i>env</i> 的 HasBinding 具体方法，并令 <i>argAlreadyDeclared</i> 为调用的结果。 </li>

          <li>如果 <i>argAlreadyDeclared</i> 的值为 <b>false</b>，以 <i>argName</i> 为参数调用 <i>env</i> 的 CreateMutableBinding 具体方法。 </li>

          <li>以 <i>argName</i>、<i>v</i> 和 <i>strict</i> 为参数，调用 <i>env</i> 的 SetMutableBinding 具体方法。</li>
        </ol>
      </li>
    </ol>
  </li>

  <li>按源码顺序遍历 <i>code</i>，对于每一个 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#x13">FunctionDeclaration 表达式 </a><i>f</i>： 

    <ol>
      <li>令 <i>fn</i> 为 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#x13">FunctionDeclaration 表达式 </a><i>f</i> 中的 <i>标识符 </i>。 </li>

      <li>按 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#x13">第 13 章 </a>中所述的步骤初始化 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#x13">FunctionDeclaration 表达式 </a>，并令 <i>fo</i> 为初始化的结果。 </li>

      <li>以 <i>fn</i> 为参数，调用 <i>env</i> 的 HasBinding 具体方法，并令 <i>argAlreadyDeclared</i> 为调用的结果。 </li>

      <li>如果 <i>argAlreadyDeclared</i> 的值为 <b>false</b>，以 <i>fn</i> 和 <i>configurableBindings</i> 为参数调用 <i>env</i> 的 CreateMutableBinding 具体方法。 </li>

      <li>否则如果 <i>env</i> 是全局环境的 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#x10.2.1">环境记录 </a>对象，则： 

        <ol>
          <li>令 <i>go</i> 为全局对象。 </li>

          <li>以 <i>fn</i> 为参数，调用 <i>go</i> 和 [[GetProperty]] 内部方法，并令 <i>existingProp</i> 为调用的结果。 </li>

          <li>如果 <i>existingProp</i>.[[Configurable]] 的值为 <b>true</b>，则： 

            <ol>
              <li>以 <i>fn</i>、由 {[[Value]]: <b>undefined</b>, [[Writable]]: <b>true</b>, [[Enumerable]]: <b>true</b>, [[Configurable]]: <i>configurableBindings</i> } 组成的 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#x8.10">属性描述符 </a>和 <b>true</b> 为参数，调用<i>go</i> 的 [[DefineOwnProperty]] 内部方法。</li>
            </ol>
          </li>

          <li>否则如果 IsAccessorDescrptor(<i>existingProp</i>) 的结果为真，或 <i>existingProp</i> 的特性中没有 {[[Writable]]: true, [[Enumerable]]: true}，则： 

            <ol>
              <li>抛出一个 TypeError 异常。</li>
            </ol>
          </li>

          <li>以 <i>fn</i>、<i>fo</i> 和 <i>strict</i> 为参数，调用 <i>env</i> 的 SetMutableBinding 具体方法。</li>
        </ol>
      </li>
    </ol>
  </li>

  <li>以 <b>arguments</b> 为参数，调用 <i>env</i> 的 HasBinding 具体方法，并令 <i>argumentsAlreadyDeclared</i> 为调用的结果。 </li>

  <li>如果 <i>code</i> 是 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#function-code">函数代码 </a>，并且 <i>argumentsAlreadyDeclared</i> 为 <b>false</b>，则： 

    <ol>
      <li>以 <i>fn</i>、<i>names</i>、<i>args</i>、<i>env</i> 和 <i>strict</i> 为参数，调用 CreateArgumentsObject 抽象运算函数，并令 <i>argsObj</i> 为调用的结果。 </li>

      <li>如果 <i>strict</i> 为 <b>true</b>，则： 

        <ol>
          <li>以字符串 <b>"arguments"</b> 为参数，调用 <i>env</i> 的 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#x10.2.1.1.7">CreateImmutableBinding</a> 具体方法。 </li>

          <li>以字符串 <b>"arguments"</b> 和 <i>argsObj</i> 为参数，调用 <i>env</i> 的 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/可执行代码与执行环境#x10.2.1.1.8">InitializeImmutableBinding</a> 具体函数。</li>
        </ol>
      </li>

      <li>否则： 
        <ol>
          <li>以字符串 <b>"arguments"</b> 为参数，调用 <i>env</i> 的 CreateMutableBinding 具体方法。 </li>

          <li>以字符串 <b>"arguments"</b>、<i>argsObj</i> 和 <b>false</b> 为参数，调用 <i>env</i> 的 SetMutableBinding 具体函数。</li>
        </ol>
      </li>
    </ol>
  </li>

  <li>按源码顺序遍历 <i>code</i>，对于每一个 <i>VariableDeclaration</i> 和 <i>VariableDeclarationNoIn</i> 表达式： 

    <ol>
      <li>令 <i>dn</i> 为 <i>d</i> 中的标识符。 </li>

      <li>以 <i>dn</i> 为参数，调用 <i>env</i> 的 HasBinding 具体方法，并令 <i>varAlreadyDeclared</i> 为调用的结果。 </li>

      <li>如果 <i>varAlreadyDeclared</i> 为 <b>false</b>，则： 

        <ol>
          <li>以 <i>dn</i> 和 <i>configurableBindings</i> 为参数，调用 <i>env</i> 的 CreateMutableBinding 具体方法。 </li>

          <li>以 <i>dn</i>、<b>undefined</b> 和 <i>strict</i> 为参数，调用 <i>env</i> 的 SetMutableBinding 具体方法。</li>
        </ol>
      </li>
    </ol>
  </li>
</ol>


<h4>Arguments 对象</h4>

<p>当控制器进入到函数代码的执行环境时，将创建一个 arguments 对象，除非它作为标识符 "arguments" 出现在该函数的形参列表中，或者是该函数代码内部的变量声明标识符或函数声明标识符。</p>

<p>Arguments 对象通过调用抽象方法 CreateArgumentsObject 创建，调用时将以下参数传入：<i>func, names, args, env, strict</i>。将要执行的函数对象作为 <i>func</i> 参数，将该函数的所有形参名加入一个 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=List&action=edit&redlink=1">List</a> 列表，作为 <i>names</i> 参数，将所有传给内部方法 [[Call]] 的实际参数，作为 <i>args</i> 参数，将该函数代码的环境变量作为 <i>env</i> 参数，将该函数代码是否为严格代码作为<i>strict</i> 参数。当 CreateArgumentsObject 调用时，按照以下步骤执行：</p>

<ol>
  <li>令 <i>len</i> 为参数 <i>args</i> 的元素个数 </li>

  <li>令 <i>obj</i> 为一个新建的 ECMAScript 对象 </li>

  <li>按照 8.12 章节中的规范去设定 <i>obj</i> 对象的所有内部方法 </li>

  <li>将 <i>obj</i> 对象的内部属性 [[Class]] 设置为 "Arguments" </li>

  <li>令 <i>Object</i> 为标准的内置对象的构造函数 (15.2.2) </li>

  <li>将 <i>obj</i> 对象的内部属性 [[Prototype]] 设置为标准的内置对象的原型对象 </li>

  <li>调用 <i>obj</i> 的内部方法 [[DefineOwnProperty]]，将 "length" 传递进去，属性描述符为：{[[Value]]: len, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true}，参数为 false </li>

  <li>令 <i>map</i> 为表达式 new Object() 创建的对象，就是名为 Object 的标准的内置构造函数 </li>

  <li>令 <i>mappedNames</i> 为一个空的 List 列表 </li>

  <li>令 <i>indx</i> = <i>len</i> - 1 </li>

  <li>当 <i>indx</i> >= 0 的时候，重复此过程： 

    <ol>
      <li>令 <i>val</i> 为 <i>args</i>（维度从 0 开始的 list 列表）的第 <i>indx</i> 维度所在的元素 </li>

      <li>调用 <i>obj</i> 的内部方法 [[DefineOwnProperty]]，将 ToString(<i>indx</i>) 传递进去，属性描述符为：{[[Value]]: val, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}，参数为 false </li>

      <li>如果 <i>indx</i> 小于 <i>names</i> 的元素个数，则 

        <ol>
          <li>令 <i>name</i> 为 <i>names</i>（维度从 0 开始的 list 列表）的第 <i>indx</i> 维度所在的元素 </li>

          <li>如果 <i>strict</i> 值为 false，且 <i>name</i> 不是一个 <i>mappedNames</i> 元素，则 

            <ol>
              <li>将 <i>name</i> 添加到 <i>mappedNames</i> 列表中，作为它的一个元素 </li>

              <li>令 <i>g</i> 为调用抽象操作 <i>MakeArgGetter</i> 的结果，其参数为 <i>name</i> 和 <i>env</i></li>

              <li>令 <i>p</i> 为调用抽象操作 <i>MakeArgSetter</i> 的结果，其参数为 <i>name</i> 和 <i>env</i></li>

              <li>调用 <i>map</i> 对象的内部方法 [[DefineOwnProperty]]，将 ToString(<i>indx</i>) 传递进去，属性描述符为：{[[Set]]: p, [[Get]]: g, [[Configurable]]: true}，参数为 false</li>
            </ol>
          </li>
        </ol>
      </li>

      <li>令 <i>indx</i> = <i>indx</i> - 1</li>
    </ol>
  </li>

  <li>如果 <i>mappedNames</i> 不为空，则 

    <ol>
      <li>将 <i>obj</i> 对象的内部属性 [[ParameterMap]] 设置为 <i>map</i></li>

      <li>将 <i>obj</i> 对象的内部方法 [[Get]], [[GetOwnProperty]], [[DefineOwnProperty]], [[Delete]] 按下面给出的定义进行设置。</li>
    </ol>
  </li>

  <li>如果 <i>strict</i> 值为 false，则 

    <ol>
      <li>调用 <i>obj</i> 对象的内部方法 [[DefineOwnProperty]]，将 "callee" 传递进去，属性描述符为；{[[Value]]: func, [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true}，参数为 false</li>
    </ol>
  </li>

  <li>否则，<i>strict</i> 值为 true，那么 

    <ol>
      <li>令 <i>thrower</i> 为 [[ThrowTypeError]] 函数对象 (13.2.3) </li>

      <li>调用 <i>obj</i> 对象的内部方法 [[DefineOwnProperty]]，将 "caller" 传递进去，属性描述符为 :{[[Get]]: thrower, [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false}，参数为 false </li>

      <li>调用 <i>obj</i> 对象的内部方法 [[DefineOwnProperty]]，将 "callee" 传递进去，属性描述符为 :{[[Get]]: thrower, [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false}，参数为 false</li>
    </ol>
  </li>

  <li>返回 <i>obj</i></li>
</ol>

<p>抽象操作 <i>MakeArgGetter</i> 以字符串 <i>name</i> 和环境记录 <i>env</i> 作为参数被调用时，会创建一个函数对象，当执行完后，会返回在 <i>env</i> 中绑定的 <i>name</i> 的值。执行步骤如下：</p>

<ol>
  <li>令 <i>body</i> 为字符 "return "，<i>name</i>，";" 的连接字符串 </li>

  <li>返回一个按照 13.2 章节中描述的方式创建的函数对象，它不需要形参列表，以 <i>body</i> 作为它的 <i>FunctionBody</i>，以 <i>env</i> 作为它的 <i>Scope</i>，并且 <i>Strict</i> 值为 true</li>
</ol>

<p>抽象操作 <i>MakeArgSetter</i> 以字符串 <i>name</i> 和环境记录 <i>env</i> 作为参数被调用时，会创建一个函数对象，当执行完后，会给在 <i>env</i> 中绑定的 <i>name</i> 设置一个值。执行步骤如下：</p>

<ol>
  <li>令 <i>param</i> 为 <i>name</i> 和字符串 "_arg" 的连接字符串 </li>

  <li>令 <i>body</i> 为字符串 "<name>=<param>;"；将 <name> 替换为 <i>name</i> 的值，将 <param> 替换为 <i>param</i> 的值 </li>

  <li>返回一个按照 13.2 章节中描述的方式创建的函数对象，以一个只包含字符串 <i>param</i> 的 list 列表作为它的形参，以 <i>body</i> 作为它的函数体（<i>FunctionBody</i>），以 <i>env</i> 作为它的<i>Scope</i>，并且 <i>Strict</i> 值为 true</li>
</ol>

<p>当 arguments 对象的内部方法 [[Get]] 在一个非严格模式下带有形参的函数中，在一个属性名为 <i>P</i> 的条件下被调用时，其执行步骤如下：</p>

<ol>
  <li>令 <i>map</i> 为 arguments 对象的内部属性 [[ParameterMap]] </li>

  <li>令 <i>isMapped</i> 为 <i>map</i> 对象的内部方法 [[GetOwnPropery]] 传入参数 <i>P</i> 的执行结果 </li>

  <li>如果 <i>isMapped</i> 值为 undefined，则 

    <ol>
      <li>令 <i>v</i> 为 arguments 对象的内部默认的 [[Get]] 方法（8.12.3），传入参数 <i>P</i> 的执行结果 </li>

      <li>如果 <i>P</i> 为 "caller"，且 <i>v</i> 为严格模式下的 Function 对象，则抛出一个 TypeError 的异常 </li>

      <li>返回 <i>v</i></li>
    </ol>
  </li>

  <li>否则，<i>map</i> 包含一个 <i>P</i> 的形参映射表 

    <ol>
      <li>返回 <i>map</i> 对象的内部方法 [[Get]] 传入参数 <i>P</i> 的执行结果</li>
    </ol>
  </li>
</ol>

<p>当 arguments 对象的内部方法 [[GetOwnProperty]] 在一个非严格模式下带有形参的函数中，在一个属性名为 P 的条件下被调用时，其执行步骤如下：</p>

<ol>
  <li>令 <i>desc</i> 为 arguments 对象的内部方法 [[GetOwnPropery]]（8.12.1）传入参数 <i>P</i> 的执行结果 </li>

  <li>如果 <i>desc</i> 为 undefined，返回 <i>desc</i></li>

  <li>令 <i>map</i> 为 arguments 对象内部属性 [[ParameterMap]] 的值 </li>

  <li>令 <i>isMapped</i> 为 <i>map</i> 对象的内部方法 [[GetOwnPropery]] 传入参数 P 的执行结果 </li>

  <li>如果 <i>isMapped</i> 的值不是 undefined，则 

    <ol>
      <li>将 <i>desc</i> 的值设置为 <i>map</i> 对象的内部方法 [[Get]] 传入参数 P 的执行结果</li>
    </ol>
  </li>

  <li>返回 <i>desc</i></li>
</ol>

<p>当 arguments 对象的内部方法 [[DefineOwnProperty]] 在一个非严格模式下带有形参的函数中，在一个属性名为 P，属性描述符为 <i>Desc</i>，布尔标志为 <i>Throw</i> 的条件下被调用时，其执行步骤如下：</p>

<ol>
  <li>令 <i>map</i> 为 arguments 对象的内部属性 [[ParameterMap]] 的值 </li>

  <li>令 <i>isMapped</i> 为 <i>map</i> 对象的内部方法 [[GetOwnPropery]] 传入参数 P 的执行结果 </li>

  <li>令 <i>allowed</i> 为 arguments 对象的内部方法 [[DefineOwnPropery]]（8.12.9）传入参数 <i>P</i>，<i>Desc</i>，false 的执行结果 </li>

  <li>如果 <i>allowed</i> 为 false，则 

    <ol>
      <li>如果 <i>Throw</i> 为 true，则抛出一个 TypeError 的异常，否则，返回 false</li>
    </ol>
  </li>

  <li>如果 <i>isMapped</i> 的值不为 undefined，则 

    <ol>
      <li>如果 IsAccessorDescriptor(<i>Desc</i>) 为 true，则 

        <ol>
          <li>调用 <i>map</i> 对象的内部方法 [[Delete]]，传入 <i>P</i> 和 false 作为参数</li>
        </ol>
      </li>

      <li>否则 
        <ol>
          <li>如果 <i>Desc</i>.[[Value]] 存在，则 

            <ol>
              <li>调用 <i>map</i> 对象的内部方法 [[Put]]，传入 <i>P</i>，<i>Desc</i>.[[Value]] 和 <i>Throw</i> 作为参数</li>
            </ol>
          </li>

          <li>如果 <i>Desc</i>.[[Writable]] 存在，且其值为 false，则 

            <ol>
              <li>调用 <i>map</i> 对象的内部方法 [[Delete]]，传入 <i>P</i> 和 false 作为参数</li>
            </ol>
          </li>
        </ol>
      </li>
    </ol>
  </li>

  <li>返回 true</li>
</ol>

<p>当 arguments 对象的内部方法 [[Delete]] 在一个非严格模式下带有形参的函数中，在一个属性名为 <i>P</i>，布尔标志为 <i>Throw</i> 的条件下被调用时，其执行步骤如下：</p>

<ol>
  <li>令 <i>map</i> 为 arguments 对象的内部属性 [[ParameterMap]] 的值 </li>

  <li>令 <i>isMapped</i> 为 <i>map</i> 对象的内部方法 [[GetOwnPropery]] 传入参数 <i>P</i> 的执行结果 </li>

  <li>令 <i>result</i> 为 arguments 对象的内部方法 [[Delete]]（8.12.7）传入参数 <i>P</i> 和 <i>Throw</i> 的执行结果 </li>

  <li>如果 <i>result</i> 为 true，且 <i>isMapped</i> 不为 undefined，则 

    <ol>
      <li>调用 <i>map</i> 对象的内部方法 [[Delete]]，传入 <i>P</i> 和 false 作为参数</li>
    </ol>
  </li>

  <li>返回 <i>result</i></li>
</ol>

<p>注： 非严格模式下的函数，arguments 对象以数组索引（参见 15.4 的定义）作为数据属性的命名，其数字名字的值少于对应的函数对象初始时的形参数量，它们与绑定在该函数执行环境中对应的参数共享值。这意味着，改变该属性将改变这些对应的、绑定的参数的值，反之亦然。如果其中一个属性被删除然后再对其重定义，或者其中一个属性在某个访问器属性内部被更改，则这种对应关系将被打破。严格模式下的函数，arguments 对象的属性值就是传入该函数的实际参数的简单拷贝，它们与形参之间的值不存在动态的联动关系。</p>

<p>注：ParameterMap 对象和它的属性值被作为说明 arguments 对象对应绑定参数的装置。ParameterMap 对象和它的属性值对象不能直接被 ECMAScript 代码访问。作为 ECMAScript 的实现，不需要实际创建或使用这些对象去实现指定的语义。</p>

<p>注： 严格模式下函数的 Arguments 对象定义的非可配置的访问器属性，"caller" 和 "callee"，在它们被访问时，将抛出一个 TypeError 的异常。在非严格模式下，"callee" 属性具有非常明确的意义，"caller" 属性有一个历史问题，它是否被提供，视为一个由实作环境决定的，在具体的 ECMAScript 实作进行扩展。在严格模式下对这些属性的定义的出现是为了确保它们俩谁也不能在规范的 ECMAScript 实作中以任何方式被定义。</p>



<h4>表达式</h4>

<h4>主值表达式</h4>

<p>语法：</p>

<pre>   PrimaryExpression :
       this 
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineIdentifier">Identifier</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineLiteral">Literal</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineArrayLiteral">ArrayLiteral</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineObjectLiteral">ObjectLiteral</a>
       ( <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineExpression">Expression</a> )</pre>


<h5>this 关键字</h5>

<p>this 关键字执行为当前执行环境的 ThisBinding。</p>



<h5>标识符引用</h5>

<p>Identifier 的执行遵循 10.3.1 所规定的标识符查找。标识符执行的结果总是一个 Reference 类型的值。</p>



<h5>字面量引用</h5>

<p>Literal 按照 7.8 所描述的方式执行。</p>



<h5>数组初始化</h5>

<p>数组初始化是一个以字面量的形式书写的描述数组对象的初始化的表达式。它是一个零个或者多个表达式的序列，其中每一个表示一个数组元素，并且用方括号括起来。元素并不一定要是字面量，每次数组初始化执行时它们都会被执行一次。</p>

<p>数组元素可能在元素列表的开始、结束，或者中间位置被省略。当元素列表中的一个逗号没有被 AssignmentExpression 优先处理（如，一个逗号在另一个逗号之前。）的情况下，缺失的数组元素仍然会对数组长度有贡献，并且增加后续元素的索引值。省略数组元素是没有定义的。假如元素在数组末尾被省略，那么元素不会贡献数组长度。</p>

<p>语法：</p>

<pre>   ArrayLiteral :
       [ <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineElision">Elision</a><sub>opt</sub> ]
       [ <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineElementList">ElementList</a> ]
       [ <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineElementList">ElementList</a> , <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineElision">Elision</a><sub>opt</sub> ]</pre>

<pre>   ElementList :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineElision">Elision</a><sub>opt</sub><a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineAssignmentExpression">AssignmentExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineElementList">ElementList</a> , <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineElision">Elision</a><sub>opt</sub><a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineAssignmentExpression">AssignmentExpression</a></pre>

<pre>   Elision :
       ,
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineElision">Elision</a> ,</pre>

<p>语义：</p>

<p>产生式 <i>ArrayLiteral</i> <b>:</b> <b>[</b> <i>Elision</i><sub>opt</sub> <b>]</b> 按照下面的过程执行 :</p>

<ol>
  <li>令 array 为以表达式 new Array() 完全一致的方式创建一个新对象的结果，其中 Array 是一个标准的内置构造器 </li>

  <li>令 pad 为解释执行 Elision 的结果 ; 如果不存在的话，使用数值 0. </li>

  <li>以参数 "length", pad, 和 false 调用 array 的 [[Put]] 内置方法 </li>

  <li>返回 array.</li>
</ol>

<p>产生式 <i>ArrayLiteral</i> <b>:</b> <b>[</b> <i>ElementList</i> <b>]</b> 按照下面的过程执行 :</p>

<ol>
  <li>返回解释执行 ElementList 的结果 .</li>
</ol>

<p>产生式 <i>ArrayLiteral</i> <b>: '</b><i>[<b> </b></i><b>ElementList<i> </i></b><i>,<b> </b></i><b>'</b>Elision<i><sub>opt</sub> <b>]</b> 按照下面的过程执行 :</i></p>

<ol>
  <li>令 array 为解释执行 ElementList 的结果 . </li>

  <li>令 pad 为解释执行 Elision 的结果 ; 如果不存在的话，使用数值 0. </li>

  <li>令 len 为以参数 "length". 调用 array 的 [[Get]] 内置方法的结果 </li>

  <li>以参数 "length", ToUint32(pad+len), 和 false 调用 array 的 [[Put]] 内置方法 </li>

  <li>返回 array.</li>
</ol>

<p>产生式 <i>ElementList</i> <b>:</b> <i>Elision</i><sub>opt</sub> <i>AssignmentExpression</i> 按照下面的过程执行 :</p>

<ol>
  <li>令 array 为以表达式 new Array() 完全一致的方式创建一个新对象的结果，其中 Array 是一个标准的内置构造器 </li>

  <li>令 firstIndex 为解释执行 Elision 的结果 ; 如果不存在的话，使用数值 0. </li>

  <li>令 initResult 为解释执行 AssignmentExpression 的结果 . </li>

  <li>令 initValue 为 GetValue(initResult). </li>

  <li>以参数 ToString(firstIndex), 属性描述对象 { [[Value]]: initValue, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, 和 false 调用 array 的 [[DefineOwnProperty]] 内置方法 </li>

  <li>返回 array.</li>
</ol>

<p>产生式 <i>ElementList</i> <b>:</b> <i>ElementList</i> <b>,</b> <i>Elision</i><sub>opt</sub> <i>AssignmentExpression</i> 按照下面的过程执行 :</p>

<ol>
  <li>令 array 为解释执行 ElementList 的结果 . </li>

  <li>令 pad 为解释执行 Elision 的结果 ; 如果不存在的话，使用数值 0. </li>

  <li>令 initResult 为解释执行 AssignmentExpression 的结果 . </li>

  <li>令 initValue 为 GetValue(initResult). </li>

  <li>令 len 为以参数 "length". 调用 array 的 [[Get]] 内置方法的结果 </li>

  <li>以参数 ToString(ToUint32((pad+len)) 和 属性描述对象 { [[Value]]: initValue, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, 和 false 调用 array 的 [[DefineOwnProperty]] 内置方法 </li>

  <li>返回 array.</li>
</ol>

<p>产生式 <i>Elision</i> <b>:</b> <b>,</b> 按照下面的过程执行 :</p>

<ol>
  <li>返回数值 1.</li>
</ol>

<p>产生式 <i>Elision</i> <b>:</b> <i>Elision</i> <b>,</b> 按照下面的过程执行 :</p>

<ol>
  <li>令 preceding 为解释执行 Elision 的结果 . </li>

  <li>返回 preceding+1.</li>
</ol>

<p>注：[[DefineOwnProperty]] 用于确保即使默认的数组原型对象被更改的情况下自身属性也会被定义，可以杜绝用 [[put]] 创建一个新的自身属性 .</p>



<h5>对象初始化</h5>

<p>对象初始化是一个以直接量的方式描述对象的初始化过程的表达式。它是用花括号括起来的由零或者多对属性名 / 关联值组成的列表，值不需要是直接量，每次对象初始化被执行到时他们会执行一次。</p>

<p>语法：</p>

<pre>   ObjectLiteral :
       { } 
       { <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlinePropertyNameAndValueList">PropertyNameAndValueList</a> }
       { <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlinePropertyNameAndValueList">PropertyNameAndValueList</a> , }</pre>

<pre>   PropertyNameAndValueList :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlinePropertyAssignment">PropertyAssignment</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlinePropertyNameAndValueList">PropertyNameAndValueList</a> , <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlinePropertyAssignment">PropertyAssignment</a></pre>

<pre>   PropertyAssignment :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlinePropertyName">PropertyName</a> : <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineAssignmentExpression">AssignmentExpression</a>
       get <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlinePropertyName">PropertyName</a>() { <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineFunctionBody">FunctionBody</a> }
       set <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlinePropertyName">PropertyName</a>( <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlinePropertySetParameterList">PropertySetParameterList</a> ) { <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineFunctionBody">FunctionBody</a> }</pre>

<pre>   PropertyName :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineIdentifierName">IdentifierName</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineStringLiteral">StringLiteral</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineNumericLiteral">NumericLiteral</a></pre>

<pre>   PropertySetParameterList :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineIdentifier">Identifier</a></pre>

<p>语义：</p>

<p>产生式 <i>ObjectLiteral</i> <b>:</b> <b>{</b> <b>}</b> 按照下面的过程执行 :</p>

<ol>
  <li>返回 a new object created as if by the expression new Object() where Object is the st 和 ard built-in constructor with that name.</li>
</ol>

<p>产生式 s <i>ObjectLiteral</i> <b>:</b> <b>{</b> <i>PropertyNameAndValueList</i> <b>}</b> 以及 <i>ObjectLiteral</i> <b>:</b> <b>{</b> <i>PropertyNameAndValueList</i> ,<b>}</b> 按照下面的过程执行 :</p>

<ol>
  <li>返回解释执行 PropertyNameAndValueList 的结果 .</li>
</ol>

<p>产生式 <i>PropertyNameAndValueList</i> <b>:</b> <i>PropertyAssignment</i> 按照下面的过程执行 :</p>

<ol>
  <li>令 obj 为以表达式 new Object() 完全一致的方式创建一个新对象的结果，其中 Object 是一个标准的内置构造器 </li>

  <li>令 propId 为解释执行 PropertyAssignment 的结果 . </li>

  <li>以参数 propId.name, propId.descriptor, 和 false 调用 obj 的 [[DefineOwnProperty]] 内置方法 </li>

  <li>返回 obj.</li>
</ol>

<p>产生式 <i>PropertyNameAndValueList</i> <b>:</b> <i>PropertyNameAndValueList</i> <b>,</b> <i>PropertyAssignment</i> 按照下面的过程执行 :</p>

<ol>
  <li>令 obj 为解释执行 PropertyNameAndValueList 的结果 . </li>

  <li>令 propId 为解释执行 PropertyAssignment 的结果 . </li>

  <li>令 previous 为以参数 propId.name. 调用 obj 的 [[GetOwnProperty]] 内置方法的结果 </li>

  <li>如果 previous 不是 undefined，且当以下任意一个条件为 true 时，则抛出一个 SyntaxError 异常： 
    <ul>
      <li>产生式包含在严格模式下并且 IsDataDescriptor(previous) 为 true 并且 IsDataDescriptor(propId.descriptor) 为 true </li>

      <li>IsDataDescriptor(previous) 为 true 并且 IsAccessorDescriptor(propId.descriptor) 为 true. </li>

      <li>IsAccessorDescriptor(previous) 为 true 并且 IsDataDescriptor(propId.descriptor) 为 true. </li>

      <li>IsAccessorDescriptor(previous) 为 true 并且 IsAccessorDescriptor(propId.descriptor) 为 true 并且 previous 和 propId.descriptor 都有 [[Get]] 字段 或者 previous 和 propId.descriptor 都有 [[Set]] 字段。</li>
    </ul>
  </li>
</ol>

<p>如果以上步骤抛出一个语法错误，那么实现应该把这个错误视为早期语法错误。</p>

<p>产生式 <i>PropertyAssignment</i> <b>:</b> <i>PropertyName</i> <b>:</b> <i>AssignmentExpression</i> 按照下面的过程执行 :</p>

<ol>
  <li>令 propName 为解释执行 PropertyName 的结果 . </li>

  <li>令 exprValue 为解释执行 AssignmentExpression 的结果 . </li>

  <li>令 propValue 为 GetValue(exprValue). </li>

  <li>令 desc 为属性描述对象 {[[Value]]: propValue, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true} </li>

  <li>返回 Property Identifier (propName, desc).</li>
</ol>

<p>产生式 <i>PropertyAssignment</i> <b>:</b> <b>get</b> <i>PropertyName</i> <b>( ) {</b> <i>FunctionBody</i> <b>}</b> 按照下面的过程执行 :</p>

<ol>
  <li>令 propName 为解释执行 PropertyName 的结果 . </li>

  <li>令 closure 为按照 13.2 规定，以空的参数列表和 body 代表的 FunctionBody 创建的一个新的函数对象 . 传入当前执行中的执行环境的 LexicalEnvironment 作为 Scope. 假如 PropertyAssignment 包含在严格模式代码中或者 FunctionBody 是严格模式代码，传入 true 为严格模式标志。 </li>

  <li>令 desc 为属性描述对象 {[[Get]]: closure, [[Enumerable]]: true, [[Configurable]]: true} </li>

  <li>返回 Property Identifier (propName, desc).</li>
</ol>

<p>产生式 <i>PropertyAssignment</i> <b>:</b> <b>set</b> <i>PropertyName</i> <b>( </b><i>PropertySetParameterList</i><b> )</b> <b>{</b> <i>FunctionBody</i> <b>}</b> is evaluated as follows:</p>

<ol>
  <li>令 propName 为解释执行 PropertyName 的结果 . </li>

  <li>令 closure 为按照 13.2 规定，以 PropertySetParameterList 作为参数列表和 body 代表的 FunctionBody 创建的一个新的函数对象 . 传入当前执行中的执行环境的 LexicalEnvironment 作为 Scope. 假如 PropertyAssignment 包含在严格模式代码中或者 FunctionBody 是严格模式代码，传入 true 为严格模式标志。 </li>

  <li>令 desc 为属性描述对象 {[[Set]]: closure, [[Enumerable]]: true, [[Configurable]]: true} </li>

  <li>返回属性标识符 (propName, desc).</li>
</ol>

<p>假如 FunctionBody 是严格模式或者被包含在严格模式代码内，PropertyAssignment 中的 PropertySetParameterList，"eval" 或者 "arguments" 作为标识符将会是一个语法错误。</p>

<p>产生式 <i>PropertyName</i> <b>: </b><i>IdentifierName</i> 按照下面的过程执行 :</p>

<ol>
  <li>返回一个包含跟 IdentifierName. 完全相同的字符序列的字符串值</li>
</ol>

<p>产生式 <i>PropertyName</i> <b>: </b><i>StringLiteral</i> 按照下面的过程执行 :</p>

<ol>
  <li>返回 the SV of the StringLiteral.</li>
</ol>

<p>产生式 <i>PropertyName</i> <b>:</b> <i>NumericLiteral</i> 按照下面的过程执行 :</p>

<ol>
  <li>令 nbr 为求 NumericLiteral 值的结果 </li>

  <li>返回 ToString(nbr).</li>
</ol>

<h5>分组表达式</h5>

<p>产生式 <i>PrimaryExpression</i> <b>: </b><i>( Expression )</i> 按照下面的过程执行 :</p>
<ol>
  <li>Return the result of evaluating Expression. This may be of type Reference. </li>
</ol>

<div>NOTE This algorithm does not apply GetValue to the result of evaluating Expression. The principal motivation for this is so that operators such as delete and typeof may be applied to parenthesised expressions.
</div>

<h4>左值表达式</h4>

<p>语法：</p>

<pre>   MemberExpression :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlinePrimaryExpression">PrimaryExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineFunctionExpression">FunctionExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineMemberExpression">MemberExpression</a> [ <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineExpression">Expression</a> ]
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineMemberExpression">MemberExpression</a> . <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineIdentifierName">IdentifierName</a>
       new <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineMemberExpression">MemberExpression</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineArguments">Arguments</a></pre>

<pre>   NewExpression :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineMemberExpression">MemberExpression</a>
       new <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineNewExpression">NewExpression</a></pre>

<pre>   CallExpression :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineMemberExpression">MemberExpression</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineArguments">Arguments</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineCallExpression">CallExpression</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineArguments">Arguments</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineCallExpression">CallExpression</a> [ <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineExpression">Expression</a> ]
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineCallExpression">CallExpression</a> . <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineIdentifierName">IdentifierName</a></pre>

<pre>   Arguments :
       ( )
       ( <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineArgumentList">ArgumentList</a> )</pre>

<pre>   ArgumentList :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineAssignmentExpression">AssignmentExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineArgumentList">ArgumentList</a> , <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineAssignmentExpression">AssignmentExpression</a></pre>

<pre>   LeftHandSideExpression :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineNewExpression">NewExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineCallExpression">CallExpression</a></pre>


<h5>属性访问</h5>

<p>属性是通过 name 来访问的，可以使用点表示法访问</p>

<pre>   MemberExpression . IdentifierName
   CallExpression . IdentifierName</pre>

<p>或者括号表示法访问</p>

<pre>   MemberExpression [ Expression ] 
   CallExpression [ Expression ]</pre>

<p>点表示法是根据以下的语法转换解释</p>

<pre>   MemberExpression . IdentifierName</pre>

<p>这会等同于下面这个行为</p>

<pre>   MemberExpression [ <identifier-name-string> ]</pre>

<p>类似地，</p>

<pre>   CallExpression . IdentifierName</pre>

<p>是等同于下面的行为</p>

<pre>   CallExpression [ <identifier-name-string> ]</pre>

<p><identifier-name-string> 是一个字符串字面量，它与 Unicode 编码后的 IdentifierName 包含相同的字符序列。</p>

<p>产生式 <i>MemberExpression</i> <b>:</b> <i>MemberExpression</i> <b>[</b> <i>Expression</i> <b>]</b> is evaluated as follows:</p>

<ol>
  <li>令 baseReference 为解释执行 MemberExpression 的结果 . </li>

  <li>令 baseValue 为 GetValue(baseReference). </li>

  <li>令 propertyNameReference 为解释执行 Expression 的结果 . </li>

  <li>令 propertyNameValue 为 GetValue(propertyNameReference). </li>

  <li>调用 CheckObjectCoercible(baseValue). </li>

  <li>令 propertyNameString 为 ToString(propertyNameValue). </li>

  <li>如果正在执行中的语法产生式包含在严格模式代码当中，令 strict 为 true, 否则令 strict 为 false. </li>

  <li>返回一个值类型的引用，其基值为 baseValue 且其引用名为 propertyNameString, 严格模式标记为 strict.</li>
</ol>

<p>The production CallExpression : CallExpression [ Expression ] is evaluated in exactly the same manner, except that the contained CallExpression is evaluated in step 1.</p>


<h5>new 运算符</h5>

<p>产生式 <i>NewExpression</i> <b>:</b><i> </i><b>new</b> <i>NewExpression</i> 按照下面的过程执行 :</p>

<ol>
  <li>令 ref 为解释执行 NewExpression 的结果 . </li>

  <li>令 constructor 为 GetValue(ref). </li>

  <li>如果 Type(constructor) is not Object ，抛出一个 TypeError 异常 . </li>

  <li>如果 constructor 没有实现 [[Construct]] 内置方法 ，抛出一个 TypeError 异常 . </li>

  <li>返回调用 constructor 的 [[Construct]] 内置方法的结果 , 传入按无参数传入参数列表 ( 就是一个空的参数列表 ).</li>
</ol>

<p>产生式 <i>MemberExpression</i> <b>:</b> <b>new</b> <i>MemberExpression</i> <i>Arguments</i> 按照下面的过程执行 :</p>

<ol>
  <li>令 ref 为解释执行 MemberExpression 的结果 . </li>

  <li>令 constructor 为 GetValue(ref). </li>

  <li>令 argList 为解释执行 Arguments 的结果 , producing an internal list of argument values (11.2.4). </li>

  <li>如果 Type(constructor) is not Object ，抛出一个 TypeError 异常 . </li>

  <li>如果 constructor 没有实现 [[Construct]] 内置方法，抛出一个 TypeError 异常 . </li>

  <li>返回以 argList 为参数调用 constructor 的 [[Construct]] 内置方法的结果。</li>
</ol>


<h5>函数调用</h5>

<p>产生式 <i>CallExpression</i> <b>:</b> <i>MemberExpression</i> <i>Arguments</i> 按照下面的过程执行 :</p>

<ol>
  <li>令 ref 为解释执行 MemberExpression 的结果 . </li>

  <li>令 func 为 GetValue(ref). </li>

  <li>令 argList 为解释执行 Arguments 的结果 , 产生参数值们的内部列表 (see 11.2.4). </li>

  <li>如果 Type(func) is not Object ，抛出一个 TypeError 异常 . </li>

  <li>如果 IsCallable(func) is false ，抛出一个 TypeError 异常 . </li>

  <li>如果 Type(ref) 为 Reference，那么 如果 IsPropertyReference(ref) 为 true，那么 令 thisValue 为 GetBase(ref). 否则 , ref 的基值是一个环境记录项 令 thisValue 为调用 GetBase(ref) 的 ImplicitThisValue 具体方法的结果 </li>

  <li>否则 , 假如 Type(ref) 不是 Reference. 令 thisValue 为 undefined. </li>

  <li>返回调用 func 的 [[Call]] 内置方法的结果 , 传入 thisValue 作为 this 值和列表 argList 作为参数列表</li>
</ol>

<p>The production CallExpression : CallExpression Arguments is evaluated in exactly the same manner, except that the contained CallExpression is evaluated in step 1.
</p>
<p>NOTE The returned result will never be of type Reference if func is a native ECMAScript object. Whether calling a host object can return a value of type Reference is implementation-dependent. If a value of type Reference is returned, it must be a non-strict Property Reference.
</p>

<h5>参数列表</h5>

<p>The evaluation of an argument list produces a List of values (see 8.8).</p>

<p>产生式 <i>Arguments </i><b>:</b> <b>( )</b> 按照下面的过程执行 :</p>

<ol>
  <li>返回一个空列表 .</li>
</ol>

<p>产生式 <i>Arguments</i> <b>:</b><i> </i><b>( </b><i>ArgumentList</i><b> )</b> 按照下面的过程执行 :</p>

<ol>
  <li>返回解释执行 ArgumentList 的结果 .</li>
</ol>

<p>产生式 <i>ArgumentList</i> '<i>:'</i><b> </b><i>AssignmentExpression</i><b> </b>按照下面的过程执行 :</p>

<ol>
  <li>令 ref 为解释执行 AssignmentExpression 的结果 . </li>

  <li>令 arg 为 GetValue(ref). </li>

  <li>返回 a List whose sole item is arg.</li>
</ol>

<p>产生式 <i>ArgumentList</i> <b>:''''</b><i> </i>ArgumentList<i><b> ,</b> </i>AssignmentExpression<i><b> </b>按照下面的过程执行 :</i></p>

<ol>
  <li>令 precedingArgs 为解释执行 ArgumentList 的结果 . </li>

  <li>令 ref 为解释执行 AssignmentExpression 的结果 . </li>

  <li>令 arg 为 GetValue(ref). </li>

  <li>返回一个列表，长度比 precedingArgs 大 1 且 它的 items 为 precedingArgs 的 items, 按顺序在后面跟 arg，arg 是这个新的列表的最后一个 item.</li>
</ol>


<h5>函数表达式</h5>

<p>产生式 <i>MemberExpression</i> <b>:</b> <i>FunctionExpression</i> 按照下面的过程执行 :</p>

<ol>
  <li>返回解释执行 FunctionExpression 的结果 .</li>
</ol>


<h4>后缀表达式</h4>

<p>语法：</p>

<pre>   PostfixExpression :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineLeftHandSideExpression">LeftHandSideExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineLeftHandSideExpression">LeftHandSideExpression</a> [ 此处无换行 <i>LineTerminator</i>] ++ 
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineLeftHandSideExpression">LeftHandSideExpression</a> [ 此处无换行 <i>LineTerminator</i>] --</pre>


<h5>后缀自增运算符</h5>

<p>产生式 <i>PostfixExpression</i> <b>:</b> <i>LeftHandSideExpression</i> [ 此处无换行 <i>LineTerminator</i>] <b>++ </b>按照下面的过程执行 :</p>

<ol>
  <li>令 lhs 为解释执行 LeftH 和 SideExpression 的结果 . </li>

  <li>假如以下所有条件都为 true，抛出一个 SyntaxError 异常 : 
    <ul>
      <li>Type(lhs) 为 Reference </li>

      <li>IsStrictReference(lhs) 为 true </li>

      <li>Type(GetBase(lhs)) 为环境记录项 </li>

      <li>GetReferencedName(lhs) 为 "eval" 或 "arguments"</li>
    </ul>
  </li>
</ol>


<h5>后缀自减运算符</h5>

<p>产生式 <i>PostfixExpression</i> <b>:</b> <i>LeftHandSideExpression</i> [ 此处无换行 <i>LineTerminator</i>] <b>-- </b>按照下面的过程执行 :</p>

<ol>
  <li>令 lhs 为解释执行 LeftH 和 SideExpression 的结果 . </li>

  <li>假如以下所有条件都为 true，抛出一个 SyntaxError 异常 : 
    <ul>
      <li>Type(lhs) 为 Reference </li>

      <li>IsStrictReference(lhs) 为 true </li>

      <li>Type(GetBase(lhs)) 为环境记录项 </li>

      <li>GetReferencedName(lhs) 为 "eval" 或 "arguments"</li>
    </ul>
  </li>
</ol>


<h4>一元运算符</h4>

<p>语法：</p>

<pre>   UnaryExpression :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlinePostfixExpression">PostfixExpression</a>
       delete <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineUnaryExpression">UnaryExpression</a>
       void <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineUnaryExpression">UnaryExpression</a>
       typeof <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineUnaryExpression">UnaryExpression</a>
       ++ <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineUnaryExpression">UnaryExpression</a>
       -- <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineUnaryExpression">UnaryExpression</a>
       + <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineUnaryExpression">UnaryExpression</a>
       - <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineUnaryExpression">UnaryExpression</a>
       ~ <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineUnaryExpression">UnaryExpression</a>  ! <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineUnaryExpression">UnaryExpression</a></pre>


<h5>delete 运算符</h5>

<p>产生式 <i>UnaryExpression</i> <b>:</b> <b>delete</b> <i>UnaryExpression</i> 按照下面的过程执行 :</p>

<ol>
  <li>令 ref 为解释执行 UnaryExpression 的结果。 </li>

  <li>如果 Type(ref) 不是 Reference，返回 true。 </li>

  <li>若 IsUnresolvableReference(ref) 则 , 如果 IsStrictReference(ref) 为 true ，抛出一个 SyntaxError 异常。 否则，返回 true。 </li>

  <li>如果 IsPropertyReference(ref) 为 true 则： 返回以 GetReferencedName(ref) 和 IsStrictReference(ref) 做为参数调用 ToObject(GetBase(ref)) 的 [[Delete]] 内置方法的结果。 </li>

  <li>否则 , ref 是到环境记录项绑定的 Reference，所以： 如果 IsStrictReference(ref) 为 true ，抛出一个 SyntaxError 异常 . 令 bindings 为 GetBase(ref). 返回以 GetReferencedName(ref) 为参数调用绑定的 DeleteBinding 具体方法的结果。</li>
</ol>

<div>NOTE When a delete operator occurs within strict mode code, a SyntaxError exception is thrown if its UnaryExpression is a direct reference to a variable, function argument, or function name. In addition, if a delete operator occurs within strict mode code and the property to be deleted has the attribute { [[Configurable]]: false }, a TypeError exception is thrown.</div>

<h5>void 运算符</h5>

<p>产生式 <i>UnaryExpression</i> <b>:</b> <b>void</b> <i>UnaryExpression</i> 按照下面的过程执行 :</p>

<div>NOTE GetValue must be called even though its value is not used because it may have observable side-effects.</div>

<ol>
  <li>令 expr 为解释执行 UnaryExpression 的结果 . </li>

  <li>调用 GetValue(expr). </li>

  <li>返回 undefined.</li>
</ol>


<h5>typeof 运算符</h5>

<p>产生式 <i>UnaryExpression</i> <b>:</b> <b>typeof</b> <i>UnaryExpression</i> 按照下面的过程执行 :</p>

<ol>
  <li>令 val 为解释执行 UnaryExpression 的结果 . </li>

  <li>如果 Type(val) 为 Reference，则： 如果 IsUnresolvableReference(val) 为 true，返回 "undefined"。 令 val 为 GetValue(val). </li>

  <li>返回根据表 20 由 Type(val) 决定的字符串。</li>
</ol>
<div>
<p>表 20 typeof 运算符结果</p>

<p><b>val 类型</b>

  <br /><b>结果</b></p>

<p><b>Undefined</b>

  <br />"undefined"</p>

<p><b>Null</b>

  <br />"null"</p>

<p><b>Boolean</b>

  <br />"boolean"</p>

<p><b>Number</b>

  <br />"number"</p>

<p><b>String</b>

  <br />"string"</p>

<p><b>Object</b></p>

<p>（原生，且没有实现 [[call]]）</p>

<p>"object"</p>

<p><b>Object</b></p>

<p>（原生或者宿主且实现了 [[call]]）</p>

<p>"function"</p>

<p><b>Object</b></p>

<p>（宿主且没实现 [[call]]）</p>

<p>由实现定义，但不能是 "undefined", "boolean", "number", or "string"</p>

</div>

<h5>前自增运算符</h5>

<p>产生式 <i>UnaryExpression</i> <b>:</b><i> </i><b>++ </b><i>UnaryExpression</i> 按照下面的过程执行 :</p>

<ol>
  <li>令 expr 为解释执行 UnaryExpression 的结果 . </li>

  <li>抛出一个 SyntaxError 异常当以下条件全部为真 : 
    <ul>
      <li>Type(expr) 为 Reference </li>

      <li>IsStrictReference(expr) 为 true </li>

      <li>Type(GetBase(expr)) 为环境记录项 </li>

      <li>GetReferencedName(expr) 是 "eval" 或 "arguments"</li>
    </ul>
  </li>
</ol>


<h5>前自减运算符</h5>

<p>产生式 <i>UnaryExpression</i> <b>:</b><i> </i><b>-- </b><i>UnaryExpression</i> 按照下面的过程执行 :</p>

<ol>
  <li>令 expr 为解释执行 UnaryExpression 的结果 . </li>

  <li>抛出一个 SyntaxError 异常，当以下条件全部为真 : 
    <ul>
      <li>Type(expr) 为 Reference </li>

      <li>IsStrictReference(expr) 为 true </li>

      <li>Type(GetBase(expr)) 为环境记录项 </li>

      <li>GetReferencedName(expr) 是 "eval" 或 "arguments"</li>
    </ul>
  </li>
</ol>


<h5>一元 + 运算符</h5>

<p>The unary + operator converts its operand to Number type.</p>

<p>产生式 <i>UnaryExpression</i> <b>:</b><i> </i><b>+</b> <i>UnaryExpression</i> 按照下面的过程执行 :</p>

<ol>
  <li>令 expr 为解释执行 UnaryExpression 的结果 . </li>

  <li>返回 ToNumber(GetValue(expr)).</li>
</ol>


<h5>一元 - 运算符</h5>

<p>The unary - operator converts its operand to Number type and then negates it. Note that negating +0 produces −0, and negating −0 produces +0.</p>

<p>产生式 <i>UnaryExpression</i> <b>:</b><i> </i><b>-</b> <i>UnaryExpression</i> 按照下面的过程执行 :</p>

<ol>
  <li>令 expr 为解释执行 UnaryExpression 的结果 . </li>

  <li>令 oldValue 为 ToNumber(GetValue(expr)). </li>

  <li>如果 oldValue is NaN ，return NaN. </li>

  <li>返回 oldValue 取负（即，算出一个数字相同但是符号相反的值）的结果。</li>
</ol>


<h5>按位非运算符</h5>

<p>产生式 <i>UnaryExpression</i> <b>:</b><i> </i><b>~</b> <i>UnaryExpression</i> 按照下面的过程执行 :</p>

<ol>
  <li>令 expr 为解释执行 UnaryExpression 的结果 . </li>

  <li>令 oldValue 为 ToInt32(GetValue(expr)). </li>

  <li>返回 oldValue 按位取反的结果。结果为 32 位有符号整数。</li>
</ol>


<h5>逻辑非运算符</h5>

<p>产生式 <i>UnaryExpression</i> <b>:</b><i> </i><b>!</b> <i>UnaryExpression</i> 按照下面的过程执行 :</p>

<ol>
  <li>令 expr 为解释执行 UnaryExpression 的结果 . </li>

  <li>令 oldValue 为 ToBoolean(GetValue(expr)). </li>

  <li>如果 oldValue 为 true ，返回 false. </li>

  <li>返回 true.</li>
</ol>


<h4>乘法运算符</h4>

<p>语法：</p>

<pre>   MultiplicativeExpression :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineUnaryExpression">UnaryExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineMultiplicativeExpression">MultiplicativeExpression</a> * <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineUnaryExpression">UnaryExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineMultiplicativeExpression">MultiplicativeExpression</a> / <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineUnaryExpression">UnaryExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineMultiplicativeExpression">MultiplicativeExpression</a> % <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineUnaryExpression">UnaryExpression</a></pre>

<p>语义：</p>

<p>产生式 <i>MultiplicativeExpression </i><b>:</b><i> '<b>MultiplicativeExpression'</b>@ '<b>UnaryExpression</b></i><b>, where @ stands for one of the operators in the above definitions, 按照下面的过程执行 :</b></p>

<ol>
  <li>令 left 为解释执行 MultiplicativeExpression 的结果 . </li>

  <li>令 leftValue 为 GetValue(left). </li>

  <li>令 right 为解释执行 UnaryExpression 的结果 . </li>

  <li>令 rightValue 为 GetValue(right). </li>

  <li>令 leftNum 为 ToNumber(leftValue). </li>

  <li>令 rightNum 为 ToNumber(rightValue). </li>

  <li>返回将特定运算符 (*, /, or %) 作用于 leftNum 和 rightNum 的结果。参见 11.5.1, 11.5.2, 11.5.3 后的注解。</li>
</ol>


<h5>使用 * 运算符</h5>

<p>The * operator performs multiplication, producing the product of its operands. Multiplication is commutative. Multiplication is not always associative in ECMAScript, because of finite precision.</p>

<p>The result of a floating-point multiplication is governed by the rules of IEEE 754 binary double-precision arithmetic:</p>

<p>
If either operand is NaN, the result is NaN.

The sign of the result is positive if both operands have the same sign, negative if the operands have different signs.

Multiplication of an infinity by a zero results in NaN.

Multiplication of an infinity by an infinity results in an infinity. The sign is determined by the rule already stated above.

Multiplication of an infinity by a finite nonzero value results in a signed infinity. The sign is determined by the rule already stated above.

In the remaining cases, where neither an infinity or NaN is involved, the product is computed and rounded to the nearest representable value using IEEE 754 round-to-nearest mode. If the magnitude is too large to represent, the result is then an infinity of appropriate sign. If the magnitude is too small to represent, the result is then a zero of appropriate sign. The ECMAScript language requires support of gradual underflow as defined by IEEE 754.</p>

<h5>使用 / 运算符</h5>
<p>The / operator performs division, producing the quotient of its operands. The left operand is the dividend and the right operand is the divisor. ECMAScript does not perform integer division. The operands and result of all division operations are double-precision floating-point numbers. The result of division is determined by the specification of IEEE 754 arithmetic:
</p>
<p>
If either operand is NaN, the result is NaN.

The sign of the result is positive if both operands have the same sign, negative if the operands have different signs.

Division of an infinity by an infinity results in NaN.

Division of an infinity by a zero results in an infinity. The sign is determined by the rule already stated above.

Division of an infinity by a nonzero finite value results in a signed infinity. The sign is determined by the rule already stated above.

Division of a finite value by an infinity results in zero. The sign is determined by the rule already stated above.

Division of a zero by a zero results in NaN; division of zero by any other finite value results in zero, with the sign determined by the rule already stated above.

Division of a nonzero finite value by a zero results in a signed infinity. The sign is determined by the rule already stated above.

In the remaining cases, where neither an infinity, nor a zero, nor NaN is involved, the quotient is computed and rounded to the nearest representable value using IEEE 754 round-to-nearest mode. If the magnitude is too large to represent, the operation overflows; the result is then an infinity of appropriate sign. If the magnitude is too small to represent, the operation underflows and the result is a zero of the appropriate sign. The ECMAScript language requires support of gradual underflow as defined by IEEE 754.</p>


<h5>使用 % 运算符</h5>

<p>The % operator yields the remainder of its operands from an implied division; the left operand is the dividend and the right operand is the divisor.
</p>
<p>NOTE In C and C++, the remainder operator accepts only integral operands; in ECMAScript, it also accepts floating-point operands.
</p>
<p>The result of a floating-point remainder operation as computed by the % operator is not the same as the “remainder” operation defined by IEEE 754. The IEEE 754 “remainder” operation computes the remainder from a rounding division, not a truncating division, and so its behaviour is not analogous to that of the usual integer remainder operator. Instead the ECMAScript language defines % on floating-point operations to behave in a manner analogous to that of the Java integer remainder operator; this may be compared with the C library function fmod.
</p>
<p>The result of an ECMAScript floating-point remainder operation is determined by the rules of IEEE arithmetic:
</p>

<p>If either operand is NaN, the result is NaN.

The sign of the result equals the sign of the dividend.

If the dividend is an infinity, or the divisor is a zero, or both, the result is NaN.

If the dividend is finite and the divisor is an infinity, the result equals the dividend.

If the dividend is a zero and the divisor is nonzero and finite, the result is the same as the dividend.

In the remaining cases, where neither an infinity, nor a zero, nor NaN is involved, the floating-point remainder r from a dividend n and a divisor d is defined by the mathematical relation r = n − (d × q) where q is an integer that is negative only if n/d is negative and positive only if n/d is positive, and whose magnitude is as large as possible without exceeding the magnitude of the true mathematical quotient of n and d. r is computed and rounded to the nearest representable value using IEEE 754 round-to-nearest mode.</p>

<h4>加法运算符</h4>

<p>语法：</p>

<pre>   AdditiveExpression :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineMultiplicativeExpression">MultiplicativeExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineAdditiveExpression">AdditiveExpression</a> + <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineMultiplicativeExpression">MultiplicativeExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineAdditiveExpression">AdditiveExpression</a> - <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineMultiplicativeExpression">MultiplicativeExpression</a></pre>
<h5>加号运算符 ( + )</h5>

<p>The addition operator either performs string concatenation or numeric addition.</p>

<p>产生式 <i>AdditiveExpression</i> <b>:</b> <i>AdditiveExpression</i> <b>+</b> <i>MultiplicativeExpression</i> 按照下面的过程执行 :</p>

<ol>
  <li>令 lref 为解释执行 AdditiveExpression 的结果 . </li>

  <li>令 lval 为 GetValue(lref). </li>

  <li>令 rref 为解释执行 MultiplicativeExpression 的结果 . </li>

  <li>令 rval 为 GetValue(rref). </li>

  <li>令 lprim 为 ToPrimitive(lval). </li>

  <li>令 rprim 为 ToPrimitive(rval). </li>

  <li>如果 Type(lprim) 为 String 或者 Type(rprim) 为 String，则： 返回由 ToString(lprim) 和 ToString(rprim) 连接而成的字符串 </li>

  <li>返回将加法运算作用于 ToNumber(lprim) 和 ToNumber(rprim) 的结果。参见 11.6.3 后的注解。</li>
</ol>
<h5>减号运算符 ( - )</h5>
<p>The production AdditiveExpression : AdditiveExpression - MultiplicativeExpression is evaluated as follows:</p>

<p>产生式 <i>AdditiveExpression</i> <b>:</b> <i>AdditiveExpression</i> <b>-</b> <i>MultiplicativeExpression</i> 按照下面的过程执行 :</p>

<ol>
  <li>令 lref 为解释执行 AdditiveExpression 的结果 . </li>

  <li>令 lval 为 GetValue(lref). </li>

  <li>令 rref 为解释执行 MultiplicativeExpression 的结果 . </li>

  <li>令 rval 为 GetValue(rref). </li>

  <li>令 lnum 为 ToNumber(lval). </li>

  <li>令 rnum 为 ToNumber(rval). </li>

  <li>返回返回将减法运算作用于 ToNumber(lprim) 和 ToNumber(rprim) 的结果。参见 11.6.3 后的注解。</li>
</ol>

<h5>加法作用于数字</h5>
<p>The + operator performs addition when applied to two operands of numeric type, producing the sum of the operands. The - operator performs subtraction, producing the difference of two numeric operands.
</p><p>
Addition is a commutative operation, but not always associative.
</p><p>
The result of an addition is determined using the rules of IEEE 754 binary double-precision arithmetic:
</p>

<p>If either operand is NaN, the result is NaN.

The sum of two infinities of opposite sign is NaN.

The sum of two infinities of the same sign is the infinity of that sign.

The sum of an infinity and a finite value is equal to the infinite operand.

The sum of two negative zeroes is −0. The sum of two positive zeroes, or of two zeroes of opposite sign, is +0.

The sum of a zero and a nonzero finite value is equal to the nonzero operand.

The sum of two nonzero finite values of the same magnitude and opposite sign is +0.

In the remaining cases, where neither an infinity, nor a zero, nor NaN is involved, and the operands have the same sign or have different magnitudes, the sum is computed and rounded to the nearest representable value using IEEE 754 round-to-nearest mode. If the magnitude is too large to represent, the operation overflows and the result is then an infinity of appropriate sign. The ECMAScript language requires support of gradual underflow as defined by IEEE 754.</p>

<div>The - operator performs subtraction when applied to two operands of numeric type, producing the difference of its operands; the left operand is the minuend and the right operand is the subtrahend. Given numeric operands a and b, it is always the case that a–b produces the same result as a +(–b).</div>
<div>The - operator performs subtraction when applied to two operands of numeric type, producing the difference of its operands; the left operand is the minuend and the right operand is the subtrahend. Given numeric operands a and b, it is always the case that a–b produces the same result as a +(–b).</div>

<h4>位运算移位运算符</h4>


<p>语法：</p>

<pre>   ShiftExpression :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineAdditiveExpression">AdditiveExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineShiftExpression">ShiftExpression</a> << <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineAdditiveExpression">AdditiveExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineShiftExpression">ShiftExpression</a> >> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineAdditiveExpression">AdditiveExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineShiftExpression">ShiftExpression</a> >>> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineAdditiveExpression">AdditiveExpression</a></pre>

<h5>左移运算符</h5>

<p>Performs a bitwise left shift operation on the left operand by the amount specified by the right operand.</p>

<p>产生式 <i>ShiftExpression</i> <b>:</b> <i>ShiftExpression</i> <b><<</b> <i>AdditiveExpression</i> 按照下面的过程执行 :</p>

<ol>
  <li>令 lref 为解释执行 ShiftExpression 的结果 . </li>

  <li>令 lval 为 GetValue(lref). </li>

  <li>令 rref 为解释执行 AdditiveExpression 的结果 . </li>

  <li>令 rval 为 GetValue(rref). </li>

  <li>令 lnum 为 ToInt32(lval). </li>

  <li>令 rnum 为 ToUint32(rval). </li>

  <li>令 shiftCount 为用掩码算出 rnum 的最后五个比特位 , 即计算 rnum & 0x1F 的结果。 </li>

  <li>返回 lnum 左移 shiftCount 比特位的结果。结果是一个有符号 32 位整数。</li>
</ol>

<h5>带符号右移运算符</h5>
<p>filling bitwise right shift operation on the left operand by the amount specified by the right operand.</p>

<p>产生式 <i>ShiftExpression</i> <b>:</b> <i>ShiftExpression</i> <b>>></b> <i>AdditiveExpression</i> 按照下面的过程执行 :</p>

<ol>
  <li>令 lref 为解释执行 ShiftExpression 的结果 . </li>

  <li>令 lval 为 GetValue(lref). </li>

  <li>令 rref 为解释执行 AdditiveExpression 的结果 . </li>

  <li>令 rval 为 GetValue(rref). </li>

  <li>令 lnum 为 ToInt32(lval). </li>

  <li>令 rnum 为 ToUint32(rval). </li>

  <li>令 shiftCount 为用掩码算出 rnum 的最后五个比特位 , 即计算 rnum & 0x1F 的结果。 </li>

  <li>返回 lnum 带符号扩展的右  移 shiftCount 比特位的结果 . The most significant bit is propagated. 结果是一个有符号 32 位整数。</li>
</ol>



<h5>无符号右移运算符</h5>

<p>Performs a zero-filling bitwise right shift operation on the left operand by the amount specified by the right operand.</p>

<p>产生式 <i>ShiftExpression</i> <b>:</b> <i>ShiftExpression</i> <b>>>></b> <i>AdditiveExpression</i> 按照下面的过程执行 :</p>

<ol>
  <li>令 lref 为解释执行 ShiftExpression 的结果 . </li>

  <li>令 lval 为 GetValue(lref). </li>

  <li>令 rref 为解释执行 AdditiveExpression 的结果 . </li>

  <li>令 rval 为 GetValue(rref). </li>

  <li>令 lnum 为 ToUint32(lval). </li>

  <li>令 rnum 为 ToUint32(rval). </li>

  <li>令 shiftCount 为用掩码算出 rnum 的最后五个比特位 , 即计算 rnum & 0x1F 的结果。 </li>

  <li>返回 lnum 做 0 填充右移 shiftCount 比特位的结果 . 缺少的比特位填 0。 结果是一个无符号 32 位整数 .</li>
</ol>


<h4>比较运算符</h4>

<p>语法：</p>

<pre>   RelationalExpression :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineShiftExpression">ShiftExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineRelationalExpression">RelationalExpression</a> < <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineShiftExpression">ShiftExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineRelationalExpression">RelationalExpression</a> > <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineShiftExpression">ShiftExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineRelationalExpression">RelationalExpression</a> <= <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineShiftExpression">ShiftExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineRelationalExpression">RelationalExpression</a> >= <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineShiftExpression">ShiftExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineRelationalExpression">RelationalExpression</a> instanceof <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineShiftExpression">ShiftExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineRelationalExpression">RelationalExpression</a> in <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineShiftExpression">ShiftExpression</a></pre>

<pre>   RelationalExpressionNoIn :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineShiftExpression">ShiftExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineRelationalExpressionNoIn">RelationalExpressionNoIn</a> < <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineShiftExpression">ShiftExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineRelationalExpressionNoIn">RelationalExpressionNoIn</a> > <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineShiftExpression">ShiftExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineRelationalExpressionNoIn">RelationalExpressionNoIn</a> <= <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineShiftExpression">ShiftExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineRelationalExpressionNoIn">RelationalExpressionNoIn</a> >= <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineShiftExpression">ShiftExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineRelationalExpressionNoIn">RelationalExpressionNoIn</a> instanceof <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineShiftExpression">ShiftExpression</a></pre>
<div>NOTE The “NoIn” variants are needed to avoid confusing the in operator in a relational expression with the in operator in a for statement.</div>
<p>语义：</p>

<p>The result of evaluating a relational operator is always of type Boolean, reflecting whether the relationship named by the operator holds between its two operands.
</p>
<p>The RelationalExpressionNoIn productions are evaluated in the same manner as the RelationalExpression productions except that the contained RelationalExpressionNoIn is evaluated instead of the contained RelationalExpression.
</p>
<h5>The Less-than Operator ( &lt; )</h5>

<p>产生式 <i>RelationalExpression</i> <b>:</b> <i>RelationalExpression</i> <b><</b> <i>ShiftExpression</i> 按照下面的过程执行 :</p>

<ol>
  <li>令 lref 为解释执行 RelationalExpression 的结果 . </li>

  <li>令 lval 为 GetValue(lref). </li>

  <li>令 rref 为解释执行 ShiftExpression 的结果 . </li>

  <li>令 rval 为 GetValue(rref). </li>

  <li>令 r 为作用关系比较算法 lval < rval( 参见 11.8.5) 的结果 </li>

  <li>如果 r 为 undefined，返回 false. 否则 , 返回 r.</li>
</ol>

<h5>The Greater-than Operator ( &gt; )</h5>

<p>产生式 RelationalExpression <b>:</b> <i>RelationalExpression</i> <b>></b> <i>ShiftExpression</i> 按照下面的过程执行 :</p>

<ol>
  <li>令 lref 为解释执行 RelationalExpression 的结果 . </li>

  <li>令 lval 为 GetValue(lref). </li>

  <li>令 rref 为解释执行 ShiftExpression 的结果 . </li>

  <li>令 rval 为 GetValue(rref). </li>

  <li>令 r 为为作用关系比较算法 lval < rval( 参见 11.8.5) 的结果，参数 LeftFirst 设为 false </li>

  <li>如果 r 为 undefined，返回 false. 否则 , 返回 r.</li>
</ol>

<h5>The Less-than-or-equal Operator ( &lt;= )</h5>

<p>产生式 RelationalExpression <b>:</b> <i>RelationalExpression</i> <b><=</b> <i>ShiftExpression</i> 按照下面的过程执行 :</p>

<ol>
  <li>令 lref 为解释执行 RelationalExpression 的结果 . </li>

  <li>令 lval 为 GetValue(lref). </li>

  <li>令 rref 为解释执行 ShiftExpression 的结果 . </li>

  <li>令 rval 为 GetValue(rref). </li>

  <li>令 r 为为作用关系比较算法 rval < lval( 参见 11.8.5) 的结果，参数 LeftFirst 设为 false </li>

  <li>如果 r 为 true 或者 undefined ，返回 false. 否则 , 返回 true.</li>
</ol>


<h5>The Greater-than-or-equal Operator ( &gt;= )</h5>

<p>产生式 RelationalExpression <b>:</b> <i>RelationalExpression</i> <b>>=</b> <i>ShiftExpression</i> 按照下面的过程执行 :</p>

<ol>
  <li>令 lref 为解释执行 RelationalExpression 的结果 . </li>

  <li>令 lval 为 GetValue(lref). </li>

  <li>令 rref 为解释执行 ShiftExpression 的结果 . </li>

  <li>令 rval 为 GetValue(rref). </li>

  <li>令 r 为作用关系比较算法 lval < rval( 参见 11.8.5) 的结果 </li>

  <li>如果 r 为 true 或者 undefined ，返回 false. 否则 , 返回 true.</li>
</ol>

<p>抽象关系比较算法（上文译为作用关系比较算法，此处为 11.8.5）</p>

<p>以 x 和 y 为值进行小于比较（x<y 的比较），会产生的结果可为 <b>true</b>，<b>false</b> 或 <b>undefined</b>（这说明 x、y 中最少有一个操作数是 NaN）。除了 x 和 y，这个算法另外需要一个名为 LeftFirst 的布尔值标记作为参数。这个标记用于解析顺序的控制，因为操作数 x 和 y 在执行的时候会有潜在可见的副作用。LeftFirst 标志是必须的，因为 ECMAScript 规定了表达式是从左到右顺序执行的。LeftFirst 的默认值是 true，这表明在相关的表达式中，参数 x 出现在参数 y 之前。如果 LeftFirst 值是 <b>false</b>，情况会相反，操作数的执行必须是先 y 后 x。这样的一个小于比较的执行步骤如下：</p>

<ol>
  <li>如果 LeftFirst 标志是 <b>true</b>，那么 

    <ol>
      <li>让 px 为调用 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=ToPrimitive&action=edit&redlink=1">ToPrimitive</a>(x, hint Number) 的结果。 </li>

      <li>让 py 为调用 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=ToPrimitive&action=edit&redlink=1">ToPrimitive</a>(y, hint Number) 的结果。</li>
    </ol>
  </li>

  <li>否则解释执行的顺序需要反转，从而保证从左到右的执行顺序 
    <ol>
      <li>让 py 为调用 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=ToPrimitive&action=edit&redlink=1">ToPrimitive</a>(y, hint Number) 的结果。 </li>

      <li>让 px 为调用 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=ToPrimitive&action=edit&redlink=1">ToPrimitive</a>(x, hint Number) 的结果。</li>
    </ol>
  </li>

  <li>如果 Type(px) 和 Type(py) 得到的结果不都是 String 类型，那么 
    <ol>
      <li>让 nx 为调用 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=ToNumber&action=edit&redlink=1">ToNumber</a>(px) 的结果。因为 px 和 py 都已经是基本数据类型（primitive values 也作原始值），其执行顺序并不重要。 </li>

      <li>让 ny 为调用 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=ToNumber&action=edit&redlink=1">ToNumber</a>(py) 的结果。 </li>

      <li>如果 nx 是 NaN，返回 <b>undefined</b></li>

      <li>如果 ny 是 NaN，返回 <b>undefined</b></li>

      <li>如果 nx 和 ny 的数字值相同，返回 <b>false</b></li>

      <li>如果 nx 是 +0 且 ny 是 -0，返回 <b>flase</b></li>

      <li>如果 nx 是 -0 且 ny 是 +0，返回 <b>false</b></li>

      <li>如果 nx 是 +∞，返回 <b>fasle</b></li>

      <li>如果 ny 是 +∞，返回 <b>true</b></li>

      <li>如果 ny 是 -∞，返回 <b>flase</b></li>

      <li>如果 nx 是 -∞，返回 <b>true</b></li>

      <li>如果 nx 数学上的值小于 ny 数学上的值（注意这些数学值都不能是无限的且不能都为 0），返回 <b>ture</b>。否则返回 <b>false</b>。</li>
    </ol>
  </li>

  <li>否则，px 和 py 都是 Strings 类型 
    <ol>
      <li>如果 py 是 px 的一个前缀，返回 <b>false</b>。（当字符串 q 的值可以是字符串 p 和一个其他的字符串 r 拼接而成时，字符串 p 就是 q 的前缀。注意：任何字符串都是自己的前缀，因为 r 可能是空字符串。） </li>

      <li>如果 px 是 py 的前缀，返回 <b>true</b>。 </li>

      <li>让 k 成为最小的非负整数，能使得在 px 字符串中位置 k 的字符与字符串 py 字符串中位置 k 的字符不相同。（这里必须有一个 k，使得互相都不是对方的前缀） </li>

      <li>让 m 成为字符串 px 中位置 k 的字符的编码单元值。 </li>

      <li>让 n 成为字符串 py 中位置 k 的字符的编码单元值。 </li>

      <li>如果 n<m，返回 <b>true</b>。否则，返回 <b>false</b>。</li>
    </ol>
  </li>
</ol>

<p>注： 使用或代替的时候要注意，这里的步骤 3 和加号操作符 + 算法 (11.6.1) 的步骤 7 的区别。</p>

<p>注： String 类型的比较使用了其编码单元值的作为一个简单的词法表序列去比较。这里不打算使用更复杂的、语义化的字符或字符串序列，和 Unicode 规范的整理序列进行比较。因此，字符串的值和其对应的 Unicode 标准的值是不相同的。实际上，这个算法假定了所有字符串已经是正常化的格式。同时要注意，对于字符串拼接追加的字符的时候，UTF-16 编码单元值的词法表序列是不同于代码点值的序列的。</p>

<h5>The instanceof operator</h5>

<p>产生式 <i>RelationalExpression</i><b>:</b> <i>RelationalExpression</i> <b>instanceof</b> <i>ShiftExpression</i> 按照下面的过程执行 :</p>

<ol>
  <li>令 lref 为解释执行 RelationalExpression 的结果 . </li>

  <li>令 lval 为 GetValue(lref). </li>

  <li>令 rref 为解释执行 ShiftExpression 的结果 . </li>

  <li>令 rval 为 GetValue(rref). </li>

  <li>如果 Type(rval) 不是 Object，抛出一个 TypeError 异常 . </li>

  <li>如果 rval 没有 [[HasInstance]] 内置方法，抛出一个 TypeError 异常 . </li>

  <li>返回以参数 lval. 调用 rval 的 [[HasInstance]] 内置方法的结果</li>
</ol>

<h5>The in operator</h5>

<p>产生式 <i>RelationalExpression</i> <b>:</b> <i>RelationalExpression</i> <b>in</b> <i>ShiftExpression</i> 按照下面的过程执行 :</p>

<ol>
  <li>令 lref 为解释执行 RelationalExpression 的结果 . </li>

  <li>令 lval 为 GetValue(lref). </li>

  <li>令 rref 为解释执行 ShiftExpression 的结果 . </li>

  <li>令 rval 为 GetValue(rref). </li>

  <li>如果 Type(rval) 不是 Object ，抛出一个 TypeError 异常 . </li>

  <li>返回以参数 ToString(lval). 调用 rval 的 [[HasProperty]] 内置方法的结果</li>
</ol>


<h4>等值运算符</h4>

<p>语法：</p>

<pre>   EqualityExpression :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineRelationalExpression">RelationalExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineEqualityExpression">EqualityExpression</a> == <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineRelationalExpression">RelationalExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineEqualityExpression">EqualityExpression</a> != <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineRelationalExpression">RelationalExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineEqualityExpression">EqualityExpression</a> === <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineRelationalExpression">RelationalExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineEqualityExpression">EqualityExpression</a> !== <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineRelationalExpression">RelationalExpression</a></pre>

<pre>   EqualityExpressionNoIn :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineRelationalExpressionNoIn">RelationalExpressionNoIn</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineEqualityExpressionNoIn">EqualityExpressionNoIn</a> == <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineRelationalExpressionNoIn">RelationalExpressionNoIn</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineEqualityExpressionNoIn">EqualityExpressionNoIn</a> != <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineRelationalExpressionNoIn">RelationalExpressionNoIn</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineEqualityExpressionNoIn">EqualityExpressionNoIn</a> === <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineRelationalExpressionNoIn">RelationalExpressionNoIn</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineEqualityExpressionNoIn">EqualityExpressionNoIn</a> !== <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineRelationalExpressionNoIn">RelationalExpressionNoIn</a></pre>

<p>语义：</p>

<p>The result of evaluating an equality operator is always of type Boolean, reflecting whether the relationship named by the operator holds between its two operands.
</p>
<p>The EqualityExpressionNoIn productions are evaluated in the same manner as the EqualityExpression productions except that the contained EqualityExpressionNoIn and RelationalExpressionNoIn are evaluated instead of the contained EqualityExpression and RelationalExpression, respectively.
</p>
<h5>The Equals Operator ( == )</h5>

<p>产生式 EqualityExpression : <i>EqualityExpression</i> <b>==</b> <i>RelationalExpression</i> 按照下面的过程执行 :</p>

<ol>
  <li>令 lref 为解释执行 EqualityExpression 的结果 . </li>

  <li>令 lval 为 GetValue(lref). </li>

  <li>令 rref 为解释执行 RelationalExpression 的结果 . </li>

  <li>令 rval 为 GetValue(rref). </li>

  <li>返回做用相等比较算法于 rval == lval( 参见 11.9.3) 的结果</li>
</ol>

<h5>The Does-not-equals Operator ( != )</h5>

<p>产生式 EqualityExpression <b>:</b> <i>EqualityExpression</i> <b>!=</b> <i>RelationalExpression</i> 按照下面的过程执行 :</p>

<ol>
  <li>令 lref 为解释执行 EqualityExpression 的结果 . </li>

  <li>令 lval 为 GetValue(lref). </li>

  <li>令 rref 为解释执行 RelationalExpression 的结果 . </li>

  <li>令 rval 为 GetValue(rref). </li>

  <li>令 r 为做用相等比较算法于 rval == lval( 参见 11.9.3) 的结果 </li>

  <li>如果 r 为 true，返回 false. 否则 , 返回 true.</li>
</ol>

<h1><span class="secnum"><a href="#sec-11.9.3" title="link to this section">11.9.3</a></span> The Abstract Equality
Comparison Algorithm</h1>
<p>The comparison <var>x</var> == <var>y</var>, where <var>x</var> and <var>y</var> are values, produces <b>true</b> or
<b>false</b>. Such a comparison is performed as follows:</p>
<ol class="proc">
<li>If <a href="#sec-8">Type</a>(<i>x</i>) is the same as <a href="#sec-8">Type</a>(<i>y</i>), then
<ol class="block">
<li>If <a href="#sec-8">Type</a>(<i>x</i>) is Undefined, return <b>true</b>.</li>
<li>If <a href="#sec-8">Type</a>(<i>x</i>) is Null, return <b>true</b>.</li>
<li>If <a href="#sec-8">Type</a>(<i>x</i>) is Number, then
<ol class="block">
<li>If <i>x</i> is <b>NaN</b>, return <b>false</b>.</li>
<li>If <i>y</i> is <b>NaN</b>, return <b>false</b>.</li>
<li>If <i>x</i> is the same Number value as <i>y</i>, return <b>true</b>.</li>
<li>If <i>x</i> is <b>+0</b> and <i>y</i> is <b>−0</b>, return <b>true</b>.</li>
<li>If <i>x</i> is <b>−0</b> and <i>y</i> is <b>+0</b>, return <b>true</b>.</li>
<li>Return <b>false</b>.</li>
</ol>
</li>
<li>If <a href="#sec-8">Type</a>(<i>x</i>) is String, then return <b>true</b> if <i>x</i> and <i>y</i> are exactly the
same sequence of characters (same length and same characters in corresponding positions). Otherwise, return
<b>false</b>.</li>
<li>If <a href="#sec-8">Type</a>(<i>x</i>) is Boolean, return <b>true</b> if <i>x</i> and <i>y</i> are both
<b>true</b> or both <b>false</b>. Otherwise, return <b>false</b>.</li>
<li>Return <b>true</b> if <i>x</i> and <i>y</i> refer to the same object. Otherwise, return <b>false</b>.</li>
</ol>
</li>
<li>If <i>x</i> is <b>null</b> and <i>y</i> is <b>undefined</b>, return <b>true</b>.</li>
<li>If <i>x</i> is <b>undefined</b> and <i>y</i> is <b>null</b>, return <b>true</b>.</li>
<li>If <a href="#sec-8">Type</a>(<i>x</i>) is Number and <a href="#sec-8">Type</a>(<i>y</i>) is String,<br>return the
result of the comparison <i>x</i> == <a href="#sec-9.3">ToNumber</a>(<i>y</i>).</li>
<li>If <a href="#sec-8">Type</a>(<i>x</i>) is String and <a href="#sec-8">Type</a>(<i>y</i>) is Number,<br>return the
result of the comparison <a href="#sec-9.3">ToNumber</a>(<i>x</i>) == <i>y</i>.</li>
<li>If <a href="#sec-8">Type</a>(<i>x</i>) is Boolean, return the result of the comparison <a href="#sec-9.3">ToNumber</a>(<i>x</i>) == <i>y</i>.</li>
<li>If <a href="#sec-8">Type</a>(<i>y</i>) is Boolean, return the result of the comparison <i>x</i> == <a href="#sec-9.3">ToNumber</a>(<i>y</i>).</li>
<li>If <a href="#sec-8">Type</a>(<i>x</i>) is either String or Number and <a href="#sec-8">Type</a>(<i>y</i>) is
Object,<br>return the result of the comparison <i>x</i> == <a href="#sec-9.1">ToPrimitive</a>(<i>y</i>).</li>
<li>If <a href="#sec-8">Type</a>(<i>x</i>) is Object and <a href="#sec-8">Type</a>(<i>y</i>) is either String or
Number,<br>return the result of the comparison <a href="#sec-9.1">ToPrimitive</a>(<i>x</i>) == <i>y</i>.</li>
<li>Return <b>false</b>.</li>
</ol>
<div class="note">
<p><span class="nh">NOTE 1</span> Given the above definition of equality:</p>
</div>
<ul>
<li>String comparison can be forced by: <code>"" + a == "" + b</code>.</li>
<li>Numeric comparison can be forced by: <code>+a == +b</code>.</li>
<li>Boolean comparison can be forced by: <code>!a == !b</code>.</li>
</ul>
<div class="note">
<p><span class="nh">NOTE 2</span> The equality operators maintain the following invariants:</p>
</div>
<ul>
<li><code>A</code> <code>!=</code> <code>B</code> is equivalent to <code>!(A</code> <code>==</code> <code>B)</code>.</li>
<li><code>A</code> <code>==</code> <code>B</code> is equivalent to <code>B</code> <code>==</code> <code>A</code>, except
in the order of evaluation of <code>A</code> and <code>B</code>.</li>
</ul>
<div class="note">
<p><span class="nh">NOTE 3</span> The equality operator is not always transitive. For example, there might be two distinct
String objects, each representing the same String value; each String object would be considered equal to the String value
by the <code>==</code> operator, but the two String objects would not be equal to each other. For Example:</p>
</div>
<ul>
<li><code>new String("a")</code> <code>==</code> <code>"a"</code> and <code>"a"</code> <code>==</code> <code>new
String("a")</code>are both <b>true</b>.</li>
<li><code>new String("a")</code> <code>==</code> <code>new String("a")</code> is <b>false</b>.</li>
</ul>
<div class="note">
<p><span class="nh">NOTE 4</span> Comparison of Strings uses a simple equality test on sequences of code unit values.
There is no attempt to use the more complex, semantically oriented definitions of character or string equality and
collating order defined in the Unicode specification. Therefore Strings values that are canonically equal according to the
Unicode standard could test as unequal. In effect this algorithm assumes that both Strings are already in normalised
form.</p>
</div>

<h5>The Strict Equals Operator ( === )</h5>

<p>产生式 EqualityExpression<b> :</b> <i>EqualityExpression</i> <b>===</b> <i>RelationalExpression</i> 按照下面的过程执行 :</p>

<ol>
  <li>令 lref 为解释执行 EqualityExpression 的结果 . </li>

  <li>令 lval 为 GetValue(lref). </li>

  <li>令 rref 为解释执行 RelationalExpression 的结果 . </li>

  <li>令 rval 为 GetValue(rref). </li>

  <li>返回做用严格相等比较算法于 rval === lval( 参见 11.9.6) 的结果</li>
</ol>

<h5> The Strict Does-not-equal Operator ( !== )</h5>

<p>产生式 EqualityExpression <b>:</b> <i>EqualityExpression</i> <b>!==</b> <i>RelationalExpression</i> 按照下面的过程执行 :</p>

<ol>
  <li>令 lref 为解释执行 EqualityExpression 的结果 . </li>

  <li>令 lval 为 GetValue(lref). </li>

  <li>令 rref 为解释执行 RelationalExpression 的结果 . </li>

  <li>令 rval 为 GetValue(rref). </li>

  <li>令 r 为做用严格相等比较算法于 rval === lval( 参见 11.9.6) 的结果 </li>

  <li>如果 r 为 true，返回 false. 否则 , 返回 true.</li>
</ol>


<h5>严格等于比较算法</h5>

<p>比较 <var>x</var>===<var>y</var>，<var>x</var> 和 <var>y</var> 为值，需要产出 <b>true</b> 或 <b>false</b>。比较过程如下：</p>

<ol>
  <li>如果 <code><a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#type">Type(<var>x</var>)</a></code> 与 <code><a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#type">Type(<var>y</var>)</a></code> 的结果不一致，返回 <b>false</b>，否则 </li>

  <li>如果 <code><a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#type">Type(<var>x</var>)</a></code> 结果为 Undefined，返回 <b>true</b></li>

  <li>如果 <code><a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#type">Type(<var>x</var>)</a></code> 结果为 Null，返回 <b>true</b></li>

  <li>如果 <code><a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#type">Type(<var>x</var>)</a></code> 结果为 Number，则 

    <ol>
      <li>如果 <var>x</var> 为 <b>NaN</b>，返回 <b>false</b></li>

      <li>如果 <var>y</var> 为 <b>NaN</b>，返回 <b>false</b></li>

      <li>如果 <var>x</var> 与 <var>y</var> 为同一个数字，返回 <b>true</b></li>

      <li>如果 <var>x</var> 为 <b>+0</b>，<var>y</var> 为 <b>-0</b>，返回 <b>true</b></li>

      <li>如果 <var>x</var> 为 <b>-0</b>，<var>y</var> 为 <b>+0</b>，返回 <b>true</b></li>

      <li>返回 <b>false</b></li>
    </ol>
  </li>

  <li>如果 <code><a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#type">Type(<var>x</var>)</a></code> 结果为 String，如果 <var>x</var> 与 <var>y</var> 为完全相同的字符序列（相同的长度和相同的字符对应相同的位置），返回 <b>true</b>，否则，返回 <b>false</b></li>

  <li>如果 <code><a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#type">Type(<var>x</var>)</a></code> 结果为 Boolean，如果 <var>x</var> 与 <var>y</var> 都为 <b>true</b> 或 <b>false</b>，则返回 <b>true</b>，否则，返回 <b>false</b></li>

  <li>如果 <var>x</var> 和 <var>y</var> 引用到同一个 Object 对象，返回 <b>true</b>，否则，返回 <b>false</b></li>
</ol>

<p>注： 此算法与 <code><a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#samevalue">SameValue</a></code> 算法在对待有符号的零和 NaN 上表现不同。</p>



<h4>二进制位运算符</h4>

<p>语法：</p>

<pre>   BitwiseANDExpression :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineEqualityExpression">EqualityExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineBitwiseANDExpression">BitwiseANDExpression</a> & <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineEqualityExpression">EqualityExpression</a></pre>

<pre>   BitwiseANDExpressionNoIn :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineEqualityExpressionNoIn">EqualityExpressionNoIn</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineBitwiseANDExpressionNoIn">BitwiseANDExpressionNoIn</a> & <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineEqualityExpressionNoIn">EqualityExpressionNoIn</a></pre>

<pre>   BitwiseXORExpression :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineBitwiseANDExpression">BitwiseANDExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineBitwiseXORExpression">BitwiseXORExpression</a> ^ <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineBitwiseANDExpression">BitwiseANDExpression</a></pre>

<pre>   BitwiseXORExpressionNoIn :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineBitwiseANDExpressionNoIn">BitwiseANDExpressionNoIn</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineBitwiseXORExpressionNoIn">BitwiseXORExpressionNoIn</a> ^ <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineBitwiseANDExpressionNoIn">BitwiseANDExpressionNoIn</a></pre>

<pre>   BitwiseORExpression :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineBitwiseXORExpression">BitwiseXORExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineBitwiseORExpression">BitwiseORExpression</a> | <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineBitwiseXORExpression">BitwiseXORExpression</a></pre>

<pre>   BitwiseORExpressionNoIn :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineBitwiseXORExpressionNoIn">BitwiseXORExpressionNoIn</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineBitwiseORExpressionNoIn">BitwiseORExpressionNoIn</a> | <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineBitwiseXORExpressionNoIn">BitwiseXORExpressionNoIn</a></pre>

<p>语义：</p>

<p>产生式 <i>A </i><b>:</b> <i>A'<b> @ '</b>B</i>, where @ is one of the bitwise operators in the productions above, 按照下面的过程执行 :</p>

<ol>
  <li>令 lref 为解释执行 A 的结果 . </li>

  <li>令 lval 为 GetValue(lref). </li>

  <li>令 rref 为解释执行 B 的结果 . </li>

  <li>令 rval 为 GetValue(rref). </li>

  <li>令 lnum 为 ToInt32(lval). </li>

  <li>令 rnum 为 ToInt32(rval). </li>

  <li>返回作用位运算符 @ 到 lnum 和 rnum. 结果是 32 位有符号整数。</li>
</ol>


<h4>二进制逻辑运算符</h4>

<p>语法：</p>

<pre>   LogicalANDExpression :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineBitwiseORExpression">BitwiseORExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineLogicalANDExpression">LogicalANDExpression</a> && <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineBitwiseORExpression">BitwiseORExpression</a></pre>

<pre>   LogicalANDExpressionNoIn :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineBitwiseORExpressionNoIn">BitwiseORExpressionNoIn</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineLogicalANDExpressionNoIn">LogicalANDExpressionNoIn</a> && <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineBitwiseORExpressionNoIn">BitwiseORExpressionNoIn</a></pre>

<pre>   LogicalORExpression :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineLogicalANDExpression">LogicalANDExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineLogicalORExpression">LogicalORExpression</a> || <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineLogicalANDExpression">LogicalANDExpression</a></pre>

<pre>   LogicalORExpressionNoIn :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineLogicalANDExpressionNoIn">LogicalANDExpressionNoIn</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineLogicalORExpressionNoIn">LogicalORExpressionNoIn</a> || <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineLogicalANDExpressionNoIn">LogicalANDExpressionNoIn</a></pre>
<h4>语义</h4>



<p>产生式 <i>LogicalANDExpression</i> <b>:</b> <i>LogicalANDExpression</i> <b>&&</b> <i>BitwiseORExpression</i> 按照下面的过程执行 :</p>

<ol>
  <li>令 lref 为解释执行 LogicalANDExpression 的结果 . </li>

  <li>令 lval 为 GetValue(lref). </li>

  <li>如果 ToBoolean(lval) 为 false ，返回 lval. </li>

  <li>令 rref 为解释执行 BitwiseORExpression 的结果 . </li>

  <li>返回 GetValue(rref).</li>
</ol>

<p>产生式 <i>LogicalORExpression</i> <b>:</b> <i>LogicalORExpression</i> <b>||</b> <i>LogicalANDExpression</i> 按照下面的过程执行 :</p>

<ol>
  <li>令 lref 为解释执行 LogicalORExpression 的结果 . </li>

  <li>令 lval 为 GetValue(lref). </li>

  <li>如果 ToBoolean(lval) 为 true ，返回 lval. </li>

  <li>令 rref 为解释执行 LogicalANDExpression 的结果 . </li>

  <li>返回 GetValue(rref).</li>
</ol>
<p>
The LogicalANDExpressionNoIn and LogicalORExpressionNoIn productions are evaluated in the same manner as the LogicalANDExpression and LogicalORExpression productions except that the contained LogicalANDExpressionNoIn, BitwiseORExpressionNoIn and LogicalORExpressionNoIn are evaluated instead of the contained LogicalANDExpression, BitwiseORExpression and LogicalORExpression, respectively.
</p>
<p>
NOTE The value produced by a && or || operator is not necessarily of type Boolean. The value produced will always be the value of one of the two operand expressions.
</p>
<h4>条件运算符</h4>

<p>语法：</p>

<pre>   ConditionalExpression :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineLogicalORExpression">LogicalORExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineLogicalORExpression">LogicalORExpression</a> ? <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineAssignmentExpression">AssignmentExpression</a> : <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineAssignmentExpression">AssignmentExpression</a></pre>

<pre>   ConditionalExpressionNoIn :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineLogicalORExpressionNoIn">LogicalORExpressionNoIn</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineLogicalORExpressionNoIn">LogicalORExpressionNoIn</a> ? <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineAssignmentExpressionNoIn">AssignmentExpressionNoIn</a> : <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineAssignmentExpressionNoIn">AssignmentExpressionNoIn</a></pre>

<p>语义</p>
<p>产生式 <i>ConditionalExpression</i> <b>:</b> <i>LogicalORExpression</i> <b>?</b> <i>AssignmentExpression</i> <b>:</b> <i>AssignmentExpression</i> 按照下面的过程执行 :</p>

<ol>
  <li>令 lref 为解释执行 LogicalORExpression 的结果 . </li>

  <li>如果 ToBoolean(GetValue(lref)) 为 true ，那么： 令 trueRef 为解释执行第一个 AssignmentExpression 的结果 . 返回 GetValue(trueRef). </li>

  <li>Else 令 falseRef 为解释执行第二个 AssignmentExpression 的结果 . 返回 GetValue(falseRef).</li>
</ol>

<p>The ConditionalExpressionNoIn production is evaluated in the same manner as the ConditionalExpression production except that the contained LogicalORExpressionNoIn, AssignmentExpression and AssignmentExpressionNoIn are evaluated instead of the contained LogicalORExpression, first AssignmentExpression and second AssignmentExpression, respectively.
</p><p>
NOTE The grammar for a ConditionalExpression in ECMAScript is a little bit different from that in C and Java, which each allow the second subexpression to be an Expression but restrict the third expression to be a ConditionalExpression. The motivation for this difference in ECMAScript is to allow an assignment expression to be governed by either arm of a conditional and to eliminate the confusing and fairly useless case of a comma expression as the centre expression.</p>

<h4>赋值运算符</h4>

<p>语法：</p>

<pre>   AssignmentExpression :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineConditionalExpression">ConditionalExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineLeftHandSideExpression">LeftHandSideExpression</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineAssignmentOperator">AssignmentOperator</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineAssignmentExpression">AssignmentExpression</a></pre>

<pre>   AssignmentExpressionNoIn :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineConditionalExpressionNoIn">ConditionalExpressionNoIn</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineLeftHandSideExpression">LeftHandSideExpression</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineAssignmentOperator">AssignmentOperator</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineAssignmentExpressionNoIn">AssignmentExpressionNoIn</a></pre>

<pre>   AssignmentOperator : 以下之一 
       = *= /= %= += -= <<= >>= >>>= &= ^= |= </pre>

<h4>Semantics</h4>

<p>The AssignmentExpressionNoIn productions are evaluated in the same manner as the AssignmentExpression productions except that the contained ConditionalExpressionNoIn and AssignmentExpressionNoIn are evaluated instead of the contained ConditionalExpression and AssignmentExpression, respectively.
</p>
<h5>简单赋值</h5>

<p>产生式 <i>AssignmentExpression</i> <b>:</b> <i>LeftHandSideExpression</i> <b>=</b> <i>AssignmentExpression</i> 按照下面的过程执行 :</p>

<ol>
  <li>令 lref 为解释执行 LeftH 和 SideExpression 的结果 . </li>

  <li>令 rref 为解释执行 AssignmentExpression 的结果 . </li>

  <li>令 rval 为 GetValue(rref). </li>

  <li>抛出一个 SyntaxError 异常，当以下条件都成立 : 
    <ul>
      <li>Type(lref) 为 Reference </li>

      <li>IsStrictReference(lref) 为 true </li>

      <li>Type(GetBase(lref)) 为环境记录项 </li>

      <li>GetReferencedName(lref) 为 "eval" 或 "arguments"</li>
    </ul>
  </li>

  <li>调用 PutValue(lref, rval). </li>

  <li>返回 rval.</li>
</ol>

<div>
NOTE When an assignment occurs within strict mode code, its LeftHandSide must not evaluate to an unresolvable reference. If it does a ReferenceError exception is thrown upon assignment. The LeftHandSide also may not be a reference to a data property with the attribute value {[[Writable]]:false}, to an accessor property with the attribute value {[[Set]]:undefined}, nor to a non-existent property of an object whose [[Extensible]] internal property has the value false. In these cases a TypeError exception is thrown.
</div>

<h5>组合赋值</h5>

<p>产生式 <i>AssignmentExpression</i> <b>:</b> <i>LeftHandSideExpression'<b>@ </b></i>=<b> <i>AssignmentExpression</i>, where @ represents one of the operators indicated above, 按照下面的过程执行 :</b></p>

<ol>
  <li>令 lref 为解释执行 LeftH 和 SideExpression 的结果 . </li>

  <li>令 lval 为 GetValue(lref). </li>

  <li>令 rref 为解释执行 AssignmentExpression 的结果 . </li>

  <li>令 rval 为 GetValue(rref). </li>

  <li>令 r 为作用运算符 @ 于 lval 和 rval 的结果。 </li>

  <li>抛出一个 SyntaxError 异常，当以下条件全部成立： 
    <ul>
      <li>Type(lref) 为 Reference </li>

      <li>IsStrictReference(lref) 为 true </li>

      <li>Type(GetBase(lref)) 为环境记录项 </li>

      <li>GetReferencedName(lref) 为 "eval" 或 "arguments"</li>
    </ul>
  </li>

  <li>调用 PutValue(lref, r). </li>

  <li>返回 r.</li>
</ol>
<div>NOTE See NOTE 11.13.1.</div>

<h4>逗号运算符</h4>

<p>语法：</p>

<pre>   Expression :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineAssignmentExpression">AssignmentExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineExpression">Expression</a> , <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineAssignmentExpression">AssignmentExpression</a></pre>

<pre>   ExpressionNoIn :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineAssignmentExpressionNoIn">AssignmentExpressionNoIn</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineExpressionNoIn">ExpressionNoIn</a> , <a href="http://www.w3.org/html/ig/zh/wiki/ES5/表达式#inlineAssignmentExpressionNoIn">AssignmentExpressionNoIn</a></pre>

<p>语义：</p>

<p>产生式 <i>Expression</i> <b>:</b> <i>Expression</i> <b>,</b> <i>AssignmentExpression</i> 按照下面的过程执行 :</p>

<ol>
  <li>令 lref 为解释执行 Expression 的结果 . </li>

  <li>Call GetValue(lref). </li>

  <li>令 rref 为解释执行 AssignmentExpression 的结果 . </li>

  <li>返回 GetValue(rref).</li>
</ol>
<p>
The ExpressionNoIn production is evaluated in the same manner as the Expression production except that the contained ExpressionNoIn and AssignmentExpressionNoIn are evaluated instead of the contained Expression and AssignmentExpression, respectively.
</p>
<div>
NOTE GetValue must be called even though its value is not used because it may have observable side-effects.
</div>
<h4>语句</h4>

<p>语法：</p>

<pre> Statement :
   Block
   VariableStatement
   EmptyStatement
   ExpressionStatement
   IfStatement
   IterationStatement
   ContinueStatement
   BreakStatement
   ReturnStatement
   WithStatement
   LabelledStatement
   SwitchStatement
   ThrowStatement
   TryStatement
   DebuggerStatement</pre>

<p>语义：</p>

<p>一个 <i>Statement</i> 可以是 <i>LabelledStatement</i> 的一部分，这个 <i>LabelledStatement</i> 自身也可以是 <i>LabelledStatement</i> 的一部分，以此类推。当描述个别语句时引入标签的这种方式统称为“当前标签组”。一个 <i>LabelledStatement</i> 介绍了一个标签到一个 <i>标签组 </i>，此外没有其他语义。一个 <i>IterationStatement</i> 或 <i>SwitchStatement</i> 的标签组最初包含单个 <b>空 </b>元素。任何其他语句的标签组最初是空的。</p>

<p>The result of evaluating a Statement is always a Completion value.</p>

<p>注： 已知几个广泛使用的 ECMAScript 实现支持 FunctionDeclaration 当作语句使用。然而，在实现之间这种 FunctionDeclarations 应用的语义也有严重且不兼容的差异。由于这些不兼容的差异，将 FunctionDeclaration 当作 Statement 使用的结果是代码在实现之间的可移植性不可靠。建议 ECMAScript 实现禁止这样运用 FunctionDeclaration，或遇到这样的运用是发出一个警告。ECMAScript 的未来版本可能定义替代的兼容方案以在 Statement 上下文中声明函数。</p>



<h4>块</h4>

<p>语法：</p>

<pre> Block :
   <b>{</b> StatementList<sub>opt</sub> <b>}</b></pre>

<pre> StatementList :
   Statement
   StatementList Statement</pre>

<p>语义：</p>

<p>产生式 <i>Block </i><b>:</b> <b>{</b> <b>}</b> 按照下面的过程执行 :</p>

<ol>
  <li>返回 (normal, empty, empty)。</li>
</ol>

<p>产生式 <i>Block </i><b>:</b> <b>{</b> <i>StatementList</i> <b>}</b> 按照下面的过程执行 :</p>

<ol>
  <li>返回解释执行 StatementList 的结果。</li>
</ol>

<p>产生式 <i>StatementList </i><b>:</b><i>Statement</i> 按照下面的过程执行 :</p>

<ol>
  <li>令 s 为解释执行 Statement 的结果。 </li>

  <li>如果有一个异常被抛出，返回 (throw, V, empty)，这里的 V 是异常。( 仿佛没有抛出异常一样继续运行。) </li>

  <li>返回 s。</li>
</ol>

<p>产生式 <i>StatementList </i><b>:</b><i>StatementList Statement</i> 按照下面的过程执行 :</p>

<ol>
  <li>令 sl 为解释执行 StatementList 的结果。 </li>

  <li>如果 sl 是个非常规完结，返回 sl。 </li>

  <li>令 s 为解释执行 Statement 的结果。 </li>

  <li>如果有一个异常被抛出，返回 (throw, V, empty)，这里的 V 是异常。 ( 仿佛没有抛出异常一样继续运行。) </li>

  <li>如果 s.value 是 empty ，令 V = sl.value, 否则令 V = s.value。 </li>

  <li>返回 (s.type, V, s.target)。</li>
</ol>

<div>
NOTE Steps 5 and 6 of the above algoritm ensure that the value of a StatementList is the value of the last value producing Statement in the StatementList. For example, the following calls to the eval function all return the value 1:

eval("1;;;;;")
eval("1;{}")
eval("1;var a;")
</div>


<h4>变量语句</h4>

<p>语法：</p>

<pre>   VariableStatement :
       var <a href="http://www.w3.org/html/ig/zh/wiki/ES5/语句#VariableDeclarationList">VariableDeclarationList</a> ;</pre>

<pre>   VariableDeclarationList :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/语句#VariableDeclaration">VariableDeclaration</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/语句#VariableDeclarationList">VariableDeclarationList</a> , <a href="http://www.w3.org/html/ig/zh/wiki/ES5/语句#VariableDeclaration">VariableDeclaration</a></pre>

<pre>   VariableDeclarationListNoIn :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/语句#VariableDeclarationNoIn">VariableDeclarationNoIn</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/语句#VariableDeclarationListNoIn">VariableDeclarationListNoIn</a> , <a href="http://www.w3.org/html/ig/zh/wiki/ES5/语句#VariableDeclarationNoIn">VariableDeclarationNoIn</a></pre>

<pre>   VariableDeclaration :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/语句#Identifier">Identifier</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/语句#Initialiser">Initialiser</a><sub>opt</sub></pre>

<pre>   VariableDeclarationNoIn :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/语句#Identifier">Identifier</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/语句#InitialiserNoIn">InitialiserNoIn</a><sub>opt</sub></pre>

<pre>   Initialiser :
       = <a href="http://www.w3.org/html/ig/zh/wiki/ES5/语句#AssignmentExpression">AssignmentExpression</a></pre>

<pre>   InitialiserNoIn :
       = <a href="http://www.w3.org/html/ig/zh/wiki/ES5/语句#AssignmentExpressionNoIn">AssignmentExpressionNoIn</a></pre>

<p>一个变量语句声明依 10.5 中定义创建的变量。当创建变量时初始化为 undefined。当 <i>VariableStatement</i> 被执行时变量关联的 <i>Initialiser</i> 会被分配 <i>AssignmentExpression</i> 的值，而不是在变量创建时。</p>

<p>语义：</p>

<p>产生式 <i>VariableStatement </i><b>:</b><i> </i><b>var</b> <i>VariableDeclarationList </i><b>;</b> 按照下面的过程执行 :</p>

<ol>
  <li>解释执行 VariableDeclarationList. </li>

  <li>返回 (normal, empty, empty).</li>
</ol>

<p>产生式 <i>VariableDeclarationList</i> <b>:</b> <i>VariableDeclaration</i> 按照下面的过程执行 :</p>

<ol>
  <li>解释执行 VariableDeclaration.</li>
</ol>

<p>产生式 <i>VariableDeclarationList</i> <b>:</b> <i>VariableDeclarationList</i> <b>,</b> <i>VariableDeclaration</i> 按照下面的过程执行 :</p>

<ol>
  <li>解释执行 VariableDeclarationList. </li>

  <li>解释执行 VariableDeclaration.</li>
</ol>

<p>产生式 <i>VariableDeclaration </i><b>:</b> <i>Identifier</i> 按照下面的过程执行 :</p>

<ol>
  <li>返回一个包含跟 Identifier. 完全相同的字符序列的字符串值</li>
</ol>

<p>产生式 <i>VariableDeclaration</i> <b>:</b> <i>Identifier Initialiser</i> 按照下面的过程执行 :</p>

<ol>
  <li>令 lhs 为解释执行 Identifier 的结果 as described in 11.1.2. </li>

  <li>令 rhs 为解释执行 Initialiser 的结果 . </li>

  <li>令 value 为 GetValue(rhs). </li>

  <li>Call PutValue(lhs, value). </li>

  <li>返回一个包含跟 Identifier. 完全相同的字符序列的字符串值</li>
</ol>

<p>注：<i>VariableDeclaration</i> 的字符串值用在 for-in 语句 (<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=12.6.4&action=edit&redlink=1">12.6.4</a>) 的解释执行。</p>

<p>如果 VariableDeclaration 嵌套在 with 语句里并且 VariableDeclaration 里的标识符与 with 语句的对象式环境记录项关联的绑定对象的一个属性名相同，则第 4 步将给这个属性分配值，而不是为 Identifier 的 VariableEnvironment 绑定分配值。</p>

<p>产生式 <i>Initialiser </i><b>:</b> <b>=</b> <i>AssignmentExpression</i> 按照下面的过程执行 :</p>

<ol>
  <li>返回解释执行 AssignmentExpression 的结果 .</li>
</ol>

<p>产生式 <i>VariableDeclarationListNoIn</i>, <i>VariableDeclarationNoIn</i>, <i>InitialiserNoIn</i> 解释执行的方式与产生式 <i>VariableDeclarationList</i>, <i>VariableDeclaration</i>，<i>Initialiser</i> 相同，除了他们包含的<i>VariableDeclarationListNoIn</i>, <i>VariableDeclarationNoIn</i>, <i>InitialiserNoIn</i>, <i>AssignmentExpressionNoIn</i> 会分别替代 <i>VariableDeclarationList</i>, <i>VariableDeclaration</i>, <i>Initialiser</i>, <i>AssignmentExpression</i> 来解释执行。</p>



<h5>严格模式的限制</h5>

<p>如果一个 <i>VariableDeclaration</i> 或 <i>VariableDeclarationNoIn</i> 出现在 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E4%BB%A3%E7%A0%81&action=edit&redlink=1">严格模式代码 </a>里并且其 <i>Identifier</i> 是 <b>"eval" 或 "arguments"</b>，那么这是个 SyntaxError。</p>



<h4>空语句</h4>

<p>语法 :</p>

<pre> EmptyStatement :
   <b>;</b></pre>

<p>语义：</p>

<p>产生式 <i>EmptyStatement </i><b>:</b> <b>;</b> 按照下面的过程执行 :</p>

<ol>
  <li>返回 (normal, empty, empty).</li>
</ol>


<h4>表达式语句</h4>

<p>语法：</p>

<pre> ExpressionStatement :
   [lookahead ∉ {<b>{</b>, <b>function</b>}]<a href="http://www.w3.org/html/ig/zh/wiki/ES5/语句#Expression">Expression</a> ;</pre>

<p>注： 一个 <i>ExpressionStatement</i> 不能用一个开大括号开始，因为这可能会使它和 <i>Block</i> 混淆。此外，<i>ExpressionStatement</i> 不能用 <b>function</b> 关键字开始，因为这可能会使它和<i>FunctionDeclaration</i> 混淆。</p>

<p>语义：</p>

<p>产生式 <i>ExpressionStatement </i><b>:</b> [lookahead ∉ {<b>{'</b><i>,'</i><b> function</b>}]<i>Expression</i><b>;</b> 按照下面的过程执行 :</p>

<ol>
  <li>令 exprRef 为解释执行 Expression 的结果 . </li>

  <li>返回 (normal, GetValue(exprRef), empty).</li>
</ol>


<h4>if 语句</h4>

<p>语法：</p>

<pre> IfStatement :
   if ( <a href="http://www.w3.org/html/ig/zh/wiki/ES5/语句#Expression">Expression</a> ) <a href="http://www.w3.org/html/ig/zh/wiki/ES5/语句#Statement">Statement</a> else <a href="http://www.w3.org/html/ig/zh/wiki/ES5/语句#Statement">Statement</a>
   if ( <a href="http://www.w3.org/html/ig/zh/wiki/ES5/语句#Expression">Expression</a> ) <a href="http://www.w3.org/html/ig/zh/wiki/ES5/语句#Statement">Statement</a></pre>

<p>每个 else 选择与它相关联的 if 是不确定的，应与此 else 最近的并且原本没有与其对应的 else 的可能的 if 对应。</p>

<p>语义：</p>

<p>产生式 <i>IfStatement </i><b>:</b> <b>if</b> <b>(</b> <i>Expression </i><b>)</b> <i>Statement </i><b>else</b> <i>Statement</i> 按照下面的过程执行 :</p>

<ol>
  <li>令 exprRef 为解释执行 Expression 的结果 . </li>

  <li>如果 ToBoolean(GetValue(exprRef)) is true ，then
      <ol><li>返回解释执行 the 的结果 first Statement.</li></ol></li>
  <li>Else,
      <ol><li>返回解释执行 the 的结果 second Statement.</li></ol></li>
 </ol>

<p>产生式 <i>IfStatement </i><b>:</b> <b>if</b> <b>(</b> <i>Expression </i><b>)</b> <i>Statement</i> 按照下面的过程执行 :</p>

<ol>
  <li>令 exprRef 为解释执行 Expression 的结果 . </li>

  <li>如果 ToBoolean(GetValue(exprRef)) is false ，return (normal, empty, empty). </li>

  <li>返回解释执行 Statement 的结果 .</li>
</ol>


<h4>迭代语句</h4>

<p>语法：</p>

<pre> IterationStatement :
   do <a href="http://www.w3.org/html/ig/zh/wiki/ES5/语句#Statement">Statement</a> while ( <a href="http://www.w3.org/html/ig/zh/wiki/ES5/语句#Expression">Expression</a> ); 
   while ( <a href="http://www.w3.org/html/ig/zh/wiki/ES5/语句#Expression">Expression</a> ) <a href="http://www.w3.org/html/ig/zh/wiki/ES5/语句#Statement">Statement</a>
   for ( <a href="http://www.w3.org/html/ig/zh/wiki/ES5/语句#ExpressionNoIn">ExpressionNoIn</a><sub>opt</sub>; <a href="http://www.w3.org/html/ig/zh/wiki/ES5/语句#Expression">Expression</a><sub>opt</sub> ; <a href="http://www.w3.org/html/ig/zh/wiki/ES5/语句#Expression">Expression</a><sub>opt</sub> ) <a href="http://www.w3.org/html/ig/zh/wiki/ES5/语句#Statement">Statement</a>
   for ( var <a href="http://www.w3.org/html/ig/zh/wiki/ES5/语句#VariableDeclarationListNoIn">VariableDeclarationListNoIn</a>; <a href="http://www.w3.org/html/ig/zh/wiki/ES5/语句#Expression">Expression</a><sub>opt</sub> ; <a href="http://www.w3.org/html/ig/zh/wiki/ES5/语句#Expression">Expression</a><sub>opt</sub> ) <a href="http://www.w3.org/html/ig/zh/wiki/ES5/语句#Statement">Statement</a>
   for ( <a href="http://www.w3.org/html/ig/zh/wiki/ES5/语句#LeftHandSideExpression">LeftHandSideExpression</a> in <a href="http://www.w3.org/html/ig/zh/wiki/ES5/语句#Expression">Expression</a> ) <a href="http://www.w3.org/html/ig/zh/wiki/ES5/语句#Statement">Statement</a>
   for ( var <a href="http://www.w3.org/html/ig/zh/wiki/ES5/语句#VariableDeclarationNoIn">VariableDeclarationNoIn</a> in <a href="http://www.w3.org/html/ig/zh/wiki/ES5/语句#Expression">Expression</a> ) <a href="http://www.w3.org/html/ig/zh/wiki/ES5/语句#Statement">Statement</a></pre>



<h5>do-while 语句</h5>

<p>产生式 <b>do</b> <i>Statement </i><b>while</b> <b>(</b> <i>Expression </i><b>);</b> 按照下面的过程执行 :</p>

<ol>
  <li>令 V = empty。 </li>

  <li>令 iterating 为 true。 </li>

  <li>只要 iterating 为 true，就重复 
    <ol>
      <li>令 stmt 为解释执行 Statement 的结果。 </li>

      <li>如果 stmt.value 不是 empty，令 V = stmt.value。 </li>

      <li>如果 stmt.type 不是 continue || stmt.target 不在当前标签组，则 
        <ol>
          <li>如果 stmt.type 是 break 并且 stmt.target 在当前标签组内，返回 (normal, V, empty)。 </li>

          <li>如果 stmt 是个 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=%E9%9D%9E%E5%B8%B8%E8%A7%84%E5%AE%8C%E7%BB%93&action=edit&redlink=1">非常规完结 </a>，返回 stmt。</li>
        </ol>
      </li>

      <li>令 exprRef 为解释执行 Expression 的结果。 </li>

      <li>如果 ToBoolean(GetValue(exprRef)) 是 false，设定 iterating 为 false。</li>
    </ol>
  </li>

  <li>返回 (normal, V, empty);</li>
</ol>


<h5>while 语句</h5>

<p>产生式 <i>IterationStatement </i><b>:</b><i> </i><b>while</b> <b>(</b> <i>Expression </i><b>)</b> <i>Statement</i> 按照下面的过程执行 :</p>

<ol>
  <li>令 V = empty. </li>

  <li>重复 
    <ol>
      <li>令 exprRef 为解释执行 Expression 的结果 . </li>

      <li>如果 ToBoolean(GetValue(exprRef)) 是 false，返回 (normal, V, empty). </li>

      <li>令 stmt 为解释执行 Statement 的结果 . </li>

      <li>如果 stmt.value 不是 empty，令 V = stmt.value. </li>

      <li>如果 stmt.type 不是 continue || stmt.target 不在当前标签组内，则 
        <ol>
          <li>如果 stmt.type 是 break 并且 stmt.target 在当前标签组内，则 
            <ol>
              <li>返回 (normal, V, empty).</li>
            </ol>
          </li>

          <li>如果 stmt 是一个非常规完结，返回 stmt.</li>
        </ol>
      </li>
    </ol>
  </li>
</ol>


<h5>for 语句</h5>

<p>产生式 <i>IterationStatement</i> <b>:</b> <b>for</b> <b>(</b> <i>ExpressionNoIn</i><sub>opt</sub> <b>;</b> <i>Expression</i><sub>opt</sub> <b>;</b> <i>Expression</i><sub>opt</sub><b>)</b> <i>Statement</i> 按照下面的过程执行 :</p>

<ol>
  <li>如果 ExpressionNoIn 是 present，则 . 
    <ol>
      <li>令 exprRef 为解释执行 ExpressionNoIn 的结果 . </li>

      <li>调用 GetValue(exprRef). ( 不会用到此值。)</li>
    </ol>
  </li>

  <li>令 V = empty. </li>

  <li>重复 
    <ol>
      <li>如果第一个 Expression 是 present，则 
        <ol>
          <li>令 testExprRef 为解释执行第一个 Expression 的结果 . </li>

          <li>如果 ToBoolean(GetValue(testExprRef)) 是 false，返回 (normal, V, empty).</li>
        </ol>
      </li>

      <li>令 stmt 为解释执行 Statement 的结果 . </li>

      <li>如果 stmt.value 不是 empty，令 V = stmt.value </li>

      <li>如果 stmt.type 是 break 并且 stmt.target 在当前标签组内，返回 (normal, V, empty). </li>

      <li>如果 stmt.type 不是 continue || stmt.target 不在当前标签组内，则 
        <ol>
          <li>如果 stmt 是个非常规完结，返回 stmt.</li>
        </ol>
      </li>

      <li>如果第二个 Expression 是 present，则 
        <ol>
          <li>令 incExprRef 为解释执行第二个 Expression 的结果 . </li>

          <li>调用 GetValue(incExprRef). ( 不会用到此值 .)</li>
        </ol>
      </li>
    </ol>
  </li>
</ol>

<p>产生式 <i>IterationStatement</i> <b>:</b> <b>for</b> <b>(</b> <b>var</b> <i>VariableDeclarationListNoIn</i> <b>;</b> <i>Expression</i><sub>opt</sub> <b>;</b> <i>Expression</i><sub>opt</sub> <b>)</b> <i>Statement</i> 按照下面的过程执行 :</p>

<ol>
  <li>解释执行 VariableDeclarationListNoIn. </li>

  <li>令 V = empty. </li>

  <li>重复 
    <ol>
      <li>如果第一个 Expression 是 present，则 
        <ol>
          <li>令 testExprRef 为解释执行第一个 Expression 的结果 . </li>

          <li>如果 ToBoolean(GetValue(testExprRef)) 是 false，则返回 (normal, V, empty).</li>
        </ol>
      </li>

      <li>令 stmt 为解释执行 Statement 的结果 . </li>

      <li>如果 stmt.value 不是 empty，令 V = stmt.value. </li>

      <li>如果 stmt.type 是 break 并且 stmt.target 在当前标签组内，返回 (normal, V, empty). </li>

      <li>如果 stmt.type 不是 continue || stmt.target 不在当前标签组内，则 
        <ol>
          <li>如果 stmt 是个非常规完结，返回 stmt.</li>
        </ol>
      </li>

      <li>如果第二个 Expression 是 present，则 . 
        <ol>
          <li>令 incExprRef 为解释执行第二个 Expression 的结果 . </li>

          <li>调用 GetValue(incExprRef). ( 不会用到此值 .)</li>
        </ol>
      </li>
    </ol>
  </li>
</ol>


<h5>for-in 语句</h5>

<p>产生式 <i>IterationStatement</i> <b>:</b> <b>for</b> <b>(</b> <i>LeftHandSideExpression</i> <b>in</b> <i>Expression</i> <b>)</b> <i>Statement</i> 按照下面的过程执行 :</p>

<ol>
  <li>令 exprRef 为解释执行 Expression 的结果 . </li>

  <li>令 experValue 为 GetValue(exprRef). </li>

  <li>如果 experValue 是 null 或 undefined，返回 (normal, empty, empty). </li>

  <li>令 obj 为 ToObject(experValue). </li>

  <li>令 V = empty. </li>

  <li>重复 
    <ol>
      <li>令 P 为 obj 的下一个 [[Enumerable]] 特性为 true 的属性的名。如果不存在这样的属性，返回 (normal, V, empty). </li>

      <li>令 lhsRef 为解释执行 LeftHandSideExpression 的结果 ( 它可能解释执行多次 ). </li>

      <li>调用 PutValue(lhsRef, P). </li>

      <li>令 stmt 为解释执行 Statement 的结果 . </li>

      <li>如果 stmt.value 不是 empty，令 V = stmt.value. </li>

      <li>如果 stmt.type 是 break 并且 stmt.target 在当前标签组内，返回 (normal, V, empty). </li>

      <li>如果 stmt.type 不是 continue || stmt.target 不在当前标签组内，则 
        <ol>
          <li>如果 stmt 是非常规完结，返回 stmt.</li>
        </ol>
      </li>
    </ol>
  </li>
</ol>

<p>产生式 <i>IterationStatement</i> <b>:</b> <b>for</b> <b>(</b> <b>var</b> <i>VariableDeclarationNoIn</i> <b>in</b> <i>Expression</i> <b>)</b> <i>Statement</i> 按照下面的过程执行 :</p>

<ol>
  <li>令 varName 为解释执行 VariableDeclarationNoIn 的结果 . </li>

  <li>令 exprRef 为解释执行 Expression 的结果 . </li>

  <li>令 experValue 为 GetValue(exprRef). </li>

  <li>如果 experValue 是 null 或 undefined，返回 (normal, empty, empty). </li>

  <li>令 obj 为 ToObject(experValue). </li>

  <li>令 V = empty. </li>

  <li>重复 
    <ol>
      <li>令 P 为 obj 的下一个 [[Enumerable]] 特性为 true 的属性的名。如果不存在这样的属性，返回 (normal, V, empty). </li>

      <li>令 varRef 为解释执行 varName 的结果，仿佛它是个标示符引用 (11.1.2); 它可能解释执行多次 . </li>

      <li>调用 PutValue(varRef, P). </li>

      <li>令 stmt 为解释执行 Statement 的结果 . </li>

      <li>如果 stmt.value 不是 empty，令 V = stmt.value. </li>

      <li>如果 stmt.type 是 break 并且 stmt.target 在当前标签组内，返回 (normal, V, empty). </li>

      <li>如果 stmt.type 不是 continue || stmt.target 不在当前标签组内，则 
        <ol>
          <li>如果 stmt 是非常规完结，返回 stmt.</li>
        </ol>
      </li>
    </ol>
  </li>
</ol>

<p>枚举的属性 ( 第一个算法中的步骤 6.a，第二个算法中的步骤 7.a) 的机制和顺序并没有指定。在枚举过程中枚举的对象属性可能被删除。如果在枚举过程中，删除了还没有被访问到的属性，那么它将不会被访问到。如果在枚举过程中添加新属性到列举的对象，新增加的属性也无法保证被当前执行中的枚举访问到。在任何枚举中对同一个属性名称的访问不得超过一次。</p>

<p>枚举一个对象的属性包括枚举其原型的属性，还有原型的原型，等等，递归；但是如果原型的一个属性是“阴影里的”那么不会枚举这个属性，因为原型链中之前某个对象有同名的属性了。当一个原型对象的一个属性是在原型链中之前对象的阴影里的，那么在决定是否枚举时不需要考虑 [[Enumerable]] 特性的值。</p>

<p>注： 见 NOTE <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=11.13.1&action=edit&redlink=1">11.13.1</a>.</p>



<h4>continue 语句</h4>

<p>语法：</p>

<pre> ContinueStatement :
   continue ;
   continue [ 此处无换行 ] <a href="http://www.w3.org/html/ig/zh/wiki/ES5/语句#Identifier">Identifier</a> ;</pre>

<p>语义：</p>

<p>如果以下任意一个为真，那么程序被认为是语法错误的：</p>

<ul>
  <li>程序包含一个不带可选的 <i>Identifier</i> 的 <b>continue</b> 语句，没有直接或间接 ( 不跨越函数边界 ) 的嵌套在 <i>IterationStatement</i> 里。 </li>

  <li>程序包含一个有可选的 <i>Identifier</i> 的 <b>continue</b> 语句，这个 <i>Identifier</i> 没有出现在 IterationStatement 中闭合标签组里 ( 不跨越函数边界 )。</li>
</ul>

<p>一个没有 <i>Identifier</i> 的 <i>ContinueStatement</i> 按照下面的过程执行 :</p>

<ol>
  <li>返回 (continue, empty, empty).</li>
</ol>

<p>一个有可选的 <i>Identifier</i> 的 <i>ContinueStatement</i> 按照下面的过程执行 :</p>

<ol>
  <li>返回 (continue, empty, Identifier).</li>
</ol>


<h4>break 语句</h4>

<p>语法：</p>

<pre> BreakStatement :
   break ;
   break [ 此处无换行 ] <a href="http://www.w3.org/html/ig/zh/wiki/ES5/语句#Identifier">Identifier</a> ;</pre>

<p>语义：</p>

<p>如果以下任意一个为真，那么程序被认为是语法错误的：</p>

<ul>
  <li>程序包含一个不带可选的 <i>Identifier</i> 的 <b>break</b> 语句，没有直接或间接 ( 不跨越函数边界 ) 的嵌套在 <i>IterationStatement</i> 或 <i>SwitchStatement</i> 里。 </li>

  <li>程序包含一个有可选的 <i>Identifier</i> 的 <b>break</b> 语句，这个 <i>Identifier</i> 没有出现在 <i>Statement</i> 中闭合标签组里 ( 不跨越函数边界 )。</li>
</ul>

<p>一个没有 <i>Identifier</i> 的 <i>BreakStatement</i> 按照下面的过程执行 :</p>

<ol>
  <li>返回 (continue, empty, empty).</li>
</ol>

<p>一个有可选的 <i>Identifier</i> 的 <i>BreakStatement</i> 按照下面的过程执行 :</p>

<ol>
  <li>返回 (continue, empty, Identifier).</li>
</ol>


<h4>return 语句</h4>

<p>语法：</p>

<pre> ReturnStatement :
   return ;
   return [ 此处无换行 ] <a href="http://www.w3.org/html/ig/zh/wiki/ES5/语句#Expression">Expression</a> ;</pre>

<p>语义：</p>

<p>在一个 ECMAScript 程序中包含的 <b>return</b> 语句没有在 <i><a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=FunctionBody&action=edit&redlink=1">FunctionBody</a></i> 里面，那么就是语法错误的。一个 <b>return</b> 语句导致函数停止执行，并返回一个值给调用者。如果省略<i>Expression</i>，返回值是 <b>undefined</b>。否则，返回值是 <i>Expression</i> 的值。</p>

<p>产生式 <i>ReturnStatement</i> <b>:'<i> </i></b><i>return'</i><b> </b>[no <i>LineTerminator</i> here]<b> </b><i>Expression</i><sub>opt</sub> <b>;</b> 按照下面的过程执行 :</p>

<ol>
  <li>如果 Expression 不是 present，返回 (return, undefined, empty). </li>

  <li>令 exprRef 为解释执行 Expression 的结果 . </li>

  <li>返回 (return, GetValue(exprRef), empty).</li>
</ol>


<h4>with 语句</h4>

<p>语法：</p>

<pre> WithStatement :
   with ( <a href="http://www.w3.org/html/ig/zh/wiki/ES5/语句#Expression">Expression</a> ) <a href="http://www.w3.org/html/ig/zh/wiki/ES5/语句#Statement">Statement</a></pre>

<p>with 语句为计算对象给当前执行上下文的 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=%E8%AF%8D%E6%B3%95%E7%8E%AF%E5%A2%83&action=edit&redlink=1">词法环境 </a>添加一个对象 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=%E7%8E%AF%E5%A2%83%E8%AE%B0%E5%BD%95%E9%A1%B9&action=edit&redlink=1">环境记录项 </a>。然后，用这个增强的 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=%E8%AF%8D%E6%B3%95%E7%8E%AF%E5%A2%83&action=edit&redlink=1">词法环境 </a>执行一个语句。最后，恢复到原来的 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=%E8%AF%8D%E6%B3%95%E7%8E%AF%E5%A2%83&action=edit&redlink=1">词法环境 </a>。</p>

<p>语义 :</p>

<p>产生式 <i>WithStatement </i><b>:</b> <b>with</b> <b>(</b> <i>Expression </i><b>)</b> <i>Statement</i> 按照下面的过程执行 :</p>

<ol>
  <li>令 val 为解释执行 Expression 的结果 . </li>

  <li>令 obj 为 ToObject(GetValue(val)). </li>

  <li>令 oldEnv 为运行中的执行上下文的 LexicalEnvironment. </li>

  <li>令 newEnv 为以 obj 和 oldEnv 为参数调用 NewObjectEnvironment 的结果。 </li>

  <li>设定 newEnv 的 provideThis 标志为 <b>true</b>。 </li>

  <li>设定运行中的执行上下文的 LexicalEnvironment 为 newEnv. </li>

  <li>令 C 为解释执行 Statement 的结果，但如果解释执行是由异常抛出，则令 C 为 (throw, V, empty)，这里的 <i>V</i> 是异常。( 现在继续执行，仿佛没有抛出异常。) </li>

  <li>设定运行中的执行上下文的 LexicalEnvironment 为 oldEnv. </li>

  <li>返回 C.</li>
</ol>

<p>注： 无论控制是从嵌入的 Statement 怎样离开的，不论是正常离开还是以 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=%E9%9D%9E%E5%B8%B8%E8%A7%84%E5%AE%8C%E7%BB%93&action=edit&redlink=1">非常规完结 </a>或异常，LexicalEnvironment 总是恢复到它之前的状态。</p>



<h5>严格模式的限制</h5>

<p>严格模式代码中不能包含 <i>WithStatement</i>。出现 <i>WithStatement</i> 的上下文被当作一个 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=SyntaxError&action=edit&redlink=1">SyntaxError</a>。</p>



<h4>switch 语句</h4>

<p>语法：</p>

<pre> SwitchStatement :
   switch ( <a href="http://www.w3.org/html/ig/zh/wiki/ES5/语句#Expression">Expression</a> ) <a href="http://www.w3.org/html/ig/zh/wiki/ES5/语句#CaseBlock">CaseBlock</a></pre>

<pre> CaseBlock :
   { <a href="http://www.w3.org/html/ig/zh/wiki/ES5/语句#CaseClauses">CaseClauses</a><sub>opt</sub> } 
   { <a href="http://www.w3.org/html/ig/zh/wiki/ES5/语句#CaseClauses">CaseClauses</a><sub>opt</sub><a href="http://www.w3.org/html/ig/zh/wiki/ES5/语句#DefaultClause">DefaultClause</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/语句#CaseClauses">CaseClauses</a><sub>opt</sub> }</pre>

<pre> CaseClauses :
   <a href="http://www.w3.org/html/ig/zh/wiki/ES5/语句#CaseClause">CaseClause</a>
   <a href="http://www.w3.org/html/ig/zh/wiki/ES5/语句#CaseClauses">CaseClauses</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/语句#CaseClause">CaseClause</a></pre>

<pre> CaseClause :
   case <a href="http://www.w3.org/html/ig/zh/wiki/ES5/语句#Expression">Expression</a> : <a href="http://www.w3.org/html/ig/zh/wiki/ES5/语句#StatementList">StatementList</a><sub>opt</sub></pre>

<pre> DefaultClause :
   default : <a href="http://www.w3.org/html/ig/zh/wiki/ES5/语句#StatementList">StatementList</a><sub>opt</sub></pre>

<p>语义：</p>

<p>产生式 <i>SwitchStatement </i><b>:</b> <b>switch</b> <b>(</b> <i>Expression </i><b>)</b> <i>CaseBlock</i> 按照下面的过程执行 :</p>

<ol>
  <li>令 exprRef 为解释执行 Expression 的结果 . </li>

  <li>令 R 为以 GetValue(exprRef) 作为参数解释执行 CaseBlock 的结果。 </li>

  <li>如果 R.type 是 break 并且 R.target 在当前标签组内，返回 (normal, R.value, empty). </li>

  <li>返回 R.</li>
</ol>

<p>产生式 <i>CaseBlock</i> <b>:</b> { <i>CaseClauses</i><sub>opt</sub> } 以一个给定输入参数 <i>input</i>, 按照下面的过程执行 :</p>

<ol>
  <li>令 V = empty. </li>

  <li>令 A 为以源代码中顺序排列的 CaseClause 列表。 </li>

  <li>令 searching 为 true. </li>

  <li>只要 searching 为 true，就重复 
    <ol>
      <li>令 C 为 A 里的下一个 CaseClause。 如果没有 CaseClause 了，返回 (normal, V, empty). </li>

      <li>令 clauseSelector 为解释执行 C 的结果 . </li>

      <li>如果 input 和 clauseSelector 是 === 操作符定义的相等，则 
        <ol>
          <li>设定 searching 为 false. </li>

          <li>如果 C 有一个 StatementList, 则 
            <ol>
              <li>令 R 为解释执行 C 的 StatementList 的结果。 </li>

              <li>如果 R 是个非常规完结 , 则返回 R。 </li>

              <li>令 V =R.value</li>
            </ol>
          </li>
        </ol>
      </li>
    </ol>
  </li>

  <li>重复 
    <ol>
      <li>令 C 为 A 里的下一个 CaseClause。 如果没有 CaseClause 了，返回 (normal, V, empty). </li>

      <li>如果 C 有一个 StatementList, 则 
        <ol>
          <li>令 R 为解释执行 C 的 StatementList 的结果。 </li>

          <li>如果 R.value 不是 empty, 则令 V =R.value. </li>

          <li>如果 R 是个非常规完结 , 则返回 (R.type,V,R.target).</li>
        </ol>
      </li>
    </ol>
  </li>
</ol>

<p>产生式 <i>CaseBlock</i> <b>:</b> { <i>CaseClauses</i><sub>opt</sub><i>DefaultClause CaseClauses</i><sub>opt</sub> } 以一个给定输入参数 <i>input</i>, 按照下面的过程执行 :</p>

<ol>
  <li>令 V = empty. </li>

  <li>令 A 为第一个 CaseClauses 中以源代码中顺序排列的 CaseClause 列表。 </li>

  <li>令 B 为第二个 CaseClauses 中以源代码中顺序排列的 CaseClause 列表。 </li>

  <li>令 found 为 false. </li>

  <li>重复，使 C 为 A 中的依次每个 CaseClause。 
    <ol>
      <li>如果 found 是 false，则 
        <ol>
          <li>令 clauseSelector 为解释执行 C 的结果 . </li>

          <li>如果 input 和 clauseSelector 是 === 操作符定义的相等，则设定 found 为 true.</li>
        </ol>
      </li>

      <li>如果 found 是 true，则 
        <ol>
          <li>如果 C 有一个 StatementList，则 
            <ol>
              <li>令 R 为解释执行 C 的 StatementList 的结果。 </li>

              <li>如果 R.value 不是 empty, 则令 V =R.value. </li>

              <li>R 是个非常规完结 , 则返回 (R.type,V,R.target).</li>
            </ol>
          </li>
        </ol>
      </li>
    </ol>
  </li>

  <li>令 foundInB 为 false. </li>

  <li>如果 found 是 false，则 
    <ol>
      <li>只要 foundInB 为 false 并且所有 B 中的元素都没有被处理，就重复 
        <ol>
          <li>令 C 为 B 里的下一个 CaseClause. </li>

          <li>令 clauseSelector 为解释执行 C 的结果 . </li>

          <li>如果 input 和 clauseSelector 是 === 操作符定义的相等，则 
            <ol>
              <li>设定 foundInB 为 true. </li>

              <li>如果 C 有一个 StatementList, 则 
                <ol>
                  <li>令 R 为解释执行 C 的 StatementList 的结果。 </li>

                  <li>如果 R.value 不是 empty, 则令 V =R.value. </li>

                  <li>R 是个非常规完结 , 则返回 (R.type,V,R.target).</li>
                </ol>
              </li>
            </ol>
          </li>
        </ol>
      </li>
    </ol>
  </li>

  <li>如果 foundInB 是 false 并且 DefaultClause 有个 StatementList, 则 
    <ol>
      <li>令 R 为解释执行 DefaultClause 的 StatementList 的结果 . </li>

      <li>如果 R.value 不是 empty, 则令 V = R.value. </li>

      <li>如果 R 是个非常规完结 , 则返回 (R.type, V, R.target).</li>
    </ol>
  </li>

  <li>重复 ( 注 : 如果已执行步骤 7.a.i, 此循环不从 B 的开头开始。) 
    <ol>
      <li>令 C 为 B 的下一个 CaseClause。如果没有 CaseClause 了 , 返回 (normal, V, empty). </li>

      <li>如果 C 有个 StatementList, 则 
        <ol>
          <li>令 R 为解释执行 C 的 StatementList 的结果。 </li>

          <li>如果 R.value 不是 empty, 则令 V = R.value. </li>

          <li>如果 R 是个非常规完结 , 则返回 (R.type, V, R.target).</li>
        </ol>
      </li>
    </ol>
  </li>
</ol>

<p>产生式 <i>CaseClause</i> <b>:</b> <b>case</b> <i>Expression </i><b>:</b> <i>StatementList</i><sub>opt</sub> 按照下面的过程执行 :</p>

<ol>
  <li>令 exprRef 为解释执行 Expression 的结果 . </li>

  <li>返回 GetValue(exprRef).</li>
</ol>

<p>注： 解释执行 CaseClause 不会运行相关的 StatementList。它只简单的解释执行 Expression 并返回值，这里的 CaseBlock 算法用于确定 StatementList 开始执行。</p>



<h4>标签语句</h4>

<p>语法：</p>

<pre> <i>LabelledStatement</i> :
   <i>Identifier</i> <b>:</b> <i>Statement</i></pre>

<p>语义：</p>

<p>一个 <i>Statement</i> 可以由一个标签作为前缀。标签语句仅与标签化的 <b>break</b> 和 <b>continue</b> 语句一起使用。ECMAScript 没有 <b>goto</b> 语句。</p>

<p>如果一个 ECMAScript 程序包含有相同 Identifier 作为标签的 LabelledStatement 闭合的 LabelledStatement，那么认为它是是语法错误的 。这不适用于直接或间接嵌套在标签语句里面的 FunctionDeclaration 的 body 里出现标签的情况。</p>

<p>产生式 Identifier : Statement 的解释执行方式是，先添加 Identifier 到 Statement 的标签组，再解释执行 Statement。如果 LabelledStatement 自身有一个非空标签组，这些标签还是会添加到解释执行前的 Statement 的标签组里。如果 Statement 的解释执行结果是 (break, V, L)，这里的 L 等于 Identifier，则产生式的结果是 (normal, V, empty)。</p>

<p>在解释执行 LabelledStatement 之前，认为包含的 Statement 拥有一个空标签组，除非它是 IterationStatement 或 SwitchStatement，这种情况下认为它拥有一个包含单个元素 empty 的标签组。</p>



<h4>throw 语句</h4>

<p>语法：</p>

<pre> <i>ThrowStatement</i> :
   <b>throw</b> [no LineTerminator here] <i>Expression</i> <b>;</b></pre>

<p>语义：</p>

<p>产生式 <i>ThrowStatement</i> <b>:</b> <b>throw</b> [no <i>LineTerminator</i> here]<i><b> </b>Expression</i> <b>;</b> 按照下面的过程执行 :</p>

<ol>
  <li>令 exprRef 为解释执行 Expression 的结果 . </li>

  <li>返回 (throw, GetValue(exprRef), empty).</li>
</ol>


<h4>try 语句</h4>

<p>语法：</p>

<pre> TryStatement :
   try <a href="http://www.w3.org/html/ig/zh/wiki/ES5/语句#Block">Block</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/语句#Catch">Catch</a>
   try <a href="http://www.w3.org/html/ig/zh/wiki/ES5/语句#Block">Block</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/语句#Finally">Finally</a>
   try <a href="http://www.w3.org/html/ig/zh/wiki/ES5/语句#Block">Block</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/语句#Catch">Catch</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/语句#Finally">Finally</a></pre>

<pre> Catch :
   catch ( <a href="http://www.w3.org/html/ig/zh/wiki/ES5/语句#Identifier">Identifier</a> ) <a href="http://www.w3.org/html/ig/zh/wiki/ES5/语句#Block">Block</a></pre>

<pre> Finally :
   finally <a href="http://www.w3.org/html/ig/zh/wiki/ES5/语句#Block">Block</a></pre>

<p>try 语句包裹一个可以出现特殊状况，如果运行时错误或 throw 语句的代码块。catch 子句提供了异常处理代码。如果 catch 子句捕获到一个异常，这个异常会绑定到它的 Identifier 上。</p>

<p>语义：</p>

<p>产生式 <i>TryStatement</i> <b>:</b> <b>try</b> <i>Block</i> <i>Catch</i> 按照下面的过程执行 :</p>

<ol>
  <li>令 B 为解释执行 Block 的结果 . </li>

  <li>如果 B.type 不是 throw，返回 B. </li>

  <li>返回一参数 B 解释执行 Catch 的结果 .</li>
</ol>

<p>产生式 <i>TryStatement</i> <b>:</b> <b>try</b> <i>Block</i> <i>Finally</i> 按照下面的过程执行 :</p>

<ol>
  <li>令 B 为解释执行 Block 的结果 . </li>

  <li>令 F 为解释执行 Finally 的结果 . </li>

  <li>如果 F.type 是 normal，返回 B. </li>

  <li>返回 F.</li>
</ol>

<p>产生式 <i>TryStatement</i> <b>:</b> <b>try</b> <i>Block</i> <i>Catch</i> <i>Finally</i> 按照下面的过程执行 :</p>

<ol>
  <li>令 B 为解释执行 Block 的结果 . </li>

  <li>如果 B.type 是 throw，则 
    <ol>
      <li>令 C 为以参数 B 解释执行 Catch 的结果 .</li>
    </ol>
  </li>

  <li>否则 , B.type 不是 throw, 
    <ol>
      <li>令 C 为 B.</li>
    </ol>
  </li>

  <li>令 F 为解释执行 Finally 的结果 . </li>

  <li>如果 F.type 是 normal，返回 C. </li>

  <li>返回 F.</li>
</ol>

<p>产生式 <i>Catch</i> <b>:</b> <b>catch</b> <b>( </b><i>Identifier</i> <b>)</b> <i>Block</i> 按照下面的过程执行 :</p>

<ol>
  <li>令 C 为传给这个产生式的参数 . </li>

  <li>令 oldEnv 为运行中执行上下文的 LexicalEnvironment. </li>

  <li>令 catchEnv 为以 oldEnv 为参数调用 NewDeclarativeEnvironment 的结果 </li>

  <li>以 Identifier 字符串值为参数调用 catchEnv 的 CreateMutableBinding 具体方法。 </li>

  <li>以 Identifier, C, false 为参数调用 catchEnv 的 SetMutableBinding 具体方法。注：这种情况下最后一个参数无关紧要。 </li>

  <li>设定运行中执行上下文的 LexicalEnvironment 为 catchEnv. </li>

  <li>令 B 为解释执行 Block 的结果 . </li>

  <li>设定运行中执行上下文的 LexicalEnvironment 为 oldEnv. </li>

  <li>返回 B.</li>
</ol>

<p>注： 不管控制是怎样退出 Block 的，LexicalEnvironment 总是会恢复到其之前的状态。</p>

<p>产生式 <i>Finally</i> <b>: finally</b> <i>Block</i> 按照下面的过程执行 :</p>

<ol>
  <li>返回解释执行 Block 的结果 .</li>
</ol>



<h5>严格模式的限制</h5>

<p>如果一个有 Catch 的 TryStatement 出现在 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E4%BB%A3%E7%A0%81&action=edit&redlink=1">严格模式代码 </a>里，并且 Catch 产生式的 Identifier 是 "<b>eval</b>" 或 "<b>arguments</b>"，那么这是个 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=SyntaxError&action=edit&redlink=1">SyntaxError</a></p>



<h4>debugger 语句</h4>

<p>语法：</p>

<pre> DebuggerStatement :
   debugger ;</pre>

<p>语义：</p>

<p>解释执行 DebuggerStatement 产生式可允许让一个实现在调试器下运行时设置断点。如果调试器不存在或是非激活状态，这个语句没有可观测效果。</p>

<p>产生式 <i>DebuggerStatement </i><b>:</b><i> </i><b>debugger ;</b> 按照下面的过程执行 :</p>

<ol>
  <li>如果一个实现定义了可用的调试工具并且是开启的，则 
    <ol>
      <li>执行实现定义的调试动作。 </li>

      <li>令 result 为实现定义的 Completion 值 .</li>
    </ol>
  </li>

  <li>否则 
    <ol>
      <li>令 result 为 (normal, empty, empty).</li>
    </ol>
  </li>

  <li>返回 result.</li>
</ol>


<h4>函数定义</h4>

<p>语法</p>

<pre> FunctionDeclaration :
   <b>function</b> Identifier <b>(</b> FormalParameterList<sub>opt</sub> <b>)</b> <b>{</b> FunctionBody <b>}</b></pre>

<pre> FunctionExpression :
   <b>function</b> Identifier<sub>opt</sub> <b>(</b> FormalParameterList<sub>opt</sub> <b>)</b> <b>{</b> FunctionBody <b>}</b></pre>

<pre> FormalParameterList :
   Identifier
   FormalParameterList <b>,</b> Identifier</pre>

<pre> FunctionBody :
   SourceElements<sub>opt</sub></pre>

<p>语义</p>

<p>产生式 <i>FunctionDeclaration</i> : <b>function</b> <i>Identifier</i> <b>(</b> <i>FormalParameterList</i><sub>opt</sub> <b>)</b> <b>{</b> <i>FunctionBody</i> <b>}</b> 依照定义绑定初始化 (<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=10.5&action=edit&redlink=1">10.5</a>) 如下初始化：</p>

<ol>
  <li>依照 13.2，指定 <i>FormalParameterList</i><sub>opt</sub> 为参数，指定 <i>FunctionBody</i> 为 body，创建一个新函数对象，返回结果。运行中的执行上下文的 <i>VariableEnvironment</i> 传递为 <i>Scope</i>。如果 <i>FunctionDeclaration</i> 包含在 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E4%BB%A3%E7%A0%81&action=edit&redlink=1">严格模式代码 </a>里或 <i>FunctionBody</i> 是 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E4%BB%A3%E7%A0%81&action=edit&redlink=1">严格模式代码 </a>，那么传递 true 为 <i>Strict</i> 标志。</li>
</ol>

<p>产生式 <i>FunctionExpression</i> : <b>function</b> <b>(</b> <i>FormalParameterList</i><sub>opt</sub> <b>)</b> <b>{</b> <i>FunctionBody</i> <b>}</b> 的解释执行如下：</p>

<ol>
  <li>依照 13.2，指定 <i>FormalParameterList</i><sub>opt</sub> 为参数，指定 <i>FunctionBody</i> 为 body，创建一个新函数对象，返回结果。运行中的执行上下文的 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=LexicalEnvironment&action=edit&redlink=1">LexicalEnvironment</a> 传递为 <i>Scope</i>。如果 <i>FunctionExpression</i> 包含在 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E4%BB%A3%E7%A0%81&action=edit&redlink=1">严格模式代码 </a>里或 <i>FunctionBody</i> 是 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E4%BB%A3%E7%A0%81&action=edit&redlink=1">严格模式代码 </a>，那么传递 true 为 <i>Strict</i> 标志。</li>
</ol>

<p>产生式 <i>FunctionExpression</i> : <b>function</b> <i>Identifier</i><sub>opt</sub> <b>(</b> <i>FormalParameterList</i><sub>opt</sub> <b>)</b> <b>{</b> <i>FunctionBody</i> <b>}</b> 的解释执行如下：</p>

<ol>
  <li>令 <i>funcEnv</i> 为以运行中执行上下文的 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Lexical_Environment&action=edit&redlink=1">Lexical Environment</a> 为参数调用 NewDeclarativeEnvironment 的结果。 </li>

  <li>令 <i>envRec</i> 为 <i>funcEnv</i> 的环境记录项。 </li>

  <li>以 <i>Identifier</i> 的字符串值为参数调用 <i>envRec</i> 的具体方法 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=CreateImmutableBinding&action=edit&redlink=1">CreateImmutableBinding</a>(N)。 </li>

  <li>令 <i>closure</i> 为依照 13.2，指定 <i>FormalParameterList</i><sub>opt</sub> 为参数，指定 <i>FunctionBody</i> 为 body，创建一个新函数对象的结果。传递 <i>funcEnv</i> 为 <i>Scope</i>。如果 <i>FunctionExpression</i> 包含在<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E4%BB%A3%E7%A0%81&action=edit&redlink=1">严格模式代码 </a>里或 <i>FunctionBody</i> 是 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E4%BB%A3%E7%A0%81&action=edit&redlink=1">严格模式代码 </a>，那么传递 true 为 <i>Strict</i> 标志。 </li>

  <li>以 Identifier 的字符串值和 closure 为参数调用 envRec 的具体方法 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=InitializeImmutableBinding&action=edit&redlink=1">InitializeImmutableBinding</a>(N,V)。 </li>

  <li>返回 closure。</li>
</ol>

<p>注： 可以从 FunctionExpression 的 FunctionBody 里面引用 FunctionExpression 的 Identifier，以允许函数递归调用自身。然而不像 FunctionDeclaration，FunctionExpression 的 Identifier 不能被范围封闭的 FunctionExpression 引用，也不会影响它。</p>

<p>产生式 <i>FunctionBody</i> : <i>SourceElements</i><sub>opt</sub> 的解释执行如下：</p>

<ol>
  <li>如果这个 FunctionBody 所在 FunctionDeclaration 或 FunctionExpression 包含在严格模式代码内，或其 SourceElements 的指令序言 (14.1) 包含一个 use strict 指令，或满足 10.1 的任何条件，那么其代码是严格模式代码。如果 FunctionBody 的代码是严格模式代码，SourceElements 的解释执行为以下的严格模式代码步骤。否则，SourceElements 的解释执行为以下的非严格模式步骤。 </li>

  <li>如果 SourceElements 是当前的，则返回 SourceElements 的解释执行结果。 </li>

  <li>否则返回 (normal, undefined, empty)。</li>
</ol>


<h4>严格的模式的限制</h4>

<p>如果严格模式 FunctionDeclaration 或 FunctionExpression 的 FormalParameterList 里出现多个相同 Identifier 值，那么这是个 SyntaxError。</p>

<p>如果严格模式 FunctionDeclaration 或 FunctionExpression 的 FormalParameterList 里出现标识符 "eval" 或标识符 "arguments"，那么这是个 SyntaxError。</p>

<p>如果严格模式 FunctionDeclaration 或 FunctionExpression 的 Identifier 是标识符 "eval" 或标识符 "arguments"，那么这是个 SyntaxError。</p>



<h4>创建函数对象</h4>

<p>指定 FormalParameterList 为可选参数列表，指定 FunctionBody 为函数体，指定 Scope 为 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=%E8%AF%8D%E6%B3%95%E7%8E%AF%E5%A2%83&action=edit&redlink=1">词法环境 </a>，Strict 为布尔标记，按照如下步骤构建函数对象：</p>

<ol>
  <li>创建一个新的 ECMAScript 原生对象，令 F 为此对象。 </li>

  <li>依照 8.12 描述设定 F 的除 [[Get]] 以外的所有内部方法。 </li>

  <li>设定 F 的 [[Class]] 内部属性为 "Function"。 </li>

  <li>设定 F 的 [[Prototype]] 内部属性为 15.3.3.1 指定的标准内置 Function 对象的 prototype 属性。 </li>

  <li>依照 15.3.5.4 描述，设定 F 的 [[Get]] 内部属性。 </li>

  <li>依照 13.2.1 描述，设定 F 的 [[Call]] 内部属性。 </li>

  <li>依照 13.2.2 描述，设定 F 的 [[Construct]] 内部属性。 </li>

  <li>依照 15.3.5.3 描述，设定 F 的 [[HasInstance]] 内部属性。 </li>

  <li>设定 F 的 [[Scope]] 内部属性为 Scope 的值。 </li>

  <li>令 names 为一个列表容器，其中元素是以从左到右的文本顺序对应 FormalParameterList 的标识符的字符串。 </li>

  <li>设定 F 的 [[FormalParameters]] 内部属性为 names。 </li>

  <li>设定 F 的 [[Code]] 内部属性为 FunctionBody。 </li>

  <li>设定 F 的 [[Extensible]] 内部属性为 true。 </li>

  <li>令 len 为 FormalParameterList 指定的形式参数的个数。如果没有指定参数，则令 len 为 0。 </li>

  <li>以参数 "length"，属性描述符 {[[Value]]: len, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false}，false 调用 F 的 [[DefineOwnProperty]] 内部方法。 </li>

  <li>令 proto 为仿佛使用 new Object() 表达式创建新对象的结果，其中 Object 是标准内置构造器名。 </li>

  <li>以参数 "constructor", 属性描述符 {[[Value]]: F, { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true}, false 调用 proto 的 [[DefineOwnProperty]] 内部方法。 </li>

  <li>以参数 "prototype", 属性描述符 {[[Value]]: proto, { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false}, false 调用 F 的 [[DefineOwnProperty]] 内部方法。 </li>

  <li>如果 Strict 是 true，则 
    <ol>
      <li>令 thrower 为 [[ThrowTypeError]] 函数对象 (13.2.3)。 </li>

      <li>以参数 "caller", 属性描述符 {[[Get]]: thrower, [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false}, false 调用 F 的 [[DefineOwnProperty]] 内部方法。 </li>

      <li>以参数 "caller", 属性描述符 {[[Get]]: thrower, [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false}, false 调用 F 的 [[DefineOwnProperty]] 内部方法。</li>
    </ol>
  </li>

  <li>返回 F。</li>
</ol>

<p>注： 每个函数都会自动创建一个 prototype 属性，以满足函数会被当作构造器的可能性。</p>



<h5>[[call]]</h5>

<p>当用一个 this 值，一个参数列表调用函数对象 F 的 [[Call]] 内部方法，采用以下步骤：</p>

<ol>
  <li>用 F 的 [[FormalParameters]] 内部属性值，参数列表 args，10.4.3 描述的 this 值来建立 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=%E5%87%BD%E6%95%B0%E4%BB%A3%E7%A0%81&action=edit&redlink=1">函数代码 </a>的一个新执行上下文，令 funcCtx 为其结果。 </li>

  <li>令 result 为 FunctionBody（也就是 F 的 [[Code]] 内部属性）解释执行的结果。如果 F 没有 [[Code]] 内部属性或其值是空的 FunctionBody，则 result 是 (normal, undefined, empty)。 </li>

  <li>退出 funcCtx 运行上下文，恢复到之前的执行运行上下文。 </li>

  <li>如果 result.type 是 throw 则抛出 result.value。 </li>

  <li>如果 result.type 是 return 则返回 result.value。 </li>

  <li>否则 result.type 必定是 normal。返回 undefined。</li>
</ol>


<h5>[[Construct]]</h5>

<p>当以一个可能的空的参数列表调用函数对象 F 的 [[Construct]] 内部方法，采用以下步骤：</p>

<ol>
  <li>令 obj 为新创建的 ECMAScript 原生对象。 </li>

  <li>依照 8.12 设定 obj 的所有内部方法。 </li>

  <li>设定 obj 的 [[Class]] 内部方法为 "Object"。 </li>

  <li>设定 obj 的 [[Extensible]] 内部方法为 true。 </li>

  <li>令 proto 为以参数 "prototype" 调用 F 的 [[Get]] 内部属性的值。 </li>

  <li>如果 Type(proto) 是 Object，设定 obj 的 [[Prototype]] 内部属性为 proto。 </li>

  <li>如果 Type(proto) 不是 Object，设定 obj 的 [[Prototype]] 内部属性为 15.2.4 描述的标准内置的 Object 的 prototype 对象。 </li>

  <li>以 obj 为 this 值，调用 [[Construct]] 的参数列表为 args，调用 F 的 [[Call]] 内部属性，令 result 为调用结果。 </li>

  <li>如果 Type(result) 是 Object，则返回 result。 </li>

  <li>返回 obj</li>
</ol>


<h5>[[ThrowTypeError]] 函数对象</h5>

<p>[[ThrowTypeError]] 对象是个唯一的函数对象，如下只定义一次：</p>

<ol>
  <li>创建一个新 ECMAScript 原生对象，令 F 为此对象。 </li>

  <li>依照 8.12 设定 F 的所有内部属性。 </li>

  <li>设定 F 的 [[Class]] 内部属性为 "Function"。 </li>

  <li>设定 F 的 [[Prototype]] 内部属性为 15.3.3.1 指定的标准内置 Function 的 prototype 对象。 </li>

  <li>依照 13.2.1 描述设定 F 的 [[Call]] 内部属性。 </li>

  <li>设定 F 的 [[Scope]] 内部属性为 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=%E5%85%A8%E5%B1%80%E7%8E%AF%E5%A2%83&action=edit&redlink=1">全局环境 </a>。 </li>

  <li>设定 F 的 [[FormalParameters]] 内部属性为一个空 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=%E5%88%97%E8%A1%A8&action=edit&redlink=1">列表 </a>。 </li>

  <li>设定 F 的 [[Code]] 内部属性为一个 FunctionBody，它无条件抛出一个 TypeError 异常，不做其他事情。 </li>

  <li>以参数 "length", 属性描述符 {[[Value]]: 0, [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false}, false 调用 F 的 [[DefineOwnProperty]] 内部方法。 </li>

  <li>设定 F 的 [[Extensible]] 内部属性为 false。 </li>

  <li>令 [[ThrowTypeError]] 为 F。</li>
</ol>


<h4>程序</h4>

<p>语法：</p>

<pre>   Program :
       SourceElements<sub>opt</sub></pre>

<pre>   SourceElements :
       SourceElement 
       SourceElements SourceElement</pre>

<pre>   SourceElement :
       Statement 
       FunctionDeclaration</pre>

<p>语义：</p>

<p>产生式 <i>Program</i> : <i>SourceElements<sub>opt</sub></i> 依照下面的步骤来解释执行 :</p>

<ol>
  <li>若 SourceElements 的指令序言 ( 参考 14.1 章 ) 中 , 包含严格模式指令 , 或者满足 10.1.1 章节所描述的任何一个条件 . 则 <i>Program</i> 的代码 . 就是一段严格模式代码 . 并对应性的 , 以严格模式或非严格模式 , 依照下面列出的步骤来解释执行代码 . </li>

  <li>若没有 <i>SourceElements</i> 部分 , 则返回 (normal, empty, empty). </li>

  <li>令 <i>progCxt</i> 为一个新的 , 如 10.4.1 章节所描述的 , 应用于全局代码的执行环境 . </li>

  <li>令 <i>result</i> 为解释执行 <i>SourceElements</i> 的结果 . </li>

  <li>退出 <i>progCxt</i> 这个执行环境 . </li>

  <li>返回 <i>result</i>.</li>
</ol>

<p>注： 本规范不会规定 , 具体如何解释执行一个 Program 以及如何处理其结果 . 其具体行为由 ECMAScript 实现 , 自行定义</p>

<p>产生式 <i>SourceElements </i> : <i>SourceElements SourceElement</i> 依照下面的步骤来解释执行 :</p>

<ol>
  <li>令 <i>headResult</i> 为解释执行 <i>SourceElements</i> 的结果 . </li>

  <li>若 <i>headResult</i> 是非常规性完结的 , 返回 <i>headResult</i>. </li>

  <li>令 <i>tailResult</i> 为解释执行 <i>SourceElement</i> 的结果 . </li>

  <li>若 <i>tailResult</i>.value 为 empty, 令 V = <i>headResult</i>.value, 其他情况 , 另 V = <i>tailResult</i>.value. </li>

  <li>返回 (tailResult.type, V, tailResult.target).</li>
</ol>

<p>产生式 : <i>SourceElement</i> : <i>Statement</i> 依照下面的步骤来解释执行 :</p>

<ol>
  <li>返回解释执行 <i>Statement</i> 的结果 .</li>
</ol>

<p>产生式 : <i>SourceElement</i> : <i>FunctionDeclaration</i> 依照下面的步骤来解释执行 :</p>

<ol>
  <li>返回 (normal, empty, empty)</li>
</ol>



<h4>指令序言和严格模式指令 .</h4>

<p>一个指令序言 , 是那些从 <i>Program</i> 或 <i>FunctionBody</i> 的首个 <i>SourceElement</i> 开始，到那些完全由一个字符串字面量后面跟一个分号 , 所构成的最长的 . 那一组 <i>ExpressionStatement</i> 序列中的每一个 . 字符串字面量后面的分号 , 可以显式的插入 , 或者借助分号自动插入机制来插入 . 一个指令序言 , 也可以是一个空的序列 .</p>

<p>严格模式指令是一个 "use strict" 或 'use strict' 的字符串字面量 . 一个严格模式指令中 , 不应该包含 <i>EscapeSequence</i> 或 <i>LineContinuation</i>.</p>

<p>一个指令序言 , 可以不仅仅包含一个严格模式指令 . 然而 , 当这种情况出现的时候 ,ECMAScript 实现 , 可以发出一个相关警告 .</p>

<p>注： 指令序言包含的 <i>ExpressionStatement</i> 产生式们，会在解释执行包含他们的 <i>SourceElements</i> 产生式期间 , 被正常的解析执行 . ECMAScript 实现 , 可以在一个指令序言中定义其他非严格模式指令 . 当一个指令序言中的某个 <i>ExpressionStatement</i> 并不是一个严格模式指令，也不是一个被 ECMAScript 实现所定义的指令 . 且存在某种通知机制的话 . 就要借助该机制 , 发出一个警告 .</p>



<h4>标准 ECMAScript 内置对象</h4>
<p>ECMAScript 代码运行时会有一些可用的内置对象。一是作为执行程序词法环境的一部分的全局对象。其他的可通过全局对象的初始属性访问。</p>

<p>除非另外指明，如果内置对象拥有 [[Call]] 内部属性，那么它的 [[Class]] 内部属性是 &quot;<b>Function</b>&quot;，如果没有 [[Call]] 内部属性，那么它的 [[Class]] 内部属性是 &quot;<b>Object</b>&quot;。除非另外指明，内置对象的 [[Extensible]] 内部属性的初始值是 true。</p>

<p>许多内置对象是函数：它们可以通过参数调用。其中有些还作为构造器：这些函数可被 <b>new</b> 运算符调用。对于每个内置函数，本规范描述了这些函数的必须参数和 Function 对象的属性。对于每个内置构造器，本规范还描述了这些构造器的 prototype 对象的属性，还描述了用 <b>new</b> 表达式调用这个构造器后返回的具体实例对象的属性。</p>

<p>除非另外指明了某一特定函数的描述，如果在调用本章中描述的函数或构造器时传入的参数少于必须的参数个数，那么这些函数或构造器将表现为仿佛传入了足够的参数，而那些缺少的参数会设定为 <b>undefined</b> 值。</p>

<p>除非另外指明了某一特定函数的描述，如果在调用本章中描述的函数或构造器时传入了比函数指定允许的更多的参数时，额外的参数会被函数忽略。然而，一个实现可以为这样的参数列表定义依赖于实现的特别行为，只要这种行为在单纯添加额外参数时不抛出 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=TypeError&amp;action=edit&amp;redlink=1">TypeError</a> 异常。</p>

<p>注： 实现为了给内置函数集合增添一些额外功能而添加新函数是被鼓励的，而不是为现有函数增加新参数。</p>

<p>每个内置函数和每个内置构造器都有 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Function_%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1&amp;action=edit&amp;redlink=1">Function 原型对象 </a>，<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Function.prototype&amp;action=edit&amp;redlink=1">Function.prototype</a>（<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=15.3.4&amp;action=edit&amp;redlink=1">15.3.4</a>）表达式的初始值作为其 [[Prototype]] 内部属性的值。</p>

<p>除非另外指明，每个内置的原型对象都有 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Object_%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1&amp;action=edit&amp;redlink=1">Object 原型对象 </a>，<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Object.prototype&amp;action=edit&amp;redlink=1">Object.prototype</a>(<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=15.2.4&amp;action=edit&amp;redlink=1">15.2.4</a>) 表达式的初始值作为其 [[Prototype]] 内部属性的值，除了 Object 的原型对象自身。</p>

<p>除非另外指明了特定函数的描述，否则本章描述的内置函数中不存在不是构造器而要实现 [[Construct]] 内部方法的内置函数。除非另外指明了特定函数的描述，否则本章描述的内置函数都没有 <b>prototype</b> 属性。</p>

<p>本章通常描述构造器的“作为函数调用”和“用 new 表达式调用” 有不同行为。&quot; 作为函数调用 &quot; 的行为对应于调用构造器的 [[Call]] 内部方法，“用 new 表达式调用”的行为对应于调用构造器的 [[Construct]] 内部方法。</p>

<p>本章描述的每个内置 Function 对象 -- 不管是构造器还是普通函数，或二者都是 -- 拥有一个 length 属性，其值是个整数。除非另外指明，此值等于显示在函数描述的子章节标题的形式参数的个数，包括可选参数。</p>

<p>注： 例如描述 String 的 prototype 对象的 slice 属性初始值的函数对象的子章节标题是“String.prototype.slice (start, end)”，这说明有两个形参 start 和 end，所以这个函数对象的 length 属性值是 2。</p>

<p>任何情况下，本章描述的内置函数对象的 length 属性拥有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。除非另外指明，本章描述的所有其他属性拥有特性 { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true }。</p>



<h4>全局对象</h4>

<p>唯一的全局对象建立在控制进入任何执行上下文之前。</p>

<p>除非另外指明，全局对象的标准内置属性拥有特性 {[[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true}。</p>

<p>全局对象没有 [[Construct]] 内部属性 ; 全局对象不可能当做构造器用 <b>new</b> 运算符调用。</p>

<p>全局对象没有 [[Call]] 内部属性，全局对象不可能当做函数来调用。</p>

<p>全局对象的 [[Prototype]] 和 [[Class]] 内部属性值是依赖于实现的。</p>

<p>除了本规范定义的属性之外，全局对象还可以拥有额外的宿主定义的属性。全局对象可包含一个值是全局对象自身的属性；例如，在 HTML 文档对象模型中全局对象的 window 属性是全局对象自身。</p>



<h5>全局对象的值属性</h5>


<h6>NaN</h6>

<p><b>NaN</b> 的值是 <b>NaN</b>（见 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=8.5&amp;action=edit&amp;redlink=1">8.5</a>）。这个属性拥有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。</p>



<h6>Infinity</h6>

<p><b>Infinity</b> 的值是 <b>+∞</b>（见 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=8.5&amp;action=edit&amp;redlink=1">8.5</a>）。这个属性拥有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。</p>



<h6>undefined</h6>

<p><b>undefined</b> 的值是 <b>undefined</b>（见 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=8.1&amp;action=edit&amp;redlink=1">8.1</a>）。这个属性拥有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。</p>



<h5>全局对象的函数属性</h5>


<h6>eval (x)</h6>

<p>当用一个参数 x 调用 eval 函数，采用如下步骤：</p>

<ol>
  <li>如果 Type(x) 不是 String, 返回 x. </li>

  <li>令 prog 为 ECMAScript 代码，它是将 x 作为一个程序解析的结果。如果解析失败，抛出一个 SyntaxError 异常 ( 见 16 章 )。 </li>

  <li>令 evalCtx 为给 eval 代码 prog 建立的新执行上下文 (<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=10.4.2&amp;action=edit&amp;redlink=1">10.4.2</a>)。 </li>

  <li>令 result 为解释执行程序 prog 的结果。 </li>

  <li>退出执行上下文 evalCtx, 恢复到之前的执行上下文。 </li>

  <li>如果 result.type 是 normal 并且其完结类型值是 V, 则返回 V 值 . </li>

  <li>如果 result.type 是 normal 并且其完结类型值是 empty, 则返回 undefined 值 . </li>

  <li>否则，result.type 必定是 throw。将 result.value 作为异常抛出 .</li>
</ol>


<h6>直接调用 Eval</h6>

<p>一个 eval 函数的直接调用是表示为符合以下两个条件的 CallExpression：</p>

<p>解释执行 CallExpression 中的 MemberExpression 的结果是个 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=%E5%BC%95%E7%94%A8&amp;action=edit&amp;redlink=1">引用 </a>，这个引用拥有一个 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=%E7%8E%AF%E5%A2%83%E8%AE%B0%E5%BD%95%E9%A1%B9&amp;action=edit&amp;redlink=1">环境记录项 </a>作为其基值，并且这个引用的名称是 &quot;eval&quot;。</p>

<p>以这个 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=%E5%BC%95%E7%94%A8&amp;action=edit&amp;redlink=1">引用 </a>作为参数调用 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=GetValue&amp;action=edit&amp;redlink=1">GetValue</a> 抽象操作的结果是 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=15.1.2.1&amp;action=edit&amp;redlink=1">15.1.2.1</a> 定义的标准内置函数。</p>



<h6>parseInt (string , radix)</h6>

<p>parseInt 函数根据指定的参数 radix，和 string 参数的内容解释结果来决定，产生一个整数值。string 开头的空白会被忽略。如果 radis 是 undefined 或 0，假定它是 10，除非数字是以字符对 0x 或 0X 开头的，这时假定 radix 是 16。如果 radix 是 16，数字开头的字符对 0x 或 0X 是可选的。</p>

<p>当调用 parseInt 函数时，采用以下步骤：</p>

<ol>
  <li>令 inputString 为 ToString(string)。 </li>

  <li>令 S 为一个新创建的子字符串，它由 inputString 的第一个非 StrWhiteSpaceChar 字符和它后面跟着的所有字符组成。( 换句话说 , 删掉前面的空白。) 如果 inputString 不包含任何这样的字符 , 则令 S 为空字符串。 </li>

  <li>令 sign 为 1。 </li>

  <li>如果 S 不是空并且 S 的第一个字符是减号 -, 则令 sign 为−1。 </li>

  <li>如果 S 不是空并且 S 的第一个字符加号 + 或减号 -, 则删除 S 的第一个字符。 </li>

  <li>令 R = ToInt32(radix). </li>

  <li>令 stripPrefix 为 true. </li>

  <li>如果 R ≠ 0, 则 
    <ol>
      <li>如果 R &lt; 2 或 R &gt; 36, 则返回 NaN。 </li>

      <li>如果 R ≠ 16, 令 stripPrefix 为 false.</li>
    </ol>
  </li>

  <li>否则 , R = 0 
    <ol>
      <li>令 R = 10.</li>
    </ol>
  </li>

  <li>如果 stripPrefix 是 true, 则 
    <ol>
      <li>如果 S 长度大于 2 并且 S 的头两个字符是“0x”或“0X”, 则删除 S 的头两个字符并且令 R = 16.</li>
    </ol>
  </li>

  <li>如果 S 包含任何不是 radix-R 进制的字符，则令 Z 为 S 的这样的字符之前的所有字符组成的子字符串；否则令 Z 为 S。. </li>

  <li>如果 Z 是空 , 返回 NaN. </li>

  <li>令 mathInt 为 Z 的 radix-R 进制表示的数学值，用字母 A-Z 和 a-z 来表示 10 到 35 之间的值。( 但是 , 如果 R 是 10 并且 Z 包含多余 20 位的值 , 可以替换 20 位后的每个数字为 0, 这是实现可选的功能 ; 如果 R 不是 2, 4, 8, 10, 16, 32, 则 mathInt 可以是 Z 的 radix-R 进制表示的依赖于实现的近似值。) </li>

  <li>令 number 为 mathInt 的数值 . </li>

  <li>返回 sign × number.</li>
</ol>

<p>注：parseInt 可以只把 string 的开头部分解释为整数值；它会忽略所有不能解释为整数记法的一部分的字符，并且没有指示会给出任何这些忽略的字符。</p>



<h6>parseFloat (string)</h6>

<p>parseFloat 函数根据 string 参数的内容解释为十进制字面量的结果来决定，产生一个数值。</p>

<p>当调用 parseFloat 函数，采用以下步骤：</p>

<ol>
  <li>令 inputString 为 ToString(string). </li>

  <li>令 trimmedString 为一个新创建的子字符串，它由 inputString 的非 StrWhiteSpaceChar 字符的最左边字符和它右边跟着的所有字符组成。( 换句话说 , 删掉前面的空白。) 如果 inputString 不包含任何这样的字符 , 则令 trimmedString 为空字符串。 </li>

  <li>如果 trimmedString 或 trimmedString 的任何前缀都不满足 StrDecimalLiteral ( 见 9.3.1) 的语法 , 返回 NaN。 </li>

  <li>令 numberString 为满足 StrDecimalLiteral 语法的 trimmedString 的最长前缀，可能是 numberString 自身。 </li>

  <li>返回 numberString 的 MV 的数值。</li>
</ol>

<p>注：parseFloat 可以只把 string 的开头部分解释为数值；它会忽略所有不能解释为数值字面量记法的一部分的字符，并且没有指示会给出任何这些忽略的字符。</p>



<h6>isNaN (number)</h6>

<p>如果指定参数为 NaN，则返回 true，否则返回 false。</p>

<ol>
  <li>如果 ToNumber(number) 是 NaN, 返回 true. </li>

  <li>否则 , 返回 false.</li>
</ol>

<p>注： 一个用 ECMAScript 代码来测试值 X 是否是 NaN 的方式是用 X !== X 表达式。当且仅当 X 是 NaN 时结果才是 true。</p>



<h6>isFinite (number)</h6>

<p>如果指定参数为 NaN 或 +∞或−∞，则返回 false，否则返回 true。</p>

<ol>
  <li>如果 ToNumber(number) 是 NaN 或 +∞或−∞, 返回 false. </li>

  <li>否则 , 返回 true.</li>
</ol>


<h5>处理 URI 的函数属性</h5>

<p>统一资源标识符，或叫做 URI，是用来标识互联网上的资源（例如，网页或文件）和怎样访问这些资源的传输协议（例如，HTTP 或 FTP）的字符串。除了 15.1.3.1, 15.1.3.2, 15.1.3.3，15.1.3.4 说明的用来编码和解码 URI 的函数之外 ECMAScript 语言自身不提供任何使用 URL 的支持。</p>

<p>注： 许多 ECMAScript 实现提供额外的函数，方法来操作网页；这些函数超出了本标准的范围。</p>

<p>一个 URI 是由组件分隔符分割的组件序列组成。其一般形式是：</p>

<p><i>Scheme</i> : <i>First</i> / <i>Second</i> ; <i>Third</i> ? <i>Fourth</i></p>

<p>其中斜体的名字代表组件；“:”, “/”, “;”，“?”是当作分隔符的保留字符。encodeURI 和 decodeURI 函数操作的是完整的 URI；这俩函数假定 URI 中的任何保留字符都有特殊意义，所有不会编码它们。encodeURIComponent 和 decodeURIComponent 函数操作的是组成 URI 的个别组件；这俩函数假定任何保留字符都代表普通文本，所以必须编码它们，所以它们出现在组成一个完整 URI 的组件里面时不会解释成保留字符了。</p>

<p>以下词法文法指定了编码后 URI 的形式。</p>

<p>语法</p>

<pre> uri :::
   uriCharacters<sub>opt</sub></pre>

<pre> uriCharacters :::
   uriCharacter uriCharacters<sub>opt</sub></pre>

<pre> uriCharacter :::
   uriReserved
   uriUnescaped
   uriEscaped</pre>

<pre> uriReserved ::: <b>one of</b>
   <b>; / ? : @ &amp; = + $ ,</b></pre>

<pre> uriUnescaped :::
   uriAlpha
   DecimalDigit
   uriMark</pre>

<pre> uriEscaped :::
   <b>%</b> HexDigit HexDigit</pre>

<pre> uriAlpha ::: <b>one of</b>
   <b>a b c d e f g h i j k l m n o p q r s t u v w x y z</b>
   A B C D E F G H I J K L M N O P Q R S T U V W X Y Z</pre>

<pre> uriMark ::: <b>one of</b>
   <b>- _ . ! ~ * ' ( )</b></pre>

<p>注： 以上语法是基于 <a href="http://tools.ietf.org/html/rfc2396">RFC 2396</a> 的，并且较新的 <a href="http://tools.ietf.org/html/rfc3986">RFC 3986</a> 引入的更改没有反应在这里。</p>

<p>当 URI 里包含一个没在上面列出的字符或有时不想让给定的保留字符有特殊意义，那么必须编码这个字符。字符被转换成 UTF-8 编码，首先从 UT​​F-16 转换成相应的代码点值的替代对。（注：在 [0,127] 范围的代码单元在单字节中具有相同返回值。）然后返回的字节序列转换为一个字符串，每个字节用一个“%xx”形式的转移序列表示。</p>

<p>描述编码和转义过程的抽象操作 Encode 需要两个字符串参数 string 和 unescapedSet。</p>

<ol>
  <li>令 strLen 为 string 的字符个数 . </li>

  <li>令 R 为空字符串 . </li>

  <li>令 k 为 0. </li>

  <li>重复 
    <ol>
      <li>如果 k 等于 strLen, 返回 R. </li>

      <li>令 C 为 string 中位置为 k 的字符 . </li>

      <li>如果 C 在 unescapedSet 里 , 则 
        <ol>
          <li>令 S 为一个只包含字符 C 的字符串 . </li>

          <li>令 R 为之前 R 的值和 S 连接得到的一个新字符串值 .</li>
        </ol>
      </li>

      <li>否则 , C 不在 unescapedSet 里 
        <ol>
          <li>如果 C 的代码单元值不小于 0xDC00 并且不大于 0xDFFF, 则抛出一个 URIError 异常 . </li>

          <li>如果 C 的代码单元值小于 0xD800 或大于 0xDBFF, 则 
            <ol>
              <li>令 V 为 C 的代码单元值 .</li>
            </ol>
          </li>

          <li>否则 , 
            <ol>
              <li>k 递增 1. </li>

              <li>如果 k 等于 strLen, 抛出一个 URIError 异常 . </li>

              <li>令 kChar 为 string 的 k 位置的字符的代码单元值 . </li>

              <li>如果 kChar 小于 0xDC00 或大于 0xDFFF, 则抛出一个 URIError 异常 . </li>

              <li>令 V 为 (((C 的代码单元值 ) – 0xD800) * 0x400 + (kChar – 0xDC00) + 0x10000).</li>
            </ol>
          </li>

          <li>令 Octets 为 V 执行 UTF-8 转换的结果字节排列 , 令 L 为这个字节排列的长度 . </li>

          <li>令 j 为 0. </li>

          <li>只要 j &lt; L，就重复 
            <ol>
              <li>令 jOctet 为 Octets 的 j 位置的值 . </li>

              <li>令 S 为一个包含三个字符“%XY”的字符串，这里 XY 是编码 jOctet 值的两个大写 16 进制数字 . </li>

              <li>令 R 为之前 R 的值和 S 连接得到的一个新字符串值 . </li>

              <li>j 递增 1.</li>
            </ol>
          </li>
        </ol>
      </li>

      <li>k 递增 1.</li>
    </ol>
  </li>
</ol>

<p>描述反转义和解码过程的抽象操作 Decode 需要两个字符串参数 string 和 reservedSet。</p>

<ol>
  <li>令 strLen 为 string 的字符个数 . </li>

  <li>令 R 为空字符串 . </li>

  <li>令 k 为 0. </li>

  <li>重复 
    <ol>
      <li>如果 k 等于 strLen, 返回 R. </li>

      <li>令 C 为 string 的 k 位置的字符 . </li>

      <li>如果 C 不是‘%’, 则 
        <ol>
          <li>令 S 为只包含字符 C 的字符串 .</li>
        </ol>
      </li>

      <li>否则 , C 是‘%’ 
        <ol>
          <li>令 start 为 k. </li>

          <li>如果 k + 2 大于或等于 strLen, 抛出一个 URIError 异常 . </li>

          <li>如果 string 的 (k+1) 和 (k + 2) 位置的字符没有表示为 16 进制数字，则抛出一个 URIError 异常 . </li>

          <li>令 B 为 (k + 1) 和 (k + 2) 位置的两个 16 进制数字表示的 8 位值 . </li>

          <li>k 递增 2. </li>

          <li>如果 B 的最高有效位是 0, 则 
            <ol>
              <li>令 C 为代码单元值是 B 的字符 . </li>

              <li>如果 C 不在 reservedSet 里 , 则 
                <ol>
                  <li>令 S 为只包含字符 C 的字符串 .</li>
                </ol>
              </li>

              <li>否则 , C 在 reservedSet 里 
                <ol>
                  <li>令 S 为 string 的从位置 start 到位置 k 的子字符串 .</li>
                </ol>
              </li>
            </ol>
          </li>

          <li>否则 , B 的最高有效位是 1 
            <ol>
              <li>令 n 为满足 (B &lt;&lt; n) &amp; 0x80 等于 0 的最小非负数 . </li>

              <li>如果 n 等于 1 或 n 大于 4, 抛出一个 URIError 异常 . </li>

              <li>令 Octets 为一个长度为 n 的 8 位整数排列 . </li>

              <li>将 B 放到 Octets 的 0 位置 . </li>

              <li>如果 k + (3 * (n – 1)) 大于或等于 strLen, 抛出一个 URIError 异常 . </li>

              <li>令 j 为 1. </li>

              <li>重复 , 直到 j &lt; n 
                <ol>
                  <li>k 递增 1. </li>

                  <li>如果 string 的 k 位置的字符不是‘%’, 抛出一个 URIError 异常 . </li>

                  <li>如果 string 的 (k +1) 和 (k+2) 位置的字符没有表示为 16 进制数字 , 抛出一个 URIError 异常 . </li>

                  <li>令 B 为 string 的 (k +1) 和 (k+2) 位置的两个 16 进制数字表示的 8 位值 . </li>

                  <li>如果 B 的两个最高有效位不是 10，抛出一个 URIError 异常 . </li>

                  <li>k 递增 2. </li>

                  <li>将 B 放到 Octets 的 j 位置 . </li>

                  <li>j 递增 1.</li>
                </ol>
              </li>

              <li>令 V 为给 Octets 执行 UTF-8 转换得到的值，这是从一个字节排列到一个 32 位值的过程。 如果 Octets 不包含有效的 UTF-8 编码的 Unicode 代码点，则抛出一个 URIError 异常 . </li>

              <li>如果 V 小于 0x10000, 则 
                <ol>
                  <li>令 C 为代码单元值是 V 的字符 . </li>

                  <li>如果 C 不在 reservedSet 里 , 则 
                    <ol>
                      <li>令 S 为只包含字符 C 的字符串 .</li>
                    </ol>
                  </li>

                  <li>否则 , C 在 reservedSet 里 
                    <ol>
                      <li>令 S 为 string 的从位置 start 到位置 k 的子字符串 .</li>
                    </ol>
                  </li>
                </ol>
              </li>

              <li>否则 , V ≥ 0x10000 
                <ol>
                  <li>令 L 为 (((V – 0x10000) &amp; 0x3FF) + 0xDC00). </li>

                  <li>令 H 为 ((((V – 0x10000) &gt;&gt; 10) &amp; 0x3FF) + 0xD800). </li>

                  <li>令 S 为代码单元值是 H 和 L 的两个字符组成的字符串 .</li>
                </ol>
              </li>
            </ol>
          </li>
        </ol>
      </li>
    </ol>
  </li>

  <li>令 R 为之前的 R 和 S 连接成的新字符串 . </li>

  <li>k 递增 1.</li>
</ol>

<p>注： 统一资源标识符的语法由 <a href="http://tools.ietf.org/html/rfc2396">RFC 2396</a> 给出，这里并没有反应更新的替换了 <a href="http://tools.ietf.org/html/rfc2396">RFC 2396</a> 的 <a href="http://tools.ietf.org/html/rfc3986">RFC 3986</a>。<a href="http://tools.ietf.org/html/rfc3629">RFC 3629</a> 给出了实现 UTF-8 的正式描述。</p>

<p>在 UTF-8 中，用 1 到 6 个字节的序列来编码字符。只有“序列”中高阶位设置为 0 的字节，其余的 7 位才用于编码字符值。在一个 n 个字节的序列中，n&gt;1，初始字节有 n 个设置为 1 的高阶位，其后的位设置为 0。这个字节的其他位包含是用来编码字符的比特。后面跟着的其字节都包含设定为 1 的高阶位，并且都跟着设定为 0 的位，剩下的 6 位都用作编码字符。表 21 指定了 ECMAScript 字符可能的 UTF-8 编码。</p>
<div>
<p>Table 21 — UTF-8 Encodings</p>

<p>Code Unit Value
  <br />Representation

  <br />1st Octet

  <br />2nd Octet

  <br />3rd Octet

  <br />4th Octet</p>

<p>0x0000 - 0x007F
  <br />00000000 0zzzzzzz

  <br />0zzzzzzz</p>

<p>0x0080 - 0x07FF
  <br />00000yyy yyzzzzzz

  <br />110yyyyy

  <br />10zzzzzz</p>

<p>0x0800 - 0xD7FF
  <br />xxxxyyyy yyzzzzzz

  <br />1110xxxx

  <br />10yyyyyy

  <br />10zzzzzz</p>

<p>0xD800 - 0xDBFF </p>

<p>followed by 0xDC00 – 0xDFFF</p>

<p>110110vv vvwwwwxx </p>

<p>followed by 110111yy yyzzzzzz</p>

<p>11110uuu
  <br />10uuwwww

  <br />10xxyyyy

  <br />10zzzzzz</p>

<p>0xD800 - 0xDBFF </p>

<p>not followed by 0xDC00 – 0xDFFF</p>

<p>causes URIError</p>

<p>0xDC00 – 0xDFFF
  <br />causes URIError</p>

<p>0xE000 - 0xFFFF
  <br />xxxxyyyy yyzzzzzz

  <br />1110xxxx

  <br />10yyyyyy

  <br />10zzzzzz</p></div>

<p>在这里</p>

<p>uuuuu = vvvv + 1</p>

<p>来访问附加的作为代理项的 0x10000，在 Unicode 标准 3.7 章节。</p>

<p>0xD800-0xDFFF 范围的代码单元值用来编码代理对；如上将 UTF-16 代理对转换组合成一个 UTF-32 表示，并编码 UTF-8 值的 21 位结果。解码重建代理对。</p>

<p><a href="http://tools.ietf.org/html/rfc3629">RFC 3629</a> 禁止对无效 UTF-8 字节序列的解码。例如，无效序列 C0 80 不能解码成字符 U+0000。当 Decode 算法的实现遇到这样的无效序列必须抛出一个 URIError 异常。</p>



<h6>decodeURI (encodedURI)</h6>

<p>decodeURI 函数计算出一个新版 URI，将 URI 中可能是 encodeURI 函数引入的每个转义序列和 UTF-8 编码组替换为代表它们的字符。不是 encodeURI 导入的转义序列不会被替换。</p>

<p>当以一个参数 encodedURI 调用 decodeURI 函数，采用如下步骤：</p>

<ol>
  <li>令 uriString 为 ToString(encodedURI). </li>

  <li>令 reservedURISet 为一个字符串，包含 uriReserved 的每个有效字符加上 &quot;#&quot; 的实例。 </li>

  <li>返回调用 Decode(uriString, reservedURISet) 的结果。</li>
</ol>

<p>注：&quot;#&quot; 字符不会从转义序列中解码，即使它不是 URI 保留字符。</p>



<h6>decodeURIComponent (encodedURIComponent)</h6>

<p>decodeURIComponent 函数计算出一个新版 URI，将 URI 中可能是 encodeURIComponent 函数引入的每个转义序列和 UTF-8 编码组替换为代表它们的字符。</p>

<p>当以一个参数 encodedURIComponent 调用 decodeURIComponent 函数，采用如下步骤：</p>

<ol>
  <li>令 componentString 为 ToString(encodedURIComponent). </li>

  <li>令 reservedURIComponentSet 为一个空字符串。 </li>

  <li>返回调用 Decode(componentString, reservedURIComponentSet) 的结果。</li>
</ol>


<h6>encodeURI (uri)</h6>

<p>encodeURI 函数计算出一个新版 URI，将 URI 中某些字符的每个实例替换为代表这些字符 UTF-8 编码的一个，两个或三个转义序列。</p>

<p>当以一个参数 uri 调用 encodeURI 函数，采用如下步骤：</p>

<ol>
  <li>令 uriString 为 ToString(uri). </li>

  <li>令 unescapedURISet 为一个字符串，包含 uriReserved 和 uriUnescaped 的每个有效字符加上 &quot;#&quot; 的实例。 </li>

  <li>返回调用 Encode(uriString, unescapedURISet) 的结果。</li>
</ol>

<p>字符 &quot;#&quot; 不会被编码为一个转义序列，即使它不是 URI 保留字符或非转义字符。</p>



<h6>encodeURIComponent (uriComponent)</h6>

<p>encodeURIComponent 函数计算出一个新版 URI，将 URI 中某些字符的每个实例替换为代表这些字符 UTF-8 编码的一个，两个或三个转义序列。</p>

<p>当以一个参数 uriComponent 调用 encodeURIComponent 函数，采用如下步骤：</p>

<ol>
  <li>令 componentString 为 ToString(uriComponent). </li>

  <li>令 unescapedURIComponentSet 为一个字符串，包含 uriUnescaped 的每个有效字符的实例。 </li>

  <li>返回调用 Encode(componentString, unescapedURIComponentSet) 的结果。</li>
</ol>


<h5>全局对象的构造器属性</h5>


<h6>Object ( . . . )</h6>

<p>见 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E6%A0%87%E5%87%86_ECMAScript_%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1#.E4.BD.9C.E4.B8.BA.E5.87.BD.E6.95.B0.E8.B0.83.E7.94.A8Object.E6.9E.84.E9.80.A0.E5.99.A8">15.2.1</a> 和 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E6%A0%87%E5%87%86_ECMAScript_%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1#Object.E6.9E.84.E9.80.A0.E5.99.A8">15.2.2</a>.</p>



<h6>Function ( . . . )</h6>

<p>见 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E6%A0%87%E5%87%86_ECMAScript_%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1#Object.prototype">15.3.1</a> 和 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E6%A0%87%E5%87%86_ECMAScript_%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1#Object.getPrototypeOf_.28_O_.29">15.3.2</a></p>



<h6>Array ( . . . )</h6>

<p>见 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E6%A0%87%E5%87%86_ECMAScript_%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1#.E4.BD.9C.E4.B8.BA.E5.87.BD.E6.95.B0.E8.B0.83.E7.94.A8Array.E6.9E.84.E9.80.A0.E5.99.A8">15.4.1</a> 和 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E6%A0%87%E5%87%86_ECMAScript_%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1#Array.E6.9E.84.E9.80.A0.E5.99.A8">15.4.2</a>.</p>



<h6>String ( . . . )</h6>

<p>见 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E6%A0%87%E5%87%86_ECMAScript_%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1#.E4.BD.9C.E4.B8.BA.E5.87.BD.E6.95.B0.E8.B0.83.E7.94.A8String.E6.9E.84.E9.80.A0.E5.99.A8">15.5.1</a> 和 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E6%A0%87%E5%87%86_ECMAScript_%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1#String.E6.9E.84.E9.80.A0.E5.99.A8">15.5.2</a>.</p>



<h6>Boolean ( . . . )</h6>

<p>见 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E6%A0%87%E5%87%86_ECMAScript_%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1#.E4.BD.9C.E4.B8.BA.E5.87.BD.E6.95.B0.E8.B0.83.E7.94.A8.E5.B8.83.E5.B0.94.E6.9E.84.E9.80.A0.E5.99.A8">15.6.1</a> 和 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E6%A0%87%E5%87%86_ECMAScript_%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1#.E5.B8.83.E5.B0.94.E6.9E.84.E9.80.A0.E5.99.A8">15.6.2</a>.</p>



<h6>Number ( . . . )</h6>

<p>见 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E6%A0%87%E5%87%86_ECMAScript_%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1#.E4.BD.9C.E4.B8.BA.E5.87.BD.E6.95.B0.E8.B0.83.E7.94.A8.E7.9A.84Number.E6.9E.84.E9.80.A0.E5.99.A8">15.7.1</a> 和 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E6%A0%87%E5%87%86_ECMAScript_%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1#Number.E6.9E.84.E9.80.A0.E5.99.A8">15.7.2</a>.</p>



<h6>Date ( . . . )</h6>

<p>见 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E6%A0%87%E5%87%86_ECMAScript_%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1#.E4.BD.9C.E4.B8.BA.E5.87.BD.E6.95.B0.E8.B0.83.E7.94.A8Date.E6.9E.84.E9.80.A0.E5.99.A8">15.9.2</a>.</p>



<h6>RegExp ( . . . )</h6>

<p>见 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E6%A0%87%E5%87%86_ECMAScript_%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1#The_RegExp_Constructor_Called_as_a_Function">15.10.3</a> 和 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E6%A0%87%E5%87%86_ECMAScript_%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1#The_RegExp_Constructor">15.10.4</a>.</p>



<h6>Error ( . . . )</h6>

<p>见 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E6%A0%87%E5%87%86_ECMAScript_%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1#The_Error_Constructor_Called_as_a_Function">15.11.1</a> 和 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E6%A0%87%E5%87%86_ECMAScript_%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1#The_Error_Constructor">15.11.2</a>.</p>



<h6>EvalError ( . . . )</h6>

<p>见 15.11.6.1.</p>



<h6>RangeError ( . . . )</h6>

<p>见 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E6%A0%87%E5%87%86_ECMAScript_%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1#RangeError">15.11.6.2</a>.</p>



<h6>ReferenceError ( . . . )</h6>

<p>见 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E6%A0%87%E5%87%86_ECMAScript_%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1#ReferenceError">15.11.6.3</a>.</p>



<h6>SyntaxError ( . . . )</h6>

<p>见 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E6%A0%87%E5%87%86_ECMAScript_%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1#SyntaxError">15.11.6.4</a>.</p>



<h6>TypeError ( . . . )</h6>

<p>见 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E6%A0%87%E5%87%86_ECMAScript_%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1#TypeError">15.11.6.5</a>.</p>



<h6>URIError ( . . . )</h6>

<p>见 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E6%A0%87%E5%87%86_ECMAScript_%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1#URIError">15.11.6.6</a>.</p>



<h5>全局对象的其他属性</h5>


<h6>Math</h6>

<p>见 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E6%A0%87%E5%87%86_ECMAScript_%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1#Math.E5.AF.B9.E8.B1.A1">15.8</a>.</p>



<h6>JSON</h6>

<p>见 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E6%A0%87%E5%87%86_ECMAScript_%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1#The_JSON_Object">15.12</a>.</p>



<h4>Object 对象</h4>


<h5>作为函数调用 Object 构造器</h5>

<p>当把 Object 当做一个函数来调用，而不是一个构造器，它会执行一个类型转换。</p>



<h6>Object ( [ value ] )</h6>

<p>当以一个参数 value 或者无参数调用 Object 函数，采用如下步骤：</p>

<ol>
  <li>如果 value 是 null, undefined 或未指定，则创建并返回一个新 Object 对象 , 这个对象与仿佛用相同参数调用标准内置的 Object 构造器 (15.2.2.1) 的结果一样 . </li>

  <li>返回 ToObject(value).</li>
</ol>


<h5>Object 构造器</h5>

<p>当 Object 是 new 表达式调用的一部分时，它是一个构造器，可创建一个对象。</p>



<h6>new Object ( [ value ] )</h6>

<p>当以一个参数 value 或者无参数调用 Object 构造器，采用如下步骤：</p>

<ol>
  <li>如果提供了 value, 则 
    <ol>
      <li>如果 Type(value) 是 Object, 则 
        <ol>
          <li>如果 value 是个原生 ECMAScript 对象 , 不创建新对象，简单的返回 value. </li>

          <li>如果 value 是宿主对象 , 则采取动作和返回依赖实现的结果的方式可以使依赖于宿主对象的 .</li>
        </ol>
      </li>

      <li>如果 Type(value) 是 String, 返回 ToObject(value). </li>

      <li>如果 Type(value) 是 Boolean, 返回 ToObject(value). </li>

      <li>如果 Type(value) 是 Number, 返回 ToObject(value).</li>
    </ol>
  </li>

  <li>断言 : 未提供参数 value 或其类型是 Null 或 Undefined. </li>

  <li>令 obj 为一个新创建的原生 ECMAScript 对象 . </li>

  <li>设定 obj 的 [[Prototype]] 内部属性为标准内置的 Object 的 prototype 对象 (15.2.4). </li>

  <li>设定 obj 的 [[Class]] 内部属性为 &quot;Object&quot;. </li>

  <li>设定 obj 的 [[Extensible]] 内部属性为 true. </li>

  <li>设定 obj 的 8.12 指定的所有内部方法 </li>

  <li>返回 obj.</li>
</ol>


<h5>Object 构造器的属性</h5>

<p>Object 构造器的 [[Prototype]] 内部属性值是标准内置 Function 的 prototype 对象。</p>

<p>除了内部属性和 length 属性（其值是 1）之外，Object 构造器拥有以下属性：</p>



<h6>Object.prototype</h6>

<p>Object.prototype 的初始值是标准内置 Object 的 prototype 对象（15.2.4）。</p>

<p>这个属性包含特性 {[[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }</p>



<h6>Object.getPrototypeOf ( O )</h6>

<p>当以参数 O 调用 getPrototypeOf 函数，采用如下步骤：</p>

<ol>
  <li>如果 Type(O) 不是 Object，则抛出一个 TypeError 异常 . </li>

  <li>返回 O 的 [[Prototype]] 内部属性的值 .</li>
</ol>


<h6>Object.getOwnPropertyDescriptor ( O, P )</h6>

<p>当调用 getOwnPropertyDescriptor 函数，采用如下步骤：</p>

<ol>
  <li>如果 Type(O) 不是 Object，则抛出一个 TypeError 异常 . </li>

  <li>令 name 为 ToString(P). </li>

  <li>令 desc 为以参数 name 调用 O 的 [[GetOwnProperty]] 内部方法的结果 . </li>

  <li>返回调用 FromPropertyDescriptor(desc) 的结果 (8.10.4).</li>
</ol>


<h6>Object.getOwnPropertyNames ( O )</h6>

<p>当调用 getOwnPropertyNames 函数，采用如下步骤：</p>

<ol>
  <li>如果 Type(O) 不是 Object，则抛出一个 TypeError 异常 . </li>

  <li>令 array 为仿佛是用表达式 new Array () 创建新对象的结果，这里的 Array 是标准内置构造器名。 </li>

  <li>令 n 为 0. </li>

  <li>对 O 的每个自身属性 P 
    <ol>
      <li>令 name 为值是 P 的名称的字符串 . </li>

      <li>以 ToString(n) 和属性描述 {[[Value]]: name, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true} 和 false 为参数调用 array 的 [[DefineOwnProperty]] 内部方法 . </li>

      <li>n 递增 1.</li>
    </ol>
  </li>

  <li>返回 array.</li>
</ol>

<p>注： 如果 O 是一个字符串实例，第 4 步处理的自身属性集合包含 15.5.5.2 定义的隐藏属性，他们对应对象的 [[PrimitiveValue]] 字符串中相应位置的字符。</p>



<h6>Object.create ( O [, Properties] )</h6>

<p>create 函数按照指定的原型创建一个新对象。当调用 create 函数，采用如下步骤：</p>

<ol>
  <li>如果 Type(O) 不是 Object 或 Null，则抛出一个 TypeError 异常 . </li>

  <li>令 obj 为为仿佛是用表达式 new Object() 创建新对象的结果，这里的 Object 是标准内置构造器名。 </li>

  <li>设定 obj 的 [[Prototype]] 内部属性为 O. </li>

  <li>如果传入了 Properties 参数并且不是 undefined, 则仿佛是用 obj 和 Properties 当作参数调用标准内置函数 Object.defineProperties 一样给 obj 添加自身属性。 </li>

  <li>返回 obj.</li>
</ol>


<h6>Object.defineProperty ( O, P, Attributes )</h6>

<p>defineProperty 函数用于给一个对象添加一个自身属性 并 / 或 更新现有自身属性的特性。当调用 defineProperty 函数，采用如下步骤：</p>

<ol>
  <li>如果 Type(O) 不是 Object，则抛出一个 TypeError 异常 . </li>

  <li>令 name 为 ToString(P). </li>

  <li>令 desc 为以 Attributes 作为参数调用 ToPropertyDescriptor 的结果 . </li>

  <li>以 name, desc, true 作为参数调用 O 的 [[DefineOwnProperty]] 内部方法 . </li>

  <li>返回 O.</li>
</ol>


<h6>Object.defineProperties ( O, Properties )</h6>

<p>defineProperties 函数用于给一个对象添加一些自身属性 并 / 或 更新现有的一些自身属性的特性。当调用 defineProperties 函数，采用如下步骤：</p>

<ol>
  <li>如果 Type(O) 不是 Object，则抛出一个 TypeError 异常 . </li>

  <li>令 props 为 ToObject(Properties). </li>

  <li>令 names 为一个内部列表，它包含 props 的每个可遍历自身属性的名称 . </li>

  <li>令 descriptors 为一个空的内部列表 . </li>

  <li>对 names 的每个元素 P，按照列表顺序 , 
    <ol>
      <li>令 descObj 为以 P 作为参数调用 props 的 [[Get]] 内部方法的结果 . </li>

      <li>令 desc 为以 descObj 作为参数调用 ToPropertyDescriptor 的结果 . </li>

      <li>将 desc 插入 descriptors 的尾部 .</li>
    </ol>
  </li>

  <li>对 descriptors 的每个元素 desc，按照列表顺序 , 
    <ol>
      <li>以参数 P, desc, true 调用 O 的 [[DefineOwnProperty]] 内部方法 .</li>
    </ol>
  </li>

  <li>返回 O</li>
</ol>

<p>如果一个实现为 for-in 语句的定义了特定的枚举顺序，那么在这个算法的第 3 步中的列表元素必须也用相同的顺序排列。</p>



<h6>Object.seal ( O )</h6>

<p>当调用 seal 函数，采用如下步骤：</p>

<ol>
  <li>如果 Type(O) 不是 Object，则抛出一个 TypeError 异常 . </li>

  <li>对 O 的每个命名自身属性名 P, 
    <ol>
      <li>令 desc 为以参数 P 调用 O 的 [[GetOwnProperty]] 内部方法的结果 . </li>

      <li>如果 desc.[[Configurable]] 是 true, 设定 desc.[[Configurable]] 为 false. </li>

      <li>以 P, desc, true 为参数调用 O 的 [[DefineOwnProperty]] 内部方法 .</li>
    </ol>
  </li>

  <li>设定 O 的 [[Extensible]] 内部属性为 false. </li>

  <li>返回 O.</li>
</ol>


<h6>Object.freeze ( O )</h6>

<p>当调用 freeze 函数，采用如下步骤：</p>

<ol>
  <li>如果 Type(O) 不是 Object，则抛出一个 TypeError 异常 . </li>

  <li>对 O 的每个命名自身属性名 P, 
    <ol>
      <li>令 desc 为以参数 P 调用 O 的 [[GetOwnProperty]] 内部方法的结果 . </li>

      <li>如果 IsDataDescriptor(desc) 是 true, 则 
        <ol>
          <li>如果 desc.[[Writable]] 是 true, 设定 desc.[[Writable]] 为 false.</li>
        </ol>
      </li>

      <li>如果 desc.[[Configurable]] 是 true, 设定 desc.[[Configurable]] 为 false. </li>

      <li>以 P, desc, true 作为参数调用 O 的 [[DefineOwnProperty]] 内部方法 .</li>
    </ol>
  </li>

  <li>设定 O 的 [[Extensible]] 内部属性为 false. </li>

  <li>返回 O.</li>
</ol>


<h6>Object.preventExtensions ( O )</h6>

<p>当调用 preventExtensions 函数，采用如下步骤：</p>

<ol>
  <li>如果 Type(O) 不是 Object，则抛出一个 TypeError 异常 . </li>

  <li>设定 O 的 [[Extensible]] 内部属性为 false. </li>

  <li>返回 O.</li>
</ol>


<h6>Object.isSealed ( O )</h6>

<p>当以参数 O 调用 isSealed 函数，采用如下步骤：</p>

<ol>
  <li>如果 Type(O) 不是 Object，则抛出一个 TypeError 异常 . </li>

  <li>对 O 的每个命名自身属性名 P, 
    <ol>
      <li>令 desc 为以参数 P 调用 O 的 [[GetOwnProperty]] 内部方法的结果 . </li>

      <li>如果 desc.[[Configurable]] 是 true, 则返回 false.</li>
    </ol>
  </li>

  <li>如果 O 的 [[Extensible]] 内部属性是 false, 则返回 true. </li>

  <li>否则 , 返回 false.</li>
</ol>


<h6>Object.isFrozen ( O )</h6>

<p>当以参数 O 调用 isFrozen 函数，采用如下步骤：</p>

<ol>
  <li>如果 Type(O) 不是 Object，则抛出一个 TypeError 异常 . </li>

  <li>对 O 的每个命名自身属性名 P, 
    <ol>
      <li>令 desc 为以参数 P 调用 O 的 [[GetOwnProperty]] 内部方法的结果 . </li>

      <li>如果 IsDataDescriptor(desc) 是 true，则 
        <ol>
          <li>如果 desc.[[Writable]] 是 true, 则返回 false.</li>
        </ol>
      </li>

      <li>如果 desc.[[Configurable]] 是 true, 则返回 false.</li>
    </ol>
  </li>

  <li>如果 O 的 [[Extensible]] 内部属性是 false, 则返回 true. </li>

  <li>否则 , 返回 false.</li>
</ol>


<h6>Object.isExtensible ( O )</h6>

<p>当以参数 O 调用 isExtensible 函数，采用如下步骤：</p>

<ol>
  <li>如果 Type(O) 不是 Object，则抛出一个 TypeError 异常 . </li>

  <li>返回 O 的 [[Extensible]] 内部属性布尔值 .</li>
</ol>


<h6>Object.keys ( O )</h6>

<p>当以参数 O 调用 keys 函数，采用如下步骤：</p>

<ol>
  <li>如果 Type(O) 不是 Object，则抛出一个 TypeError 异常 . </li>

  <li>令 n 为 O 的可遍历自身属性的个数 </li>

  <li>令 array 为仿佛是用表达式 new Array () 创建新对象的结果，这里的 Array 是标准内置构造器名。 </li>

  <li>令 index 为 0. </li>

  <li>对 O 的每个可遍历自身属性名 P, 
    <ol>
      <li>以 ToString(index)，属性描述 {[[Value]]: P, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}，和 false 作为参数调用 array 的 [[DefineOwnProperty]] 内部方法。 </li>

      <li>index 递增 1.</li>
    </ol>
  </li>

  <li>返回 array.</li>
</ol>

<p>如果一个实现为 for-in 语句的定义了特定的枚举顺序，那么在这个算法的第 5 步中的必须使用相同的枚举顺序。</p>



<h5>Object 的 prototype 对象的属性</h5>

<p>Object 的 prototype 对象的 [[Prototype]] 内部属性的值是 null，[[Class]] 内部属性的值是 &quot;Object&quot;，[[Extensible]] 内部属性的初始值是 true。</p>



<h6>Object.prototype.constructor</h6>

<p>Object.prototype.constructor 的初始值是标准内置的 Object 构造器。</p>



<h6>Object.prototype.toString ( )</h6>

<p>当调用 toString 方法，采用如下步骤：</p>

<ol>
  <li>如果 this 的值是 undefined, 返回 &quot;[object Undefined]&quot;. </li>

  <li>如果 this 的值是 null, 返回 &quot;[object Null]&quot;. </li>

  <li>令 O 为以 this 作为参数调用 ToObject 的结果 . </li>

  <li>令 class 为 O 的 [[Class]] 内部属性的值 . </li>

  <li>返回三个字符串 &quot;[object &quot;, class, and &quot;]&quot; 连起来的字符串 .</li>
</ol>


<h6>Object.prototype.toLocaleString ( )</h6>

<p>当调用 toLocaleString 方法，采用如下步骤：</p>

<ol>
  <li>令 O 为以 this 作为参数调用 ToObject 的结果 . </li>

  <li>令 toString 为以 &quot;toString&quot; 作为参数调用 O 的 [[Get]] 内部方法的结果 . </li>

  <li>如果 IsCallable(toString) 是 false, 抛出一个 TypeError 异常 . </li>

  <li>返回以 O 作为 this 值，无参数调用 toString 的 [[Call]] 内部方法的结果 .</li>
</ol>

<p>注：1. 这个函数给所有 Object 对象提供一个通用的 toLocaleString 接口，即使并不是所有的都使用它。目前，Array, Number, Date 提供了它们自身的语言环境敏感的 toLocaleString 方法。</p>

<p>注：2. 这个函数的第一个参数可能会在此标准的未来版本中使用到；因此建议实现不要用这个位置参数来做其他事情。</p>



<h6>Object.prototype.valueOf ( )</h6>

<p>当调用 valueOf 方法，采用如下步骤：</p>

<ol>
  <li>令 O 为以 this 作为参数调用 ToObject 的结果 . </li>

  <li>如果 O 是以一个宿主对象 (15.2.2.1) 为参数调用 Object 构造器的结果，则 
    <ol>
      <li>返回 O 或传递给构造器的原来的宿主对象 . 返回的具体结果是由实现定义的 .</li>
    </ol>
  </li>

  <li>返回 O.</li>
</ol>


<h6>Object.prototype.hasOwnProperty (V)</h6>

<p>当以参数 V 调用 hasOwnProperty 方法，采用如下步骤：</p>

<ol>
  <li>令 P 为 ToString(V). </li>

  <li>令 O 为以 this 值作为参数调用 ToObject 的结果 . </li>

  <li>令 desc 为以 P 为参数调用 O 的 [[GetOwnProperty]] 内部方法的结果 . </li>

  <li>如果 desc 是 undefined, 返回 false. </li>

  <li>返回 true.</li>
</ol>

<p>注：1. 不像 [[HasProperty]](8.12.6)，这个方法不考虑原形链中的对象。</p>

<p>注：2. 为步骤 1 和 2 的选择这样的顺序，是为了确保在本规范之前版本中会在这里的步骤 1 里抛出的任何异常，即使 this 值是 undefined 或 null，也会继续抛出。</p>



<h6>Object.prototype.isPrototypeOf (V)</h6>

<p>当以参数 V 调用 isPrototypeOf 方法，采用如下步骤：</p>

<ol>
  <li>如果 V 不是个对象 , 返回 false. </li>

  <li>令 O 为以 this 作为参数调用 ToObject 的结果 . </li>

  <li>重复 
    <ol>
      <li>令 V 为 V 的 [[Prototype]] 内部属性的值 . </li>

      <li>如果 V 是 null, 返回 false </li>

      <li>如果 O 和 V 指向同一个对象 , 返回 true.</li>
    </ol>
  </li>
</ol>

<p>注： 为步骤 1 和 2 的选择这样的顺序，是为了当 V 不是对象并且 this 值是 undefined 或 null 时能够保持本规范之前版本指定的行为。</p>



<h6>Object.prototype.propertyIsEnumerable (V)</h6>

<p>当以参数 V 调用 propertyIsEnumerable 方法，采用如下步骤：</p>

<ol>
  <li>令 P 为 ToString(V). </li>

  <li>令 O 为以 this 作为参数调用 ToObject 的结果 . </li>

  <li>令 desc 为以 P 作为参数调用 O 的 [[GetOwnProperty]] 内部方法的结果 . </li>

  <li>如果 desc 是 undefined, 返回 false. </li>

  <li>返回 desc.[[Enumerable]] 的值 .</li>
</ol>

<p>注：1. 这个方法不考虑原型链中的对象。</p>

<p>注：2. 为步骤 1 和 2 的选择这样的顺序，是为了确保在本规范之前版本中会在这里的步骤 1 里抛出的任何异常，即使 this 值是 undefined 或 null，也会继续抛出。</p>



<h5>Object 的实例的属性</h5>

<p>Object 的实例除了拥从 Object 的 prototype 对象继承来的属性之外不包含特殊的属性。</p>



<h4>Function 对象</h4>


<h5>作为函数调用 Function 构造器</h5>

<p>当将 Function 作为函数来调用，而不是作为构造器，它会创建并初始化一个新函数对象。所以函数调用 Function(…) 与用相同参数的 new Function(…) 表达式创建的对象相同。</p>



<h6>Function (p1, p2, … , pn, body)</h6>

<p>当以 p1, p2, … , pn, body 作为参数调用 Function 函数（这里的 n 可以是 0，也就是说没有“p”参数，这时还可以不提供 body），采用如下步骤：</p>

<ol>
  <li>创建并返回一个新函数对象，它仿佛是用相同参数给标准内置构造器 Function (15.3.2.1). 用一个 new 表达式创建的。</li>
</ol>


<h5>Function 构造器</h5>

<p>当 Function 作为 new 表达式的一部分被调用时，它是一个构造器：它初始化新创建的对象。</p>



<h6>new Function (p1, p2, … , pn, body)</h6>

<p>最后一个参数指定为函数的 body( 可执行代码 )；之前的任何参数都指定为形式参数。</p>

<p>当以 p1, p2, … , pn, body 作为参数调用 Function 构造器（这里的 n 可以是 0，也就是说没有“p”参数，这时还可以不提供 body），采用如下步骤：</p>

<ol>
  <li>令 argCount 为传给这个函数调用的参数总数 . </li>

  <li>令 P 为空字符串 . </li>

  <li>如果 argCount = 0, 令 body 为空字符串 . </li>

  <li>否则如果 argCount = 1, 令 body 为那个参数 . </li>

  <li>否则 , argCount &gt; 1 
    <ol>
      <li>令 firstArg 为第一个参数 . </li>

      <li>令 P 为 ToString(firstArg). </li>

      <li>令 k 为 2. </li>

      <li>只要 k &lt; argCount 就重复 
        <ol>
          <li>令 nextArg 为第 k 个参数 . </li>

          <li>令 P 为之前的 P 值，字符串 &quot;,&quot;（一个逗号），ToString(nextArg) 串联的结果。 </li>

          <li>k 递增 1.</li>
        </ol>
      </li>

      <li>令 body 为第 k 个参数 .</li>
    </ol>
  </li>

  <li>令 body 为 ToString(body). </li>

  <li>如果 P 不可解析为一个 FormalParameterListopt，则抛出一个 SyntaxError 异常 . </li>

  <li>如果 body 不可解析为 FunctionBody，则抛出一个 SyntaxError 异常 . </li>

  <li>如果 body 是严格模式代码 ( 见 10.1.1)，则令 strict 为 true, 否则令 strict 为 false. </li>

  <li>如果 strict 是 true, 适用 13.1 指定抛出的任何异常 . </li>

  <li>返回一个新创建的函数对象，它是依照 13.2 指定 -- 专递 P 作为 FormalParameterList，body 作为 FunctionBody，全局环境作为 Scope 参数，strict 作为严格模式标志 -- 创建的。</li>
</ol>

<p>每个函数都会自动创建一个 prototype 属性，用来支持函数被当做构造器使用的可能性。</p>

<div>注： 为每个形参指定一个参数是允许的，但没必要。例如以下三个表达式产生相同的结果：

<pre> new Function(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;return a+b+c&quot;)

 new Function(&quot;a, b, c&quot;, &quot;return a+b+c&quot;)

 new Function(&quot;a,b&quot;, &quot;c&quot;, &quot;return a+b+c&quot;)</pre></div>


<h5>Function 构造器的属性</h5>

<p>Function 构造器自身是个函数对象，它的 [[Class]] 是 &quot;Function&quot;。Function 构造器的 [[Prototype]] 内部属性值是标准内置 Function 的 prototype 对象 (15.3.4)。</p>

<p>Function 构造器的 [[Extensible]] 内部属性值是 true.</p>

<p>Function 构造器有如下属性 :</p>



<h6>Function.prototype</h6>

<p>Function.prototype 的初始值是标准内置 Function 的 prototype 对象 (15.3.4)。</p>

<p>此属性拥有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。</p>



<h6>Function.length</h6>

<p>这是个值为 1 的数据属性。此属性拥有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。</p>



<h5>Function 的 prototype 对象的属性</h5>

<p>Function 的 prototype 对象自身是一个函数对象 ( 它的 [[Class]] 是 &quot;Function&quot;)，调用这个函数对象时，接受任何参数并返回 undefined。</p>

<p>Function 的 prototype 对象的 [[Prototype]] 内部属性值是标准内置 Object 的 prototype 对象 (15.2.4)。Function 的 prototype 对象的 [[Extensible]] 内部属性的初始值是 true。</p>

<p>Function 的 prototype 对象自身没有 valueOf 属性 ; 但是，它从 Object 的 prototype 对象继承了 valueOf 属性。</p>

<p>Function 的 prototype 对象的 length 属性是 0。</p>



<h6>Function.prototype.constructor</h6>

<p>Function.prototype.constructor 的初始值是内置 Function 构造器。</p>



<h6>Function.prototype.toString ( )</h6>

<p>此函数的返回值的表示是依赖于实现的。这个表示包含 FunctionDeclaration 的语法。特别注意，怎样在这个字符串表示中使用和放置空白，行终止符，分号是依赖于实现的。</p>

<p>这个 toString 不是通用的；如果它的 this 值不是一个函数对象，它会抛出一个 TypeError 异常。因此，它不能当做方法来转移到其他类型的对象中。</p>



<h6>Function.prototype.apply (thisArg, argArray)</h6>

<p>当以 thisArg 和 argArray 为参数在一个 func 对象上调用 apply 方法，采用如下步骤：</p>

<ol>
  <li>如果 IsCallable(func) 是 false, 则抛出一个 TypeError 异常 . </li>

  <li>如果 argArray 是 null 或 undefined, 则 
    <ol>
      <li>返回提供 thisArg 作为 this 值并以空参数列表调用 func 的 [[Call]] 内部方法的结果。</li>
    </ol>
  </li>

  <li>如果 Type(argArray) 不是 Object, 则抛出一个 TypeError 异常 . </li>

  <li>令 len 为以 &quot;length&quot; 作为参数调用 argArray 的 [[Get]] 内部方法的结果。 </li>

  <li>令 n 为 ToUint32(len). </li>

  <li>令 argList 为一个空列表 . </li>

  <li>令 index 为 0. </li>

  <li>只要 index &lt; n 就重复 
    <ol>
      <li>令 indexName 为 ToString(index). </li>

      <li>令 nextArg 为以 indexName 作为参数调用 argArray 的 [[Get]] 内部方法的结果。 </li>

      <li>将 nextArg 作为最后一个元素插入到 argList 里。 </li>

      <li>设定 index 为 index + 1.</li>
    </ol>
  </li>

  <li>提供 thisArg 作为 this 值并以 argList 作为参数列表，调用 func 的 [[Call]] 内部方法，返回结果。</li>
</ol>

<p>apply 方法的 length 属性是 2。</p>

<p>注： 在外面传入的 thisArg 值会修改并成为 this 值。thisArg 是 undefined 或 null 时它会被替换成全局对象，所有其他值会被应用 ToObject 并将结果作为 this 值，这是第三版引入的更改。</p>



<h6>Function.prototype.call (thisArg [ , arg1 [ , arg2, … ] ] )</h6>

<p>当以 thisArg 和可选的 arg1, arg2 等等作为参数在一个 func 对象上调用 call 方法，采用如下步骤：</p>

<ol>
  <li>如果 IsCallable(func) 是 false, 则抛出一个 TypeError 异常。 </li>

  <li>令 argList 为一个空列表。 </li>

  <li>如果调用这个方法的参数多余一个，则从 arg1 开始以从左到右的顺序将每个参数插入为 argList 的最后一个元素。 </li>

  <li>提供 thisArg 作为 this 值并以 argList 作为参数列表，调用 func 的 [[Call]] 内部方法，返回结果。</li>
</ol>

<p>call 方法的 length 属性是 1。</p>

<p>注： 在外面传入的 thisArg 值会修改并成为 this 值。thisArg 是 undefined 或 null 时它会被替换成全局对象，所有其他值会被应用 ToObject 并将结果作为 this 值，这是第三版引入的更改。</p>



<h6>Function.prototype.bind (thisArg [, arg1 [, arg2, …]])</h6>

<p>bind 方法需要一个或更多参数，thisArg 和（可选的）arg1, arg2, 等等，执行如下步骤返回一个新函数对象：</p>

<ol>
  <li>令 Target 为 this 值 . </li>

  <li>如果 IsCallable(Target) 是 false, 抛出一个 TypeError 异常 . </li>

  <li>令 A 为一个（可能为空的）新内部列表，它包含按顺序的 thisArg 后面的所有参数（arg1, arg2 等等）。 </li>

  <li>令 F 为一个新原生 ECMAScript 对象。 </li>

  <li>依照 8.12 指定，设定 F 的除了 [[Get]] 之外的所有内部方法。 </li>

  <li>依照 15.3.5.4 指定，设定 F 的 [[Get]] 内部属性。 </li>

  <li>设定 F 的 [[TargetFunction]] 内部属性为 Target。 </li>

  <li>设定 F 的 [[BoundThis]] 内部属性为 thisArg 的值。 </li>

  <li>设定 F 的 [[BoundArgs]] 内部属性为 A。 </li>

  <li>设定 F 的 [[Class]] 内部属性为 &quot;Function&quot;。 </li>

  <li>设定 F 的 [[Prototype]] 内部属性为 15.3.3.1 指定的标准内置 Function 的 prototype 对象。 </li>

  <li>依照 15.3.4.5.1 描述，设定 F 的 [[Call]] 内置属性。 </li>

  <li>依照 15.3.4.5.2 描述，设定 F 的 [[Construct]] 内置属性。 </li>

  <li>依照 15.3.4.5.3 描述，设定 F 的 [[HasInstance]] 内置属性。 </li>

  <li>如果 Target 的 [[Class]] 内部属性是 &quot;Function&quot;, 则 
    <ol>
      <li>令 L 为 Target 的 length 属性减 A 的长度。 </li>

      <li>设定 F 的 length 自身属性为 0 和 L 中更大的值。</li>
    </ol>
  </li>

  <li>否则设定 F 的 length 自身属性为 0. </li>

  <li>设定 F 的 length 自身属性的特性为 15.3.5.1 指定的值。 </li>

  <li>设定 F 的 [[Extensible]] 内部属性为 true。 </li>

  <li>令 thrower 为 [[ThrowTypeError]] 函数对象 (13.2.3)。 </li>

  <li>以 &quot;caller&quot;, 属性描述符 {[[Get]]: thrower, [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false}, 和 false 作为参数调用 F 的 [[DefineOwnProperty]] 内部方法。 </li>

  <li>以 &quot;arguments&quot;, 属性描述符 {[[Get]]: thrower, [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false}, 和 false 作为参数调用 F 的 [[DefineOwnProperty]] 内部方法。 </li>

  <li>返回 F.</li>
</ol>

<p>bind 方法的 length 属性是 1。</p>

<p>注：Function.prototype.bind 创建的函数对象不包含 prototype 属性或 [[Code]], [[FormalParameters]], [[Scope]] 内部属性。</p>



<h6>[[Call]]</h6>

<p>当调用一个用 bind 函数创建的函数对象 F 的 [[Call]] 内部方法，传入一个 this 值和一个参数列表 ExtraArgs，采用如下步骤：</p>

<ol>
  <li>令 boundArgs 为 F 的 [[BoundArgs]] 内部属性值。 </li>

  <li>令 boundThis 为 F 的 [[BoundThis]] 内部属性值。 </li>

  <li>令 target 为 F 的 [[TargetFunction]] 内部属性值。 </li>

  <li>令 args 为一个新列表，它包含与列表 boundArgs 相同顺序相同值，后面跟着与 ExtraArgs 是相同顺序相同值。 </li>

  <li>提供 boundThis 作为 this 值，提供 args 为参数调用 target 的 [[Call]] 内部方法，返回结果。</li>
</ol>


<h6>[[Construct]]</h6>

<p>当调用一个用 bind 函数创建的函数对象 F 的 [[Construct]] 内部方法，传入一个参数列表 ExtraArgs，采用如下步骤：</p>

<ol>
  <li>令 target 为 F 的 [[TargetFunction]] 内部属性值。 </li>

  <li>如果 target 不包含 [[Construct]] 内部方法 , 抛出一个 TypeError 异常。 </li>

  <li>令 boundArgs 为 F 的 [[BoundArgs]] 内部属性值。 </li>

  <li>令 args 为一个新列表，它包含与列表 boundArgs 相同顺序相同值，后面跟着与 ExtraArgs 是相同顺序相同值。 </li>

  <li>提供 args 为参数调用 target 的 [[Construct]] 内部方法，返回结果。</li>
</ol>


<h6>[[HasInstance]] (V)</h6>

<p>当调用一个用 bind 函数创建的函数对象 F 的 [[Construct]] 内部方法，并以 V 作为参数，采用如下步骤：</p>

<ol>
  <li>令 target 为 F 的 [[TargetFunction]] 内部属性值。 </li>

  <li>如果 target 不包含 [[HasInstance]] 内部方法 , 抛出一个 TypeError 异常。 </li>

  <li>提供 V 为参数调用 target 的 [[HasInstance]] 内部方法，返回结果。</li>
</ol>


<h5>Function 的实例的属性</h5>

<p>除了必要的内部属性之外，每个函数实例还有一个 [[Call]] 内部属性并且在大多数情况下使用不同版本的 [[Get]] 内部属性。函数实例根据怎样创建的（见 8.6.2 ,13.2, 15, 15.3.4.5）可能还有一个 [[HasInstance]] 内部属性 , 一个 [[Scope]] 内部属性 , 一个 [[Construct]] 内部属性 , 一个 [[FormalParameters]] 内部属性 , 一个 [[Code]] 内部属性 , 一个 [[TargetFunction]] 内部属性 , 一个 [[BoundThis]] 内部属性 , 一个 [[BoundArgs]] 内部属性。</p>

<p>[[Class]] 内部属性的值是 &quot;Function&quot;。</p>

<p>对应于严格模式函数 (13.2) 的函数实例和用 Function.prototype.bind 方法 (15.3.4.5) 创建的函数实例有名为“caller”和 “arguments”的属性时，抛出一个 TypeError 异常。一个 ECMAScript 实现不得为在严格模式函数代码里访问这些属性关联任何依赖实现的特定行为。</p>



<h6>length</h6>

<p>length 属性值是个整数，它指出函数预期的“一般的”参数个数。然而，语言允许用其他数量的参数来调用函数。当以与函数的 length 属性指定的数量不同的参数个数调用函数时，它的行为依赖于函数自身。这个属性拥有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。</p>



<h6>prototype</h6>

<p>prototype 属性的值用于初始化一个新创建对象的的 [[Prototype]] 内部属性，为了这个新创建对象要先将函数对象作为构造器调用。这个属性拥有特性 { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }。</p>

<p>注： 用 Function.prototype.bind 创建的函数对象没有 prototype 属性。</p>



<h6>[[HasInstance]] (V)</h6>

<p>设 F 是个函数对象。 </p><p>当以 V 作为参数调用 F 的 [[HasInstance]] 内部方法，采用如下步骤：</p>

<ol>
  <li>如果 V 不是个对象 , 返回 false。 </li>

  <li>令 O 为用属性名 &quot;prototype&quot; 调用 F 的 [[Get]] 内部方法的结果。 </li>

  <li>如果 Type(O) 不是 Object, 抛出一个 TypeError 异常。 </li>

  <li>重复 
    <ol>
      <li>令 V 为 V 的 [[Prototype]] 内部属性值。 </li>

      <li>如果 V 是 null, 返回 false. </li>

      <li>如果 O 和 V 指向相同对象，返回 true。</li>
    </ol>
  </li>
</ol>

<p>注： 用 Function.prototype.bind 创建的函数对象拥有的不同的 [[HasInstance]] 实现，在 15.3.4.5.3 中定义。</p>



<h6>[[Get]] (P)</h6>

<p>函数对象与其他原生 EMACScript 对象 (8.12.3) 用不同的 [[Get]] 内部方法。</p>

<p>设 F 是一个函数对象，当以属性名 P 调用 F 的 [[Get]] 内部方法 , 采用如下步骤：</p>

<ol>
  <li>令 v 为传入 P 作为属性名参数调用 F 的默认 [[Get]] 内部方法 (8.12.3) 的结果。 </li>

  <li>如果 P 是 &quot;caller&quot; 并且 v 是个严格模式函数对象 , 抛出一个 TypeError 异常。 </li>

  <li>返回 v。</li>
</ol>

<p>注： 用 Function.prototype.bind 创建的函数对象使用默认的 [[Get]] 内部方法。</p>



<h4>Array 对象</h4>

<p>数组对象会给予一些种类的属性名特殊待遇。对一个属性名 P（字符串形式），当且仅当 ToString(ToUint32(P)) 等于 P 并且 ToUint32(P) 不等于 2<sup>32</sup>−1 时，它是个 <i>数组索引 </i>。一个属性名是数组索引的属性还叫做 <i>元素 </i>。所有数组对象都有一个 length 属性，其值始终是一个小于 2<sup>32</sup> 的非负整数。length 属性值在数值上比任何名为数组索引的属性的名称还要大；每当创建或更改一个数组对象的属性，要调整其他的属性以保持上面那个条件不变的需要。具体来说，每当添加一个名为数组索引的属性时，如果需要就更改 length 属性为在数值上比这个数组索引大 1 的值；每当更改 length 属性，所有属性名是数组索引并且其值不小于新 length 的属性会被自动删除。这个限制只应用于数组对象的自身属性，并且从原型中继承的 length 或数组索引不影响这个限制。</p>

<p>对一个对象 O，如果以下算法返回 true，那么就叫这个对象为 <i>稀疏 </i>的：</p>

<ol>
  <li>令 len 为以 &quot;length&quot; 作为参数调用 O 的 [[Get]] 内部方法的结果。 </li>

  <li>对每个范围在 0≤i&lt;ToUint32(len) 的整数 i 
    <ol>
      <li>令 elem 为以 ToString(i) 作为参数调用 O 的 [[GetOwnProperty]] 内部方法的结果。 </li>

      <li>如果 elem 是 undefined, 返回 true.</li>
    </ol>
  </li>

  <li>返回 false.</li>
</ol>


<h5>作为函数调用 Array 构造器</h5>

<p>当将 Array 作为函数来调用，而不是作为构造器，它会创建并初始化一个新数组对象。所以函数调用 Array(…) 与用相同参数的 new Array(…) 表达式创建的对象相同。</p>



<h6>Array ( [ item1 [ , item2 [ , … ] ] ] )</h6>

<p>当调用 Array 函数，采用如下步骤：</p>

<ol>
  <li>创建并返回一个新函数对象，它仿佛是用相同参数给标准内置构造器 Array 用一个 new 表达式创建的 (15.4.2)。</li>
</ol>


<h5>Array 构造器</h5>

<p>当 Array 作为 new 表达式的一部分被调用时，它是一个构造器：它初始化新创建的对象。</p>



<h6>new Array ( [ item0 [ , item1 [ , … ] ] ] )</h6>

<p>当且仅当以无参数或至少两个参数调用 Array 构造器时，适用这里的描述。</p>

<p>新构造对象的 [[Prototype]] 内部属性要设定为原始的数组原型对象，他是 Array.prototype(15.4.3.1) 的初始值。</p>

<p>新构造对象的 [[Class]] 内部属性要设定为 &quot;Array&quot;。</p>

<p>新构造对象的 [[Extensible]] 内部属性要设定为 true。</p>

<p>新构造对象的 length 属性要设定为参数的个数。</p>

<p>新构造对象的 0 属性要设定为 item0( 如果提供了 ); 新构造对象的 1 属性要设定为 item1( 如果提供了 ); 更多的参数可应用普遍规律，新构造对象的 k 属性要设定为第 k 个参数，这里的 k 是从 0 开始的。所有这些属性都有特性 {[[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}。</p>



<h6>new Array (len)</h6>

<p>新构造对象的 [[Prototype]] 内部属性要设定为原始的数组原型对象，他是 Array.prototype(15.4.3.1) 的初始值。新构造对象的 [[Class]] 内部属性要设定为 &quot;Array&quot;。新构造对象的 [[Extensible]] 内部属性要设定为 true。</p>

<p>如果参数 len 是个数字值并且 ToUint32(len) 等于 len，则新构造对象的 length 属性要设定为 ToUint32(len)。如果参数 len 是个数字值并且 ToUint32(len) 不等于 len，则抛出一个 RangeError 异常。</p>

<p>如果参数 len 不是数字值，则新构造对象的 length 属性要设定为 0，并且新构造对象的 0 属性要设定为 len，设定它的特性为 {[[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}。</p>



<h5>Array 构造器的属性</h5>

<p>Array 构造器的 [[Prototype]] 内部属性值是函数原型对象 (15.3.4)。</p>

<p>Array 构造器除了有一些内部属性和 length 属性（其值是 1）之外，还有如下属性：</p>



<h6>Array.prototype</h6>

<p>Array.prototype 的初始值是数组原型对象 (15.4.4)。</p>

<p>此属性拥有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false}。</p>



<h6>Array.isArray ( arg )</h6>

<p>isArray 函数需要一个参数 arg，如果参数是个对象并且 class 内部属性是 &quot;Array&quot;, 返回布尔值 true；否则它返回 false。采用如下步骤：</p>

<ol>
  <li>如果 Type(arg) 不是 Object, 返回 false。 </li>

  <li>如果 arg 的 [[Class]] 内部属性值是 &quot;Array&quot;, 则返回 true。 </li>

  <li>返回 false.</li>
</ol>


<h5>数组原型对象的属性</h5>

<p>数组原型对象的 [[Prototype]] 内部属性值是标准内置 Object 原型对象 (15.2.4)。</p>

<p>数组原型对象自身是个数组；它的 [[Class]] 是 &quot;Array&quot;，它拥有一个 length 属性（初始值是 +0）和 15.4.5.1 描述的特殊的 [[DefineOwnProperty]] 内部方法。</p>

<p>在以下的对数组原型对象的属性函数的描述中，短语“this 对象”指的是调用这个函数时的 this 值对象。允许 this 是 [[Class]] 内部属性值不是 &quot;Array&quot; 的对象。</p>

<p>注： 数组原型对象不包含它自身的 valueOf 属性；然而，它从标准内置 Object 原型对象继承 valueOf 属性。</p>



<h6>Array.prototype.constructor</h6>

<p>Array.prototype.constructor 的初始值是标准内置 Array 构造器。</p>



<h6>Array.prototype.toString ( )</h6>

<p>当调用 toString 方法，采用如下步骤：</p>

<ol>
  <li>令 array 为用 this 值调用 ToObject 的结果。 </li>

  <li>令 func 为以 &quot;join&quot; 作为参数调用 array 的 [[Get]] 内部方法的结果。 </li>

  <li>如果 IsCallable(func) 是 false, 则令 func 为标准内置方法 Object.prototype.toString (15.2.4.2)。 </li>

  <li>提供 array 作为 this 值并以空参数列表调用 func 的 [[Call]] 内部方法，返回结果。</li>
</ol>

<p>注：toString 函数被有意设计成通用的；它的 this 值并非必须是数组对象。因此，它可以作为方法转移到其他类型的对象中。一个宿主对象是否可以正确应用这个 toString 函数是依赖于实现的。</p>



<h6>Array.prototype.toLocaleString ( )</h6>

<p>先用数组元素的 toLocaleString 方法，将他们转换成字符串。然后将这些字符串串联，用一个分隔符分割，这里的分隔符字符串是与特定语言环境相关，由实现定义的方式得到的。调用这个函数的结果除了与特定语言环境关联之外，与 toString 的结果类似。</p>

<p>结果是按照一下方式计算的：</p>

<ol>
  <li>令 array 为以 this 值作为参数调用 ToObject 的结果。 </li>

  <li>令 arrayLen 为以 &quot;length&quot; 作为参数调用 array 的 [[Get]] 内部方法的结果。 </li>

  <li>令 len 为 ToUint32(arrayLen)。 </li>

  <li>令 separator 为宿主环境的当前语言环境对应的列表分隔符字符串（这是实现定义的方式得到的）。 </li>

  <li>如果 len 是零 , 返回空字符串。 </li>

  <li>令 firstElement 为以 &quot;0&quot; 作为参数调用 array 的 [[Get]] 内部方法的结果。 </li>

  <li>如果 firstElement 是 undefined 或 null, 则 
    <ol>
      <li>令 R 为空字符串。</li>
    </ol>
  </li>

  <li>否则 
    <ol>
      <li>令 elementObj 为 ToObject(firstElement). </li>

      <li>令 func 为以 &quot;toLocaleString&quot; 作为参数调用 elementObj 的 [[Get]] 内部方法的结果。 </li>

      <li>如果 IsCallable(func) 是 false, 抛出一个 TypeError 异常。 </li>

      <li>令 R 为提供 elementObj 作为 this 值并以空参数列表调用 func 的 [[Call]] 内部方法的结果。</li>
    </ol>
  </li>

  <li>令 k 为 1。 </li>

  <li>只要 k &lt; len 就重复 
    <ol>
      <li>令 S 为串联 R 和 separator 产生的字符串。 </li>

      <li>令 nextElement 为以 ToString(k) 作为参数调用 array 的 [[Get]] 内部方法的结果。 </li>

      <li>如果 nextElement 是 undefined 或 null, 则 
        <ol>
          <li>令 R 为空字符串。</li>
        </ol>
      </li>

      <li>否则 
        <ol>
          <li>令 elementObj 为 ToObject(nextElement). </li>

          <li>令 func 为以 &quot;toLocaleString&quot; 作为参数调用 elementObj 的 [[Get]] 内部方法的结果。 </li>

          <li>如果 IsCallable(func) 是 false, 抛出一个 TypeError 异常。 </li>

          <li>令 R 为提供 elementObj 作为 this 值并以空参数列表调用 func 的 [[Call]] 内部方法的结果。</li>
        </ol>
      </li>

      <li>令 R 为串联 S 和 R 产生的字符串。 </li>

      <li>k 递增 1。</li>
    </ol>
  </li>

  <li>返回 R</li>
</ol>

<p>注：1. 此函数的第一个参数可能会在本标准的未来版本中用到；建议实现不要以任何其他用途使用这个参数位置。</p>

<p>注：2. toLocaleString 函数被有意设计成通用的；它的 this 值并非必须是数组对象。因此，它可以作为方法转移到其他类型的对象中。一个宿主对象是否可以正确应用这个 toLocaleString 函数是依赖于实现的。</p>



<h6>Array.prototype.concat ( [ item1 [ , item2 [ , … ] ] ] )</h6>

<p>当以零或更多个参数 item1, item2, 等等，调用 concat 方法，返回一个数组，这个数组包含对象的数组元素和后面跟着的每个参数按照顺序组成的数组元素。</p>

<p>采用如下步骤：</p>

<ol>
  <li>令 O 为以 this 值作为参数调用 ToObject 的结果。 </li>

  <li>令 A 为仿佛是用表达式 new Array() 创建的新数组，这里的 Array 是标准内置构造器名。 </li>

  <li>令 n 为 0。 </li>

  <li>令 items 为一个内部列表，他的第一个元素是 O，其后的元素是传给这个函数调用的参数（以从左到右的顺序）。 </li>

  <li>只要 items 不是空就重复 
    <ol>
      <li>删除 items 的第一个元素，并令 E 为这个元素值。 </li>

      <li>如果 E 的 [[Class]] 内部属性是 &quot;Array&quot;, 则 
        <ol>
          <li>令 k 为 0。 </li>

          <li>令 len 为以 &quot;length&quot; 为参数调用 E 的 [[Get]] 内部方法的结果。 </li>

          <li>只要 k &lt; len 就重复 
            <ol>
              <li>令 P 为 ToString(k). </li>

              <li>令 exists 为以 P 作为参数调用 E 的 [[HasProperty]] 内部方法的结果。 </li>

              <li>如果 exists 是 true, 则 
                <ol>
                  <li>令 subElement 为以 P 作为参数调用 E 的 [[Get]] 内部方法的结果。 </li>

                  <li>以 ToString(n), 属性描述符 {[[Value]]: subElement, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, 和 false 作为参数调用 A 的 [[DefineOwnProperty]] 内部方法。</li>
                </ol>
              </li>

              <li>n 递增 1. </li>

              <li>k 递增 1.</li>
            </ol>
          </li>
        </ol>
      </li>

      <li>否则 , E 不是数组 
        <ol>
          <li>以 ToString(n), 属性描述符 {[[Value]]: E, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, 和 false 作为参数调用 A 的 [[DefineOwnProperty]]&lt;/nowiki&gt; 内部方法。 </li>

          <li>n 递增 1.</li>
        </ol>
      </li>
    </ol>
  </li>

  <li>返回 A.</li>
</ol>

<p>concat 方法的 length 属性是 1。</p>

<p>注：concat 函数被有意设计成通用的；它的 this 值并非必须是数组对象。因此，它可以作为方法转移到其他类型的对象中。一个宿主对象是否可以正确应用这个 concat 函数是依赖于实现的。</p>



<h6>Array.prototype.join (separator)</h6>

<p>数组元素先被转换为字符串，再将这些字符串用 separator 分割连接在一起。如果没提供分隔符，将一个逗号用作分隔符。</p>

<p>join 方法需要一个参数 separator, 执行以下步骤 :</p>

<ol>
  <li>令 O 为以 this 值作为参数调用 ToObject 的结果 . </li>

  <li>令 lenVal 为以 &quot;length&quot; 作为参数调用 O 的 [[Get]] 内部方法的结果 . </li>

  <li>令 len 为 ToUint32(lenVal). </li>

  <li>如果 separator 是 undefined, 令 separator 为单字符字符串 &quot;,&quot;. </li>

  <li>令 sep 为 ToString(separator). </li>

  <li>如果 len 是零 , 返回空字符串 . </li>

  <li>令 element0 为以 &quot;0&quot; 作为参数调用 O 的 [[Get]] 内部方法的结果 . </li>

  <li>如果 element0 是 undefined 或 null, 令 R 为空字符串 ; 否则 , 令 R 为 ToString(element0). </li>

  <li>令 k 为 1. </li>

  <li>只要 k &lt; len 就重复 
    <ol>
      <li>令 S 为串联 R 和 sep 产生的字符串值 . </li>

      <li>令 element 为以 ToString(k) 作为参数调用 O 的 [[Get]] 内部方法的结果 . </li>

      <li>如果 element 是 undefined 或 null, 令 next 为空字符串 ; 否则 , 令 next 为 ToString(element). </li>

      <li>令 R 为串联 S 和 next 产生的字符串值 . </li>

      <li>k 递增 1.</li>
    </ol>
  </li>

  <li>返回 R.</li>
</ol>

<p>join 方法的 length 属性是 1。</p>

<p>注：join 函数被有意设计成通用的；它的 this 值并非必须是数组对象。因此，它可以作为方法转移到其他类型的对象中。一个宿主对象是否可以正确应用这个 join 函数是依赖于实现的。</p>



<h6>Array.prototype.pop ( )</h6>

<p>删除并返回数组的最后一个元素。</p>

<ol>
  <li>令 O 为以 this 值作为参数调用 ToObject 的结果 . </li>

  <li>令 lenVal 为以 &quot;length&quot; 作为参数调用 O 的 [[Get]] 内部方法的结果 . </li>

  <li>令 len 为 ToUint32(lenVal). </li>

  <li>如果 len 是零 , 
    <ol>
      <li>以 &quot;length&quot;, 0, 和 true 作为参数调用 O 的 [[Put]] 内部方法 . </li>

      <li>返回 undefined.</li>
    </ol>
  </li>

  <li>否则 , len &gt; 0 
    <ol>
      <li>令 indx 为 ToString(len–1). </li>

      <li>令 element 为 以 indx 作为参数调用 O 的 [[Get]] 内部方法的结果 . </li>

      <li>以 indx 和 true 作为参数调用 O 的 [[Delete]] 内部方法 . </li>

      <li>以 &quot;length&quot;, indx, 和 true 作为参数调用 O 的 [[Put]] 内部方法 . </li>

      <li>返回 element.</li>
    </ol>
  </li>
</ol>

<p>注：pop 函数被有意设计成通用的；它的 this 值并非必须是数组对象。因此，它可以作为方法转移到其他类型的对象中。一个宿主对象是否可以正确应用这个 pop 函数是依赖于实现的。</p>



<h6>Array.prototype.push ( [ item1 [ , item2 [ , … ] ] ] )</h6>

<p>将参数以他们出现的顺序追加到数组末尾。数组的新 length 属性值会作为调用的结果返回。</p>

<p>当以零或更多个参数 item1,item2, 等等，调用 push 方法，采用以下步骤：</p>

<ol>
  <li>令 O 为以 this 值作为参数调用 ToObject 的结果 . </li>

  <li>令 lenVal 为以 &quot;length&quot; 作为参数调用 O 的 [[Get]] 内部方法的结果 . </li>

  <li>令 n 为 ToUint32(lenVal). </li>

  <li>令 items 为一个内部列表，它的元素是调用这个函数时传入的参数（从左到右的顺序）. </li>

  <li>只要 items 不是空就重复 
    <ol>
      <li>删除 items 的第一个元素，并令 E 为这个元素的值 . </li>

      <li>以 ToString(n), E, 和 true 作为参数调用 O 的 [[Put]] 内部方法 . </li>

      <li>n 递增 1.</li>
    </ol>
  </li>

  <li>以 &quot;length&quot;, n, 和 true 作为参数调用 O 的 [[Put]] 内部方法 . </li>

  <li>返回 n.</li>
</ol>

<p>push 方法的 length 属性是 1。</p>

<p>注：push 函数被有意设计成通用的；它的 this 值并非必须是数组对象。因此，它可以作为方法转移到其他类型的对象中。一个宿主对象是否可以正确应用这个 push 函数是依赖于实现的。</p>



<h6>Array.prototype.reverse ( )</h6>

<p>重新排列数组元素，以翻转它们的顺序。对象会被当做调用的结果返回。</p>

<ol>
  <li>令 O 为以 this 值作为参数调用 ToObject 的结果 . </li>

  <li>令 lenVal 为以 &quot;length&quot; 作为参数调用 O 的 [[Get]] 内部方法的结果 . </li>

  <li>令 len 为 ToUint32(lenVal). </li>

  <li>令 middle 为 floor(len/2). </li>

  <li>令 lower 为 0. </li>

  <li>只要 lower ≠ middle 就重复 
    <ol>
      <li>令 upper 为 len−lower −1. </li>

      <li>令 upperP 为 ToString(upper). </li>

      <li>令 lowerP 为 ToString(lower). </li>

      <li>令 lowerValue 为以 lowerP 作为参数调用 O 的 [[Get]] 内部方法的结果 . </li>

      <li>令 upperValue 为以 upperP 作为参数调用 O 的 [[Get]] 内部方法的结果 . </li>

      <li>令 lowerExists 为以 lowerP 作为参数调用 O 的 [[HasProperty]] 内部方法的结果 . </li>

      <li>令 upperExists 为以 upperP 作为参数调用 O 的 [[HasProperty]] 内部方法的结果 . </li>

      <li>如果 lowerExists 是 true 并且 upperExists 是 true, 则 
        <ol>
          <li>以 lowerP, upperValue, 和 true 作为参数调用 O 的 [[Put]] 内部方法 . </li>

          <li>以 upperP, lowerValue, 和 true 作为参数调用 O 的 [[Put]] 内部方法 .</li>
        </ol>
      </li>

      <li>否则如果 lowerExists 是 false 并且 upperExists 是 true, 则 
        <ol>
          <li>以 lowerP, upperValue, 和 true 作为参数调用 O 的 [[Put]] 内部方法 . </li>

          <li>以 upperP 和 true 作为参数调用 O 的 [[Delete]] 内部方法 .</li>
        </ol>
      </li>

      <li>否则如果 lowerExists 是 true 并且 upperExists 是 false, 则 
        <ol>
          <li>以 lowerP 和 true 作为参数调用 O 的 [[Delete]] 内部方法 . </li>

          <li>以 upperP, lowerValue, 和 true 作为参数调用 O 的 [[Put]] 内部方法 .</li>
        </ol>
      </li>

      <li>否则 , lowerExists 和 upperExists 都是 false 
        <ol>
          <li>不需要做任何事情 .</li>
        </ol>
      </li>

      <li>lower 递增 1.</li>
    </ol>
  </li>

  <li>返回 O .</li>
</ol>

<p>注：reverse 函数被有意设计成通用的；它的 this 值并非必须是数组对象。因此，它可以作为方法转移到其他类型的对象中。一个宿主对象是否可以正确应用这个 reverse 函数是依赖于实现的。</p>



<h6>Array.prototype.shift ( )</h6>

<p>删除并返回数组的第一个元素。</p>

<ol>
  <li>令 O 为以 this 值作为参数调用 ToObject 的结果 . </li>

  <li>令 lenVal 为以 &quot;length&quot; 作为参数调用 O 的 [[Get]] 内部方法的结果 . </li>

  <li>令 len 为 ToUint32(lenVal). </li>

  <li>如果 len 是零 , 则 
    <ol>
      <li>以 &quot;length&quot;, 0, 和 true 作为参数调用 O 的 [[Put]] 内部方法 . </li>

      <li>返回 undefined.</li>
    </ol>
  </li>

  <li>令 first 为以 &quot;0&quot; 作为参数调用 O 的 [[Get]] 内部方法的结果 . </li>

  <li>令 k 为 1. </li>

  <li>只要 k &lt; len 就重复 
    <ol>
      <li>令 from 为 ToString(k). </li>

      <li>令 to 为 ToString(k–1). </li>

      <li>令 fromPresent 为以 from 作为参数调用 O 的 [[HasProperty]] 内部方法的结果 . </li>

      <li>如果 fromPresent 是 true, 则 
        <ol>
          <li>令 fromVal 为以 from 作为参数调用 O 的 [[Get]] 内部方法的结果 . </li>

          <li>以 to, fromVal, 和 true 作为参数调用 O 的 [[Put]] 内部方法 .</li>
        </ol>
      </li>

      <li>否则 , fromPresent 是 false 
        <ol>
          <li>以 to 和 ture 作为参数调用 O 的 [[Delete]] 内部方法 .</li>
        </ol>
      </li>

      <li>k 递增 1.</li>
    </ol>
  </li>

  <li>以 ToString(len–1) 和 true 作为参数调用 O 的 [[Delete]] 内部方法 . </li>

  <li>以 &quot;length&quot;, (len–1) , 和 true 作为参数调用 O 的 [[Put]] 内部方法 . </li>

  <li>返回 first.</li>
</ol>

<p>注：shift 函数被有意设计成通用的；它的 this 值并非必须是数组对象。因此，它可以作为方法转移到其他类型的对象中。一个宿主对象是否可以正确应用这个 shift 函数是依赖于实现的。</p>



<h6>Array.prototype.slice (start, end)</h6>

<p>slice 方法需要 start 和 end 两个参数，返回一个数组，这个数组包含从第 start 个元素到 -- 但不包括 -- 第 end 个元素 ( 或如果 end 是 undefined 就到数组末尾 )。如果 start 为负，它会被当做是 length+start，这里的 length 是数组长度。如果 end 为负，它会被当做是 length+end，这里的 length 是数组长度。采用如下步骤：</p>

<ol>
  <li>令 O 为以 this 值作为参数调用 ToObject 的结果 . </li>

  <li>令 A 为仿佛用表达式 new Array() 创建的新数组，这里的 Array 是标准内置构造器名 . </li>

  <li>令 lenVal 为以 &quot;length&quot; 作为参数调用 O 的 [[Get]] 内部方法的结果 . </li>

  <li>令 len 为 ToUint32(lenVal). </li>

  <li>令 relativeStart 为 ToInteger(start). </li>

  <li>如果 relativeStart 为负 , 令 k 为 max((len +relativeStart),0); 否则令 k 为 min(relativeStart,len). </li>

  <li>如果 end 是 undefined, 令 relativeEnd 为 len; 否则令 relativeEnd 为 ToInteger(end). </li>

  <li>如果 relativeEnd 为负 , 令 final 为 max((len + relativeEnd),0); 否则令 final 为 min(relativeEnd,len). </li>

  <li>令 n 为 0. </li>

  <li>只要 k &lt; final 就重复 
    <ol>
      <li>令 Pk 为 ToString(k). </li>

      <li>令 kPresent 为 Pk 作为参数调用 O 的 [[HasProperty]] 内部方法的结果 . </li>

      <li>如果 kPresent 是 true, 则 
        <ol>
          <li>令 kValue 为以 Pk 作为参数调用 O 的 [[Get]] 内部方法的结果 . </li>

          <li>以 ToString(n), 属性描述符 {[[Value]]: kValue, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, 和 false 作为参数调用 A 的 [[DefineOwnProperty]] 内部方法 .</li>
        </ol>
      </li>

      <li>k 递增 1. </li>

      <li>n 递增 1.</li>
    </ol>
  </li>

  <li>返回 A.</li>
</ol>

<p>slice 方法的 length 属性是 2。</p>

<p>注：slice 函数被有意设计成通用的；它的 this 值并非必须是数组对象。因此，它可以作为方法转移到其他类型的对象中。一个宿主对象是否可以正确应用这个 slice 函数是依赖于实现的。</p>



<h6>Array.prototype.sort (comparefn)</h6>

<p>给 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=This_%E6%95%B0%E7%BB%84%E7%9A%84%E5%85%83%E7%B4%A0&amp;action=edit&amp;redlink=1">this 数组的元素 </a>排序。排序不一定是稳定的（相等的元素们不一定按照他们原来的顺序排列）。如果 comparefn 不是 undefined，它就必须是个函数，这个函数接受两个参数 x 和 y，如果 x &lt; y 返回一个负值，如果 x = y 返回零，如果 x &gt; y 返回一个正值。</p>

<p>令 obj 为以 this 值作为参数调用 ToObject 的结果。</p>

<p>以 &quot;length&quot; 作为参数调用 obj 的 [[Get]] 内部方法，将结果作为参数调用 Uint32，令 len 为返回的结果。</p>

<p>如果 comparefn 不是 undefined 并且不是对 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=This_%E6%95%B0%E7%BB%84%E7%9A%84%E5%85%83%E7%B4%A0&amp;action=edit&amp;redlink=1">this 数组的元素 </a>保持一致的比较函数（见下面），那么这种情况下 sort 的行为是实现定义的。</p>

<p>令 proto 为 obj 的 [[Prototype]] 内部属性。如果 proto 不是 null 并且存在一个整数 j 满足下面列出的全部条件，那么这种情况下 sort 的行为是实现定义的：</p>

<ul>
  <li>obj 是 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=%E7%A8%80%E7%96%8F%E7%9A%84&amp;action=edit&amp;redlink=1">稀疏的 </a>(15.4) </li>

  <li>0 ≤ j &lt; len </li>

  <li>以 ToString(j) 作为参数调用 proto 的 [[HasProperty]] 内部方法的结果是 true</li>
</ul>

<p>如果 obj 是 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=%E7%A8%80%E7%96%8F%E7%9A%84&amp;action=edit&amp;redlink=1">稀疏的 </a>并且以下任何条件为真，那么这种情况下 sort 的行为是实现定义的：</p>

<ul>
  <li>obj 的 [[Extensible]] 内部属性是 false. </li>

  <li>任何名为小于 len 的非负整数的数组索引属性中，有 [[Configurable]] 特性是 false 的数据属性。</li>
</ul>

<p>任何名为小于 len 的非负整数的数组索引属性中，有访问器属性，或有 [[Writable]] 特性是 false 的数据属性，那么这种情况下 sort 的行为是实现定义的。</p>

<p>否则，采用如下步骤。</p>

<ol>
  <li>对 obj 的 [[Get]] , [[Put]], [[Delete]] 内部方法和 SortCompare（下面描述）执行一个依赖于实现的调用序列，这里对每个 [[Get]], [[Put]], 或 [[Delete]] 调用的第一个参数是小于 len 的非负整数 ，SortCompare 调用的参数是前面调用 [[Get]] 内部方法的结果。调用 [[Put]] 和 [[Delete]] 内部方法时，throw 参数是 true。如果 obj 不是 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=%E7%A8%80%E7%96%8F%E7%9A%84&amp;action=edit&amp;redlink=1">稀疏的 </a>，则必须不调用 [[Delete]]。 </li>

  <li>返回 obj。</li>
</ol>

<p>返回的对象必须拥有下面两个性质。</p>

<ul>
  <li>必须有这样的数学排列π，它是由比 len 小的非负整数组成 , 对于每个比 len 小的非负整数 j, 如果属性 old[j] 存在 , 则 new[π(j)] 有与 old[j] 相同的值，如果属性 old[j] 不存在，则 new[π(j)] 也不存在。 </li>

  <li>对于都比 len 小的所有非负整数 j 和 k，如果 SortCompare(j,k) &lt; 0 ( 见下面的 SortCompare), 则π(j) &lt; π(k).</li>
</ul>

<p>这里的符号 old[j] 用来指：假定在执行这个函数之前以 j 作为参数调用 obj 的 [[Get]] 内部方法的结果，符号 new[j] 用来指：假定在执行这个函数后以 j 作为参数调用 obj 的 [[Get]] 内部方法的结果。</p>

<p>如果对于集合 S 里的任何值 a，b，c（可以是相同值），都满足以下所有条件，那么函数 comparefn 是在集合 S 上保持一致的比较函数（以下，符号 a &lt;<sub>CF</sub> b 表示 comparefn(a,b) &lt; 0；符号 a =<sub>CF</sub> b 表示 comparefn(a,b) = 0（不论正负）； 符号 a &gt;<sub>CF</sub> b 表示 comparefn(a,b) &gt; 0）：</p>

<ul>
  <li>当用指定值 a 和 b 作为两个参数调用 comparefn(a,b)，总是返回相同值 v。此外 Type(v) 是 Number, 并且 v 不是 NaN。注意，这意味着对于给定的 a 和 b，a &lt;<sub>CF</sub> b, a =<sub>CF</sub> b, and a &gt;<sub>CF</sub> b 中正好有一个是真。 </li>

  <li>调用 comparefn(a,b) 不改变 this 对象。 </li>

  <li>a =<sub>CF</sub> a ( 自反性 ) </li>

  <li>如果 a =<sub>CF</sub> b, 则 b =<sub>CF</sub> a ( 对称性 ) </li>

  <li>如果 a =<sub>CF</sub> b 并且 b =<sub>CF</sub> c, 则 a =<sub>CF</sub> c (=<sub>CF</sub> 传递 ) </li>

  <li>如果 a &lt;<sub>CF</sub> b 并且 b &lt;<sub>CF</sub> c, 则 a &lt;<sub>CF</sub> c (&lt;<sub>CF</sub> 传递 ) </li>

  <li>如果 a &gt;<sub>CF</sub> b 并且 b &gt;<sub>CF</sub> c, 则 a &gt;<sub>CF</sub> c (&gt;<sub>CF</sub> 传递 )</li>
</ul>

<p>注： 这些条件是确保 comparefn 划分集合 S 为等价类并且是完全排序等价类的充分必要条件。</p>

<p>当用两个参数 j 和 k 调用抽象操作 SortCompare，采用如下步骤：</p>

<ol>
  <li>令 jString 为 ToString(j). </li>

  <li>令 kString 为 ToString(k). </li>

  <li>令 hasj 为 以 jString 作为参数调用 obj 的 [[HasProperty]] 内部方法的结果。 </li>

  <li>令 hask 为 以 kString 作为参数调用 obj 的 [[HasProperty]] 内部方法的结果。 </li>

  <li>如果 hasj 和 hask 都是 false, 则返回 +0. </li>

  <li>如果 hasj 是 false, 则返回 1. </li>

  <li>如果 hask 是 false, 则返回 –1. </li>

  <li>令 x 为 以 jString 作为参数调用 obj 的 [[Get]] 内部方法的结果。 </li>

  <li>令 y 为 以 kString 作为参数调用 obj 的 [[Get]] 内部方法的结果。 </li>

  <li>如果 x 和 y 都是 undefined, 返回 +0. </li>

  <li>如果 x 是 undefined, 返回 1. </li>

  <li>如果 y 是 undefined, 返回 −1. </li>

  <li>如果 参数 comparefn 不是 undefined, 则 
    <ol>
      <li>如果 IsCallable(comparefn) 是 false, 抛出一个 TypeError 异常 . </li>

      <li>传入 undefined 作为 this 值，以 x 和 y 作为参数调用 comparefn 的 [[Call]] 内部方法，返回结果。</li>
    </ol>
  </li>

  <li>令 xString 为 ToString(x). </li>

  <li>令 yString 为 ToString(y). </li>

  <li>如果 xString &lt; yString, 返回 −1. </li>

  <li>如果 xString &gt; yString, 返回 1. </li>

  <li>返回 +0.</li>
</ol>

<p>注：1. 因为不存在的属性值总是比 undefined 属性值大，并且 undefined 属性值总是比任何其他值大，所以 undefined 属性值总是排在结果的末尾，后面跟着不存在属性值。</p>

<p>注：2. sort 函数被有意设计成通用的；它的 this 值并非必须是数组对象。因此，它可以作为方法转移到其他类型的对象中。一个宿主对象是否可以正确应用这个 sort 函数是依赖于实现的。</p>



<h6>Array.prototype.splice (start, deleteCount [ , item1 [ , item2 [ , … ] ] ] )</h6>

<p>当以两个或更多参数 start, deleteCount 和 ( 可选的 ) item1, item2, 等等，调用 splice 方法，从数组索引 start 开始的 deleteCount 个数组元素会被替换为参数 item1, item2, 等等。返回一个包含参数元素（如果有）的数组。采用以下步骤：</p>

<ol>
  <li>令 O 为 以 this 值作为参数调用 ToObject 的结果 . </li>

  <li>令 A 为 仿佛用表达式 new Array() 创建的新数组，这里的 Array 是标准内置构造器名。 </li>

  <li>令 lenVal 为 以 &quot;length&quot; 作为参数调用 O 的 [[Get]] 内部方法的结果 . </li>

  <li>令 len 为 ToUint32(lenVal). </li>

  <li>令 relativeStart 为 ToInteger(start). </li>

  <li>如果 relativeStart 为负 , 令 actualStart 为 max((len + relativeStart),0); 否则令 actualStart 为 min(relativeStart, len). </li>

  <li>令 actualDeleteCount 为 min(max(ToInteger(deleteCount),0),len – actualStart). </li>

  <li>令 k 为 0. </li>

  <li>只要 k &lt; actualDeleteCount 就重复 
    <ol>
      <li>令 from 为 ToString(actualStart+k). </li>

      <li>令 fromPresent 为 以 from 作为参数调用 O 的 [[HasProperty]] 内部方法的结果。 </li>

      <li>如果 fromPresent 是 true, 则 
        <ol>
          <li>令 fromValue 为 以 from 作为参数调用 O 的 [[Get]] 内部方法的结果。 </li>

          <li>以 ToString(k), 属性描述符 {[[Value]]: fromValue, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, 和 false 作为参数调用 A 的 [[DefineOwnProperty]] 内部方法。</li>
        </ol>
      </li>

      <li>k 递增 1.</li>
    </ol>
  </li>

  <li>令 items 为一个内部列表，它的元素是实际参数列表中 item1 开始的参数（从左到右的顺序）。如果没传入这些项目，则列表是空的。 </li>

  <li>令 itemCount 为 items 的元素个数 . </li>

  <li>如果 itemCount &lt; actualDeleteCount, 则 
    <ol>
      <li>令 k 为 actualStart. </li>

      <li>只要 k &lt; (len – actualDeleteCount) 就重复 
        <ol>
          <li>令 from 为 ToString(k+actualDeleteCount). </li>

          <li>令 to 为 ToString(k+itemCount). </li>

          <li>令 fromPresent 为 以 from 作为参数调用 O 的 [[HasProperty]] 内部方法的结果 . </li>

          <li>如果 fromPresent 是 true, 则 
            <ol>
              <li>令 fromValue 为 以 from 作为参数调用 O 的 [[Get]] 内部方法的结果 . </li>

              <li>以 to, fromValue, 和 true 作为参数调用 O 的 [[Put]] 内部方法 .</li>
            </ol>
          </li>

          <li>否则 , fromPresent 是 false 
            <ol>
              <li>以 to 和 true 作为参数调用 O 的 [[Delete]] 内部方法 .</li>
            </ol>
          </li>

          <li>k 递增 1.</li>
        </ol>
      </li>

      <li>令 k 为 len. </li>

      <li>只要 k &gt; (len – actualDeleteCount +itemCount) 就重复 
        <ol>
          <li>以 ToString(k–1) 和 true 作为参数调用 O 的 [[Delete]] 内部方法 . </li>

          <li>k 递减 1.</li>
        </ol>
      </li>
    </ol>
  </li>

  <li>否则如果 itemCount &gt; actualDeleteCount, 则 
    <ol>
      <li>令 k 为 (len – actualDeleteCount). </li>

      <li>只要 k &gt; actualStart 就重复 
        <ol>
          <li>令 from 为 ToString(k + actualDeleteCount – 1). </li>

          <li>令 to 为 ToString(k + itemCount – 1) </li>

          <li>令 fromPresent 为 以 from 作为参数调用 O 的 [[HasProperty]] 内部方法的结果 . </li>

          <li>如果 fromPresent 是 true, 则 
            <ol>
              <li>令 fromValue 为 以 from 作为参数调用 O 的 [[Get]] 内部方法的结果 . </li>

              <li>以 to, fromValue, 和 true 作为参数调用 O 的 [[Put]] 内部方法 .</li>
            </ol>
          </li>

          <li>否则 , fromPresent 是 false 
            <ol>
              <li>以 to 和 true 作为参数调用 O 的 [[Delete]] 内部方法 .</li>
            </ol>
          </li>

          <li>k 递减 1.</li>
        </ol>
      </li>
    </ol>
  </li>

  <li>令 k 为 actualStart. </li>

  <li>只要 items 不是空 就重复 
    <ol>
      <li>删除 items 的第一个元素 , 并令 E 为这个元素值 . </li>

      <li>以 ToString(k), E, 和 true 作为参数调用 O 的 [[Put]] 内部方法 . </li>

      <li>k 递增 1.</li>
    </ol>
  </li>

  <li>以 &quot;length&quot;, (len – actualDeleteCount + itemCount), 和 true 作为参数调用 O 的 [[Put]] 内部方法 . </li>

  <li>返回 A.</li>
</ol>

<p>splice 方法的 length 属性是 2。</p>

<p>注：splice 函数被有意设计成通用的；它的 this 值并非必须是数组对象。因此，它可以作为方法转移到其他类型的对象中。一个宿主对象是否可以正确应用这个 splice 函数是依赖于实现的。</p>



<h6>Array.prototype.unshift ( [ item1 [ , item2 [ , … ] ] ] )</h6>

<p>将参数们插入到数组的开始位置，它们在数组中的顺序与它们出现在参数列表中的顺序相同。</p>

<p>当以零或更多个参数 item1,item2, 等等，调用 unshift 方法，采用如下步骤：</p>

<ol>
  <li>令 O 为 以 this 值作为参数调用 ToObject 的结果 . </li>

  <li>令 lenVal 为 以 &quot;length&quot; 作为参数调用 O 的 [[Get]] 内部方法的结果 . </li>

  <li>令 len 为 ToUint32(lenVal). </li>

  <li>令 argCount 为 实际参数的个数 . </li>

  <li>令 k 为 len. </li>

  <li>只要 k &gt; 0, 就重复 
    <ol>
      <li>令 from 为 ToString(k–1). </li>

      <li>令 to 为 ToString(k+argCount –1). </li>

      <li>令 fromPresent 为 以 from 作为参数调用 O 的 [[HasProperty]] 内部方法的结果 . </li>

      <li>如果 fromPresent 是 true, 则 
        <ol>
          <li>令 fromValue 为 以 from 作为参数调用 O 的 [[Get]] 内部方法的结果 . </li>

          <li>以 to, fromValue, 和 true 作为参数调用 O 的 [[Put]] 内部方法 .</li>
        </ol>
      </li>

      <li>否则 , fromPresent 是 false 
        <ol>
          <li>以 to 和 true 作为参数调用 O 的 [[Delete]] 内部方法 .</li>
        </ol>
      </li>

      <li>k 递减 1.</li>
    </ol>
  </li>

  <li>令 j 为 0. </li>

  <li>令 items 为一个内部列表，它的元素是调用这个函数时传入的实际参数（从左到右的顺序）。 </li>

  <li>只要 items 不是空，就重复 
    <ol>
      <li>删除 items 的第一个元素，并令 E 为这个元素值 . </li>

      <li>以 ToString(j), E, 和 true 作为参数调用 O 的 [[Put]] 内部方法 . </li>

      <li>j 递增 1.</li>
    </ol>
  </li>

  <li>以 &quot;length&quot;, len+argCount, 和 true 作为参数调用 O 的 [[Put]] 内部方法 . </li>

  <li>返回 len+argCount.</li>
</ol>

<p>unshift 方法的 length 属性是 1。</p>

<p>注：unshift 函数被有意设计成通用的；它的 this 值并非必须是数组对象。因此，它可以作为方法转移到其他类型的对象中。一个宿主对象是否可以正确应用这个 unshift 函数是依赖于实现的。</p>



<h6>Array.prototype.indexOf ( searchElement [ , fromIndex ] )</h6>

<p>indexOf 按照索引的升序比较 searchElement 和数组里的元素们，它使用内部的严格相等比较算法 (11.9.6)，如果找到一个或更多这样的位置，返回这些位置中第一个索引；否则返回 -1。</p>

<p>可选的第二个参数 fromIndex 默认是 0（即搜索整个数组）。如果它大于或等于数组长度，返回 -1，即不会搜索数组。如果它是负的，就把它当作从数组末尾到计算后的 fromIndex 的偏移量。如果计算后的索引小于 0，就搜索整个数组。</p>

<p>当用一个或两个参数调用 indexOf 方法 , 采用以下步骤 :</p>

<ol>
  <li>令 O 为 以 this 值作为参数调用 ToObject 的结果 . </li>

  <li>令 lenValue 为 以 &quot;length&quot; 作为参数调用 O 的 [[Get]] 内部方法的结果 . </li>

  <li>令 len 为 ToUint32(lenValue). </li>

  <li>如果 len 是 0, 返回 -1. </li>

  <li>如果 传入了参数 fromIndex, 则令 n 为 ToInteger(fromIndex); 否则令 n 为 0. </li>

  <li>如果 n ≥ len, 返回 -1. </li>

  <li>如果 n ≥ 0, 则 
    <ol>
      <li>令 k 为 n.</li>
    </ol>
  </li>

  <li>否则 , n&lt;0 
    <ol>
      <li>令 k 为 len - abs(n). </li>

      <li>如果 k 小于 0, 则令 k 为 0.</li>
    </ol>
  </li>

  <li>只要 k&lt;len，就重复 
    <ol>
      <li>令 kPresent 为 以 ToString(k) 为参数调用 O 的 [[HasProperty]] 内部方法的结果 . </li>

      <li>如果 kPresent 是 true, 则 
        <ol>
          <li>令 elementK 为 以 ToString(k) 为参数调用 O 的 [[Get]] 内部方法的结果 . </li>

          <li>令 same 为 对 searchElement 和 elementK 执行严格相等比较算法的结果 . </li>

          <li>如果 same 是 true, 返回 k.</li>
        </ol>
      </li>

      <li>k 递增 1.</li>
    </ol>
  </li>

  <li>返回 -1.</li>
</ol>

<p>indexOf 方法的 length 属性是 1。</p>

<p>注：indexOf 函数被有意设计成通用的；它的 this 值并非必须是数组对象。因此，它可以作为方法转移到其他类型的对象中。一个宿主对象是否可以正确应用这个 indexOf 函数是依赖于实现的。</p>



<h6>Array.prototype.lastIndexOf ( searchElement [ , fromIndex ] )</h6>

<p>lastIndexOf 按照索引的降序比较 searchElement 和数组里的元素们，它使用内部的严格相等比较算法 (11.9.6)，如果找到一个或更多这样的位置，返回这些位置中最后一个索引；否则返回 -1。</p>

<p>可选的第二个参数 fromIndex 默认是数组的长度减一（即搜索整个数组）。如果它大于或等于数组长度，将会搜索整个数组。如果它是负的，就把它当作从数组末尾到计算后的 fromIndex 的偏移量。如果计算后的索引小于 0，返回 -1。</p>

<p>当用一个或两个参数调用 lastIndexOf 方法，采用如下步骤 :</p>

<ol>
  <li>令 O 为 以 this 值作为参数调用 ToObject 的结果 . </li>

  <li>令 lenValue 为 以 &quot;length&quot; 作为参数调用 O 的 [[Get]] 内部方法的结果 . </li>

  <li>令 len 为 ToUint32(lenValue). </li>

  <li>如果 len is 0, 返回 -1. </li>

  <li>如果 传入了参数 fromIndex, 则令 n 为 ToInteger(fromIndex); 否则令 n 为 len. </li>

  <li>如果 n ≥ 0, 则令 k 为 min(n, len – 1). </li>

  <li>否则 , n &lt; 0 
    <ol>
      <li>令 k 为 len - abs(n).</li>
    </ol>
  </li>

  <li>只要 k≥ 0 就重复 
    <ol>
      <li>令 kPresent 为 以 ToString(k) 作为参数调用 O 的 [[HasProperty]] 内部方法的结果 . </li>

      <li>如果 kPresent 是 true, 则 
        <ol>
          <li>令 elementK 为 以 ToString(k) 作为参数调用 O 的 [[Get]] 内部方法的结果 . </li>

          <li>令 same 为 对 searchElement 和 elementK 执行严格相等比较算法的结果 . </li>

          <li>如果 same 是 true, 返回 k.</li>
        </ol>
      </li>

      <li>k 递减 1.</li>
    </ol>
  </li>

  <li>返回 -1.</li>
</ol>

<p>lastIndexOf 方法的 length 属性是 1。</p>

<p>注：lastIndexOf 函数被有意设计成通用的；它的 this 值并非必须是数组对象。因此，它可以作为方法转移到其他类型的对象中。一个宿主对象是否可以正确应用这个 lastIndexOf 函数是依赖于实现的。</p>



<h6>Array.prototype.every ( callbackfn [ , thisArg ] )</h6>

<p>callbackfn 应该是个函数，它接受三个参数并返回一个可转换为布尔值 true 和 false 的值。every 按照索引的升序，对数组里存在的每个元素调用一次 callbackfn，直到他找到一个使 callbackfn 返回 false 的元素。如果找到这样的元素，every 马上返回 false，否则如果对所有元素 callbackfn 都返回 true，every 将返回 true。callbackfn 只被数组里实际存在的元素调用；它不会被缺少的元素调用。</p>

<p>如果提供了一个 thisArg 参数，它会被当作 this 值传给每个 callbackfn 调用。如果没提供它，用 undefined 替代。</p>

<p>调用 callbackfn 时将传入三个参数：元素的值，元素的索引，和遍历的对象。</p>

<p>对 every 的调用不直接更改对象，但是对 callbackfn 的调用可能更改对象。</p>

<p>every 处理的元素范围是在首次调用 callbackfn 之前设定的。在 every 调用开始后追加到数组里的元素们不会被 callbackfn 访问。如果更改以存在数组元素，every 访问这些元素时的值会传给 callbackfn；在 every 调用开始后删除的和之前被访问过的元素们是不访问的。every 的行为就像数学量词“所有（for all）”。特别的，对一个空数组，它返回 true。</p>

<p>当以一个或两个参数调用 every 方法，采用以下步骤：</p>

<ol>
  <li>令 O 为 以 this 值作为参数调用 ToObject 的结果 . </li>

  <li>令 lenValue 为 以 &quot;length&quot; 作为参数调用 O 的 [[Get]] 内部方法的结果 . </li>

  <li>令 len 为 ToUint32(lenValue). </li>

  <li>如果 IsCallable(callbackfn) 是 false, 抛出一个 TypeError 异常 . </li>

  <li>如果提供了 thisArg, 令 T 为 thisArg; 否则令 T 为 undefined. </li>

  <li>令 k 为 0. </li>

  <li>只要 k &lt; len ，就重复 
    <ol>
      <li>令 Pk 为 ToString(k). </li>

      <li>令 kPresent 为 以 Pk 作为参数调用 O 的 [[HasProperty]] 内部方法的结果 . </li>

      <li>如果 kPresent 是 true, 则 
        <ol>
          <li>令 kValue 为 以 Pk 作为参数调用 O 的 [[Get]] 内部方法的结果 . </li>

          <li>令 testResult 为 以 T 作为 this 值以包含 kValue, k, 和 O 的参数列表调用 callbackfn 的 [[Call]] 内部方法的结果 . </li>

          <li>如果 ToBoolean(testResult) 是 false, 返回 false.</li>
        </ol>
      </li>

      <li>k 递增 1.</li>
    </ol>
  </li>

  <li>返回 true.</li>
</ol>

<p>every 方法的 length 属性是 1。</p>

<p>注：every 函数被有意设计成通用的；它的 this 值并非必须是数组对象。因此，它可以作为方法转移到其他类型的对象中。一个宿主对象是否可以正确应用这个 every 函数是依赖于实现的。</p>



<h6>Array.prototype.some ( callbackfn [ , thisArg ] )</h6>

<p>callbackfn 应该是个函数，它接受三个参数并返回一个可转换为布尔值 true 和 false 的值。some 按照索引的升序，对数组里存在的每个元素调用一次 callbackfn，直到他找到一个使 callbackfn 返回 true 的元素。如果找到这样的元素，some 马上返回 true，否则，some 返回 false。callbackfn 只被实际存在的数组元素调用；它不会被缺少的数组元素调用。</p>

<p>如果提供了一个 thisArg 参数，它会被当作 this 值传给每个 callbackfn 调用。如果没提供它，用 undefined 替代。</p>

<p>调用 callbackfn 时将传入三个参数：元素的值，元素的索引，和遍历的对象。</p>

<p>对 some 的调用不直接更改对象，但是对 callbackfn 的调用可能更改对象。</p>

<p>some 处理的元素范围是在首次调用 callbackfn 之前设定的。在 some 调用开始后追加到数组里的元素们不会被 callbackfn 访问。如果更改以存在数组元素，some 访问这些元素时的值会传给 callbackfn；在 some 调用开始后删除的和之前被访问过的元素们是不访问的。some 的行为就像数学量词“存在（exists）”。特别的，对一个空数组，它返回 false。</p>

<p>当以一个或两个参数调用 some 方法，采用以下步骤：</p>

<ol>
  <li>令 O 为 以 this 值作为参数调用 ToObject 的结果 . </li>

  <li>令 lenValue 为 以 &quot;length&quot; 作为参数调用 O 的 [[Get]] 内部方法的结果 . </li>

  <li>令 len 为 ToUint32(lenValue). </li>

  <li>如果 IsCallable(callbackfn) 是 false, 抛出一个 TypeError 异常 . </li>

  <li>如果提供了 thisArg, 令 T 为 thisArg; 否则令 T 为 undefined. </li>

  <li>令 k 为 0. </li>

  <li>只要 k &lt; len ，就重复 
    <ol>
      <li>令 Pk 为 ToString(k). </li>

      <li>令 kPresent 为 以 Pk 作为参数调用 O 的 [[HasProperty]] 内部方法的结果 . </li>

      <li>如果 kPresent 是 true, 则 
        <ol>
          <li>令 kValue 为 以 Pk 作为参数调用 O 的 [[Get]] 内部方法的结果 . </li>

          <li>令 testResult 为 以 T 作为 this 值以包含 kValue, k, 和 O 的参数列表调用 callbackfn 的 [[Call]] 内部方法的结果 . </li>

          <li>如果 ToBoolean(testResult) 是 true, 返回 true.</li>
        </ol>
      </li>

      <li>k 递增 1.</li>
    </ol>
  </li>

  <li>返回 false.</li>
</ol>

<p>some 方法的 length 属性是 1。</p>

<p>注：some 函数被有意设计成通用的；它的 this 值并非必须是数组对象。因此，它可以作为方法转移到其他类型的对象中。一个宿主对象是否可以正确应用这个 some 函数是依赖于实现的。</p>



<h6>Array.prototype.forEach ( callbackfn [ , thisArg ] )</h6>

<p>callbackfn 应该是个函数，它接受三个参数。forEach 按照索引的升序，对数组里存在的每个元素调用一次 callbackfn。callbackfn 只被实际存在的数组元素调用；它不会被缺少的数组元素调用。</p>

<p>如果提供了一个 thisArg 参数，它会被当作 this 值传给每个 callbackfn 调用。如果没提供它，用 undefined 替代。</p>

<p>调用 callbackfn 时将传入三个参数：元素的值，元素的索引，和遍历的对象。</p>

<p>对 forEach 的调用不直接更改对象，但是对 callbackfn 的调用可能更改对象。</p>

<p>forEach 处理的元素范围是在首次调用 callbackfn 之前设定的。在 forEach 调用开始后追加到数组里的元素们不会被 callbackfn 访问。如果更改以存在数组元素，forEach 访问这些元素时的值会传给 callbackfn；在 forEach 调用开始后删除的和之前被访问过的元素们是不访问的。</p>

<p>当以一个或两个参数调用 forEach 方法，采用以下步骤：</p>

<ol>
  <li>令 O 为 以 this 值作为参数调用 ToObject 的结果 . </li>

  <li>令 lenValue 为 以 &quot;length&quot; 作为参数调用 O 的 [[Get]] 内部方法的结果 . </li>

  <li>令 len 为 ToUint32(lenValue). </li>

  <li>如果 IsCallable(callbackfn) 是 false, 抛出一个 TypeError 异常 . </li>

  <li>如果提供了 thisArg, 令 T 为 thisArg; 否则令 T 为 undefined. </li>

  <li>令 k 为 0. </li>

  <li>只要 k &lt; len ，就重复 
    <ol>
      <li>令 Pk 为 ToString(k). </li>

      <li>令 kPresent 为 以 Pk 作为参数调用 O 的 [[HasProperty]] 内部方法的结果 . </li>

      <li>如果 kPresent 是 true, 则 
        <ol>
          <li>令 kValue 为 以 Pk 作为参数调用 O 的 [[Get]] 内部方法的结果 . </li>

          <li>以 T 作为 this 值以包含 kValue, k, 和 O 的参数列表调用 callbackfn 的 [[Call]] 内部方法 .</li>
        </ol>
      </li>

      <li>k 递增 1.</li>
    </ol>
  </li>

  <li>返回 undefined.</li>
</ol>

<p>forEach 方法的 length 属性是 1。</p>

<p>注：forEach 函数被有意设计成通用的；它的 this 值并非必须是数组对象。因此，它可以作为方法转移到其他类型的对象中。一个宿主对象是否可以正确应用这个 forEach 函数是依赖于实现的。</p>



<h6>Array.prototype.map ( callbackfn [ , thisArg ] )</h6>

<p>callbackfn 应该是个函数，它接受三个参数。map 按照索引的升序，对数组里存在的每个元素调用一次 callbackfn，并用结果构造一个新数组。callbackfn 只被实际存在的数组元素调用；它不会被缺少的数组元素调用。</p>

<p>如果提供了一个 thisArg 参数，它会被当作 this 值传给每个 callbackfn 调用。如果没提供它，用 undefined 替代。</p>

<p>调用 callbackfn 时将传入三个参数：元素的值，元素的索引，和遍历的对象。</p>

<p>对 map 的调用不直接更改对象，但是对 callbackfn 的调用可能更改对象。</p>

<p>map 处理的元素范围是在首次调用 callbackfn 之前设定的。在 map 调用开始后追加到数组里的元素们不会被 callbackfn 访问。如果更改以存在数组元素，map 访问这些元素时的值会传给 callbackfn；在 map 调用开始后删除的和之前被访问过的元素们是不访问的。</p>

<p>当以一个或两个参数调用 map 方法，采用以下步骤：</p>

<ol>
  <li>令 O 为 以 this 值作为参数调用 ToObject 的结果 . </li>

  <li>令 lenValue 为 以 &quot;length&quot; 作为参数调用 O 的 [[Get]] 内部方法的结果 . </li>

  <li>令 len 为 ToUint32(lenValue). </li>

  <li>如果 IsCallable(callbackfn) 是 false, 抛出一个 TypeError 异常 . </li>

  <li>如果提供了 thisArg, 令 T 为 thisArg; 否则令 T 为 undefined. </li>

  <li>令 A 为 仿佛用 new Array( len) 创建的新数组，这里的 Array 是标准内置构造器名，len 是 len 的值。 </li>

  <li>令 k 为 0. </li>

  <li>只要 k &lt; len ，就重复 
    <ol>
      <li>令 Pk 为 ToString(k). </li>

      <li>令 kPresent 为 以 Pk 作为参数调用 O 的 [[HasProperty]] 内部方法的结果 . </li>

      <li>如果 kPresent 是 true, 则 
        <ol>
          <li>令 kValue 为 以 Pk 作为参数调用 O 的 [[Get]] 内部方法的结果 . </li>

          <li>令 mappedValue 为 以 T 作为 this 值以包含 kValue, k, 和 O 的参数列表调用 callbackfn 的 [[Call]] 内部方法的结果 . </li>

          <li>以 Pk, 属性描述符 {[[Value]]: mappedValue, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, 和 false 作为参数调用 A 的 [[DefineOwnProperty]] 内部方法 .</li>
        </ol>
      </li>

      <li>k 递增 1.</li>
    </ol>
  </li>

  <li>返回 A.</li>
</ol>

<p>map 方法的 length 属性是 1。</p>

<p>注：map 函数被有意设计成通用的；它的 this 值并非必须是数组对象。因此，它可以作为方法转移到其他类型的对象中。一个宿主对象是否可以正确应用这个 map 函数是依赖于实现的。</p>



<h6>Array.prototype.filter ( callbackfn [ , thisArg ] )</h6>

<p>callbackfn 应该是个函数，它接受三个参数并返回一个可转换为布尔值 true 和 false 的值。filter 按照索引的升序，对数组里存在的每个元素调用一次 callbackfn，并用使 callbackfn 返回 true 的所有值构造一个新数组。callbackfn 只被实际存在的数组元素调用；它不会被缺少的数组元素调用。</p>

<p>如果提供了一个 thisArg 参数，它会被当作 this 值传给每个 callbackfn 调用。如果没提供它，用 undefined 替代。</p>

<p>调用 callbackfn 时将传入三个参数：元素的值，元素的索引，和遍历的对象。</p>

<p>对 filter 的调用不直接更改对象，但是对 callbackfn 的调用可能更改对象。</p>

<p>filter 处理的元素范围是在首次调用 callbackfn 之前设定的。在 filter 调用开始后追加到数组里的元素们不会被 callbackfn 访问。如果更改以存在数组元素，filter 访问这些元素时的值会传给 callbackfn；在 filter 调用开始后删除的和之前被访问过的元素们是不访问的。</p>

<p>当以一个或两个参数调用 filter 方法，采用以下步骤：</p>

<ol>
  <li>令 O 为 以 this 值作为参数调用 ToObject 的结果 . </li>

  <li>令 lenValue 为 以 &quot;length&quot; 作为参数调用 O 的 [[Get]] 内部方法的结果 . </li>

  <li>令 len 为 ToUint32(lenValue). </li>

  <li>如果 IsCallable(callbackfn) 是 false, 抛出一个 TypeError 异常 . </li>

  <li>如果提供了 thisArg, 令 T 为 thisArg; 否则令 T 为 undefined. </li>

  <li>令 A 为 仿佛用 new Array( len) 创建的新数组，这里的 Array 是标准内置构造器名，len 是 len 的值。 </li>

  <li>令 k 为 0. </li>

  <li>令 to 为 0. </li>

  <li>只要 k &lt; len ，就重复 
    <ol>
      <li>令 Pk 为 ToString(k). </li>

      <li>令 kPresent 为 以 Pk 作为参数调用 O 的 [[HasProperty]] 内部方法的结果 . </li>

      <li>如果 kPresent 是 true, 则 
        <ol>
          <li>令 kValue 为 以 Pk 作为参数调用 O 的 [[Get]] 内部方法的结果 . </li>

          <li>令 selected 为 以 T 作为 this 值以包含 kValue, k, 和 O 的参数列表调用 callbackfn 的 [[Call]] 内部方法的结果 . </li>

          <li>如果 ToBoolean(selected) 是 true, 则 
            <ol>
              <li>以 ToString(to), 属性描述符 {[[Value]]: kValue, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, 和 false 作为参数调用 A 的 [[DefineOwnProperty]] 内部方法 . </li>

              <li>to 递增 1.</li>
            </ol>
          </li>
        </ol>
      </li>

      <li>k 递增 1.</li>
    </ol>
  </li>

  <li>返回 A.</li>
</ol>

<p>filter 方法的 length 属性是 1。</p>

<p>注：filter 函数被有意设计成通用的；它的 this 值并非必须是数组对象。因此，它可以作为方法转移到其他类型的对象中。一个宿主对象是否可以正确应用这个 filter 函数是依赖于实现的。</p>



<h6>Array.prototype.reduce ( callbackfn [ , initialValue ] )</h6>

<p>callbackfn 应该是个函数，它需要四个参数。reduce 按照索引的升序，对数组里存在的每个元素 , 将 callbackfn 作为回调函数调用一次。</p>

<p>调用 callbackfn 时将传入四个参数：previousValue（initialValue 的值或上次调用 callbackfn 的返回值），currentValue（当前元素值），currentIndex，和遍历的对象。第一次调用回调函数时，previousValue 和 currentValue 的取值可以是下面两种情况之一。如果为 reduce 调用提供了一个 initialValue，则 previousValue 将等于 initialValue 并且 currentValue 将等于数组的首个元素值。如果没提供 initialValue，则 previousValue 将等于数组的首个元素值并且 currentValue 将等于数组的第二个元素值。如果数组里没有元素并且没有提供 initialValue，则抛出一个 TypeError 异常。</p>

<p>对 reduce 的调用不直接更改对象，但是对 callbackfn 的调用可能更改对象。</p>

<p>reduce 处理的元素范围是在首次调用 callbackfn 之前设定的。在 reduce 调用开始后追加到数组里的元素们不会被 callbackfn 访问。如果更改以存在数组元素，reduce 访问这些元素时的值会传给 callbackfn；在 reduce 调用开始后删除的和之前被访问过的元素们是不访问的。</p>

<p>当以一个或两个参数调用 reduce 方法，采用以下步骤：</p>

<ol>
  <li>令 O 为 以 this 值作为参数调用 ToObject 的结果 . </li>

  <li>令 lenValue 为 以 &quot;length&quot; 作为参数调用 O 的 [[Get]] 内部方法的结果 . </li>

  <li>令 len 为 ToUint32(lenValue ). </li>

  <li>如果 IsCallable(callbackfn) 是 false, 抛出一个 TypeError 异常 . </li>

  <li>如果 len 是 0 并且 initialValue 不是 present, 抛出一个 TypeError 异常 . </li>

  <li>令 k 为 0. </li>

  <li>如果 initialValue 参数有传入值 , 则 
    <ol>
      <li>设定 accumulator 为 initialValue.</li>
    </ol>
  </li>

  <li>否则 , initialValue 参数没有传入值 
    <ol>
      <li>令 kPresent 为 false. </li>

      <li>只要 kPresent 是 false 并且 k &lt; len ，就重复 
        <ol>
          <li>令 Pk 为 ToString(k). </li>

          <li>令 kPresent 为 以 Pk 作为参数调用 O 的 [[HasProperty]] 内部方法的结果 . </li>

          <li>如果 kPresent 是 true, 则 
            <ol>
              <li>令 accumulator 为 以 Pk 作为参数调用 O 的 [[Get]] 内部方法的结果 .</li>
            </ol>
          </li>

          <li>k 递增 1.</li>
        </ol>
      </li>

      <li>如果 kPresent 是 false, 抛出一个 TypeError 异常 .</li>
    </ol>
  </li>

  <li>只要 k &lt; len ，就重复 
    <ol>
      <li>令 Pk 为 ToString(k). </li>

      <li>令 kPresent 为 以 Pk 作为参数调用 O 的 [[HasProperty]] 内部方法的结果 . </li>

      <li>如果 kPresent 是 true, 则 
        <ol>
          <li>令 kValue 为 以 Pk 作为参数调用 O 的 [[Get]] 内部方法的结果 . </li>

          <li>令 accumulator 为 以 undefined 作为 this 值并以包含 accumulator, kValue, k, 和 O 的参数列表调用 callbackfn 的 [[Call]] 内部方法的结果 .</li>
        </ol>
      </li>

      <li>k 递增 1.</li>
    </ol>
  </li>

  <li>返回 accumulator.</li>
</ol>

<p>reduce 方法的 length 属性是 1。</p>

<p>注：reduce 函数被有意设计成通用的；它的 this 值并非必须是数组对象。因此，它可以作为方法转移到其他类型的对象中。一个宿主对象是否可以正确应用这个 reduce 函数是依赖于实现的。</p>



<h6>Array.prototype.reduceRight ( callbackfn [ , initialValue ] )</h6>

<p>callbackfn 应该是个函数，它需要四个参数。reduceRight 按照索引的升序，对数组里存在的每个元素 , 将 callbackfn 作为回调函数调用一次。</p>

<p>调用 callbackfn 时将传入四个参数：previousValue（initialValue 的值或上次调用 callbackfn 的返回值），currentValue（当前元素值），currentIndex，和遍历的对象。第一次调用回调函数时，previousValue 和 currentValue 的取值可以是下面两种情况之一。如果为 reduceRight 调用提供了一个 initialValue，则 previousValue 将等于 initialValue 并且 currentValue 将等于数组的最后一个元素值。如果没提供 initialValue，则 previousValue 将等于数组的最后一个元素值并且 currentValue 将等于数组的倒数第二个元素值。如果数组里没有元素并且没有提供 initialValue，则抛出一个 TypeError 异常。</p>

<p>对 reduceRight 的调用不直接更改对象，但是对 callbackfn 的调用可能更改对象。</p>

<p>reduceRight 处理的元素范围是在首次调用 callbackfn 之前设定的。在 reduceRight 调用开始后追加到数组里的元素们不会被 callbackfn 访问。如果更改以存在数组元素，reduceRight 访问这些元素时的值会传给 callbackfn；在 reduceRight 调用开始后删除的和之前被访问过的元素们是不访问的。</p>

<p>当以一个或两个参数调用 reduceRight 方法，采用以下步骤：</p>

<ol>
  <li>令 O 为 以 this 值作为参数调用 ToObject 的结果 . </li>

  <li>令 lenValue 为 以 &quot;length&quot; 作为参数调用 O 的 [[Get]] 内部方法的结果 . </li>

  <li>令 len 为 ToUint32(lenValue ). </li>

  <li>如果 IsCallable(callbackfn) 是 false, 抛出一个 TypeError 异常 . </li>

  <li>如果 len 是 0 并且 initialValue 不是 present, 抛出一个 TypeError 异常 . </li>

  <li>令 k 为 0. </li>

  <li>如果 initialValue 参数有传入值 , 则 
    <ol>
      <li>设定 accumulator 为 initialValue.</li>
    </ol>
  </li>

  <li>否则 , initialValue 参数没有传入值 
    <ol>
      <li>令 kPresent 为 false. </li>

      <li>只要 kPresent 是 false 并且 k ≥ 0 ，就重复 
        <ol>
          <li>令 Pk 为 ToString(k). </li>

          <li>令 kPresent 为 以 Pk 作为参数调用 O 的 [[HasProperty]] 内部方法的结果 . </li>

          <li>如果 kPresent 是 true, 则 
            <ol>
              <li>令 accumulator 为 以 Pk 作为参数调用 O 的 [[Get]] 内部方法的结果 .</li>
            </ol>
          </li>

          <li>k 递减 1.</li>
        </ol>
      </li>

      <li>如果 kPresent 是 false, 抛出一个 TypeError 异常 .</li>
    </ol>
  </li>

  <li>只要 k ≥ 0 ，就重复 
    <ol>
      <li>令 Pk 为 ToString(k). </li>

      <li>令 kPresent 为 以 Pk 作为参数调用 O 的 [[HasProperty]] 内部方法的结果 . </li>

      <li>如果 kPresent 是 true, 则 
        <ol>
          <li>令 kValue 为 以 Pk 作为参数调用 O 的 [[Get]] 内部方法的结果 . </li>

          <li>令 accumulator 为 以 undefined 作为 this 值并以包含 accumulator, kValue, k, 和 O 的参数列表调用 callbackfn 的 [[Call]] 内部方法的结果 .</li>
        </ol>
      </li>

      <li>k 递减 1.</li>
    </ol>
  </li>

  <li>返回 accumulator.</li>
</ol>

<p>reduceRight 方法的 length 属性是 1。</p>

<p>注：reduceRight 函数被有意设计成通用的；它的 this 值并非必须是数组对象。因此，它可以作为方法转移到其他类型的对象中。一个宿主对象是否可以正确应用这个 reduceRight 函数是依赖于实现的。</p>



<h5>Array 实例的属性</h5>

<p>Array 实例从数组原型对象继承属性，Array 实例的 [[Class]] 内部属性是 &quot;Array&quot;。Array 实例还有以下属性。</p>



<h6>[[DefineOwnProperty]] ( P, Desc, Throw )</h6>

<p>数组对象使用一个，用在其他原生 ECMAscript 对象的 [[DefineOwnProperty]] 内部方法 (8.12.9) 的变化版。</p>

<p>设 A 为一个数组对象，Desc 为一个属性描述符，Throw 为一个布尔标示。</p>

<p>在以下算法中，术语“拒绝”指代“如果 Throw 是 true，则抛出 TypeError 异常，否则返回 false。</p>

<p>当用属性名 P，属性描述 Desc，布尔值 Throw 调用 A 的 [[DefineOwnProperty]] 内部方法，采用以下步骤：</p>

<ol>
  <li>令 oldLenDesc 为 以 &quot;length&quot; 作为参数调用 A 的 [[GetOwnProperty]] 内部方法的结果。 结果绝不会是 undefined 或一个访问器描述符，因为在创建数组时的 length 是一个不可删除或重新配置的数据属性。 </li>

  <li>令 oldLen 为 oldLenDesc.[[Value]]. </li>

  <li>如果 P 是 &quot;length&quot;, 则 
    <ol>
      <li>如果 Desc 的 [[Value]] 字段不存在 , 则 
        <ol>
          <li>以 &quot;length&quot;, Desc, 和 Throw 作为参数在 A 上调用默认的 [[DefineOwnProperty]] 内部方法 (8.12.9)，返回结果。</li>
        </ol>
      </li>

      <li>令 newLenDesc 为 Desc 的一个拷贝 . </li>

      <li>令 newLen 为 ToUint32(Desc.[[Value]]). </li>

      <li>如果 newLen 不等于 ToNumber( Desc.[[Value]]), 抛出一个 RangeError 异常 . </li>

      <li>设定 newLenDesc.[[Value]] 为 newLen. </li>

      <li>如果 newLen ≥oldLen, 则 
        <ol>
          <li>以 &quot;length&quot;, newLenDesc, 和 Throw 作为参数在 A 上调用默认的 [[DefineOwnProperty]] 内部方法 (8.12.9)，返回结果。</li>
        </ol>
      </li>

      <li>如果 oldLenDesc.[[Writable]] 是 false，拒绝 </li>

      <li>如果 newLenDesc.[[Writable]] 不存在或值是 true, 令 newWritable 为 true. </li>

      <li>否则 , 
        <ol>
          <li>因为它将使得无法删除任何元素，所以需要延后设定 [[Writable]] 特性为 false. </li>

          <li>令 newWritable 为 false. </li>

          <li>设定 newLenDesc.[[Writable]] 为 true.</li>
        </ol>
      </li>

      <li>令 succeeded 为 以 &quot;length&quot;, newLenDesc, 和 Throw 作为参数在 A 上调用默认的 [[DefineOwnProperty]] 内部方法 (8.12.9) 的结果 </li>

      <li>如果 succeeded 是 false, 返回 false.. </li>

      <li>只要 newLen &lt; oldLen，就重复 , 
        <ol>
          <li>设定 oldLen 为 oldLen – 1. </li>

          <li>令 deleteSucceeded 为 以 ToString(oldLen) 和 false 作为参数调用 A 的 [[Delete]] 内部方法的结果 . </li>

          <li>如果 deleteSucceeded 是 false, 则 
            <ol>
              <li>设定 newLenDesc.[[Value]] 为 oldLen+1. </li>

              <li>如果 newWritable 是 false, 设定 newLenDesc.[[Writable]] 为 false. </li>

              <li>以 &quot;length&quot;, newLenDesc, 和 false 为参数在 A 上调用默认的 [[DefineOwnProperty]] 内部方法 (8.12.9). </li>

              <li>拒绝 .</li>
            </ol>
          </li>
        </ol>
      </li>

      <li>如果 newWritable 是 false, 则 
        <ol>
          <li>以 &quot;length&quot;, 属性描述符 {[[Writable]]: false}, 和 false 作为参数在 A 上调用 [[DefineOwnProperty]] 内部方法 (8.12.9). 这个调用始终返回 true.</li>
        </ol>
      </li>

      <li>返回 true.</li>
    </ol>
  </li>

  <li>否则如果 P 是一个数组索引 (15.4), 则 
    <ol>
      <li>令 index 为 ToUint32(P). </li>

      <li>如果 index ≥ oldLen 并且 oldLenDesc.[[Writable]] 是 false，拒绝 . </li>

      <li>令 succeeded 为 以 P, Desc, 和 false 作为参数在 A 上调用默认的 [[DefineOwnProperty]] 内部方法 (8.12.9) 的结果 . </li>

      <li>如果 succeeded 是 false，拒绝 . </li>

      <li>如果 index ≥ oldLen 
        <ol>
          <li>设定 oldLenDesc.[[Value]] 为 index + 1. </li>

          <li>以 &quot;length&quot;, oldLenDesc, 和 false 作为参数在在 A 上调用默认的 [[DefineOwnProperty]] 内部方法 (8.12.9). 这个调用始终返回 true.</li>
        </ol>
      </li>

      <li>返回 true.</li>
    </ol>
  </li>

  <li>以 P, Desc, 和 Throw 作为参数在在 A 上调用默认的 [[DefineOwnProperty]] 内部方法 (8.12.9)，返回结果 .</li>
</ol>


<h6>length</h6>

<p>数组对象的 length 属性是个数据属性，其值总是在数值上大于任何属性名是数组索引的可删除属性的属性名。</p>

<p>length 属性拥有的初始特性是 { [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }.</p>

<p>注： 试图将一个数组对象的 length 属性设定为在数值上比 -- 数组中存在数组索引并且是不可参数属性中的最大数字属性名 -- 小或相等时，length 将设定为比那个最大数字属性名大一的数字子。见 15.4.5.1。</p>



<h4>String 对象</h4>


<h5>作为函数调用 String 构造器</h5>

<p>当将 String 作为函数调用，而不是作为构造器，它执行一个类型转换。</p>



<h6>String ( [ value ] )</h6>

<p>返回一个由 ToString(value) 计算出的字符串值（不是 String 对象）。如果没有提供 value，返回空字符串 &quot;&quot;。</p>



<h5>String 构造器</h5>

<p>当 String 作为一个 new 表达式的一部分被调用，它是个构造器：它初始化新创建的对象。</p>



<h6>new String ( [ value ] )</h6>

<p>新构造对象的 [[Prototype]] 内部属性设定为标准内置的字符串原型对象，它是 String.prototype 的初始值 (15.5.3.1)。</p>

<p>新构造对象的 [[Class]] 内部属性设定为 &quot;String&quot;。</p>

<p>新构造对象的 [[Extensible]] 内部属性设定为 true。</p>

<p>新构造对象的 [[PrimitiveValue]] 内部属性设定为 ToString(value)，或如果没提供 value 则设定为空字符串。</p>



<h5>String 构造器的属性</h5>

<p>String 构造器的 [[Prototype]] 内部属性的值是标准内置的函数原型对象 (15.3.4).</p>

<p>除了内部属性和 length 属性（值为 1）之外，String 构造器还有以下属性：</p>



<h6>String.prototype</h6>

<p>String.prototype 的初始值是标准内置的字符串原型对象 (15.5.4)。</p>

<p>这个属性有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。</p>



<h6>String.fromCharCode ( [ char0 [ , char1 [ , … ] ] ] )</h6>

<p>返回一个字符串值，包含的字符数与参数数目相同。每个参数指定返回字符串中的一个字符，也就是说第一个参数第一个字符，以此类推（从左到右）。一个参数转换为一个字符，通过先应用 ToUint16 (9.7) 操作，再将返回的 16 位整数看作字符的代码单元值。如果没提供参数，返回空字符串。</p>

<p>fromCharCode 函数的 length 属性是 1。</p>



<h5>字符串原型对象的属性</h5>

<p>字符串原型对象本身是一个值为空字符串的 String 对象（它的 [[Class]] 是 &quot;String&quot;）。</p>

<p>字符串原型对象的 [[Prototype]] 内部属性值是标准内置的 Object 原型对象 (15.2.4)。</p>



<h6>String.prototype.constructor</h6>

<p>String.prototype.constructor 的初始值是内置 String 构造器。</p>



<h6>String.prototype.toString ( )</h6>

<p>返回 this 字符串值。（注，对于一个 String 对象，toString 方法和 valueOf 方法返回相同值。）</p>

<p>toString 函数是非通用的 ; 如果它的 this 值不是一个字符串或字符串对象，则抛出一个 TypeError 异常。因此它不能作为方法转移到其他类型对象上。</p>



<h6>String.prototype.valueOf ( )</h6>

<p>返回 this 字符串值。</p>

<p>valueOf 函数是非通用的 ; 如果它的 this 值不是一个字符串或字符串对象，则抛出一个 TypeError 异常。因此它不能作为方法转移到其他类型对象上。</p>



<h6>String.prototype.charAt (pos)</h6>

<p>将 this 对象转换为一个字符串，返回包含了这个字符串 pos 位置的字符的字符串。如果那个位置没有字符，返回空字符串。返回结果是个字符串值，不是字符串对象。</p>

<p>如果 pos 是一个数字类型的整数值，则 x.charAt( pos) 与 x.substring( pos, pos+1) 的结果相等。</p>

<p>当用一个参数 pos 调用 charAt 方法，采用以下步骤：</p>

<ol>
  <li>以 this 值作为参数调用 CheckObjectCoercible。 </li>

  <li>令 S 为以 this 值作为参数调用 ToString 的结果 . </li>

  <li>令 position 为 ToInteger(pos). </li>

  <li>令 size 为 S 的字符数 . </li>

  <li>如果 position &lt; 0 或 position ≥ size, 返回空字符串 . </li>

  <li>返回一个长度为 1 的字符串 , 它包含 S 中 position 位置的一个字符 , 在这里 S 中的第一个（最左边）字符被当作是在位置 0，下一个字符被当作是在位置 1，等等 .</li>
</ol>

<p>注： charAt 函数被有意设计成通用的；它不要求它的 this 值是字符串对象。因此，他可以当做方法转移到其他类型对象。</p>



<h6>String.prototype.charCodeAt (pos)</h6>

<p>将 this 对象转换为一个字符串，返回一个代表这个字符串 pos 位置字符的代码单元值的数字（小于 2<sup>16</sup> 的非负整数）。如果那个位置没有字符，返回 NaN。</p>

<p>当用一个参数 pos 调用 charCodeAt 方法，采用以下步骤：</p>

<ol>
  <li>以 this 值作为参数调用 CheckObjectCoercible。 </li>

  <li>令 S 为以 this 值作为参数调用 ToString 的结果 . </li>

  <li>令 position 为 ToInteger(pos). </li>

  <li>令 size 为 S 的字符数 . </li>

  <li>如果 position &lt; 0 或 position ≥ size, 返回 NaN. </li>

  <li>返回一个数字类型值，值是字符串 S 中 position 位置字符的代码单元值。 在这里 S 中的第一个（最左边）字符被当作是在位置 0，下一个字符被当作是在位置 1，等等 .</li>
</ol>

<p>注： charCodeAt 函数被有意设计成通用的；它不要求它的 this 值是字符串对象。因此，他可以当做方法转移到其他类型对象。</p>



<h6>String.prototype.concat ( [ string1 [ , string2 [ , … ] ] ] )</h6>

<p>当用一个或更多参数 string1, string2, 等等 , 调用 concat 方法 , 它返回一个包含了 --this 对象（转换为一个字符串）中的字符们和后面跟着的每个 string1, string2, 等等，（每个参数都转换为字符串）里的字符们 -- 的字符串。返回结果是一个字符串值，不是一个字符串对象。采用以下步骤：</p>

<ol>
  <li>以 this 值作为参数调用 CheckObjectCoercible。 </li>

  <li>令 S 为以 this 值作为参数调用 ToString 的结果 . </li>

  <li>令 args 为一个内部列表，它是传给这个函数的参数列表的拷贝 . </li>

  <li>令 R 为 S. </li>

  <li>只要 args 不是空，就重复 
    <ol>
      <li>删除 args 的第一个元素，并令 next 为这个元素 . </li>

      <li>令 R 为包含了 -- 之前的 R 值中的字符们和后面跟着的 ToString(next) 结果的字符们 -- 的字符串值。</li>
    </ol>
  </li>

  <li>返回 R.</li>
</ol>

<p>concat 方法的 length 属性是 1.</p>

<p>注： concat 函数被有意设计成通用的；它不要求它的 this 值是字符串对象。因此，他可以当做方法转移到其他类型对象。</p>



<h6>String.prototype.indexOf (searchString, position)</h6>

<p>将 this 对象转换为一个字符串，如果 searchString 在这个字符串里大于或等于 position 的位置中的一个或多个位置使它呈现为字符串的子串，那么返回这些位置中最小的索引；否则返回 -1。如果 position 是 undefined，就认为它是 0，以搜索整个字符串。</p>

<p>indexOf 需要两个参数 searchString 和 position，执行以下步骤：</p>

<ol>
  <li>以 this 值作为参数调用 CheckObjectCoercible。 </li>

  <li>令 S 为以 this 值作为参数调用 ToString 的结果 . </li>

  <li>令 searchStr 为 ToString(searchString). </li>

  <li>令 pos 为 ToInteger(position). ( 如果 position 是 undefined, 此步骤产生 0). </li>

  <li>令 len 为 S 的字符数 . </li>

  <li>令 start 为 min(max(pos, 0), len). </li>

  <li>令 searchLen 为 SearchStr 的字符数 . </li>

  <li>返回 一个不小于 start 的可能的最小值整数 k，使得 k+searchLen 不大于 len，并且对所有小于 searchLen 的非负数整数 j，S 的 k+j 位置字符和 searchStr 的 j 位置字符相同；但如果没有这样的整数 k，则返回 -1。</li>
</ol>

<p>indexOf 的 length 属性是 1。</p>

<p>注： indexOf 函数被有意设计成通用的；它不要求它的 this 值是字符串对象。因此，他可以当做方法转移到其他类型对象。</p>



<h6>String.prototype.lastIndexOf (searchString, position)</h6>

<p>将 this 对象转换为一个字符串，如果 searchString 在这个字符串里小于或等于 position 的位置中的一个或多个位置使它呈现为字符串的子串，那么返回这些位置中最大的索引；否则返回 -1。如果 position 是 undefined，就认为它是字符串值的长度，以搜索整个字符串。</p>

<p>lastIndexOf 需要两个参数 searchString 和 position，执行以下步骤：</p>

<ol>
  <li>以 this 值作为参数调用 CheckObjectCoercible。 </li>

  <li>令 S 为以 this 值作为参数调用 ToString 的结果 . </li>

  <li>令 searchStr 为 ToString(searchString). </li>

  <li>令 numPos 为 Tonumber(position). ( 如果 position 是 undefined, 此步骤产生 NaN). </li>

  <li>如果 numPos 是 NaN, 令 pos 为 +∞; 否则 , 令 pos 为 ToInteger(numPos). </li>

  <li>令 len 为 S 的字符数 . </li>

  <li>令 start 为 min(max(pos, 0), len). </li>

  <li>令 searchLen 为 SearchStr 的字符数 . </li>

  <li>返回 一个不大于 start 的可能的最大值整数 k，使得 k+searchLen 不大于 len，并且对所有小于 searchLen 的非负数整数 j，S 的 k+j 位置字符和 searchStr 的 j 位置字符相同；但如果没有这样的整数 k，则返回 -1。</li>
</ol>

<p>lastIndexOf 的 length 属性是 1。</p>

<p>注： lastIndexOf 函数被有意设计成通用的；它不要求它的 this 值是字符串对象。因此，他可以当做方法转移到其他类型对象。</p>



<h6>String.prototype.localeCompare (that)</h6>

<p>当以一个参数 that 来调用 localeCompare 方法，它返回一个非 NaN 数字值，这个数字值反应了对 this 值（转换为字符串）和 that 值（转换为字符串）进行语言环境敏感的字符串比较的结果。两个字符串 S 和 That 用实现定义的一种方式进行比较。比较结果是为了按照系统默认语言环境指定的排列顺序来排列字符串，根据按照排列顺序 S 是在 That 前面，相同，还是 S 在 That 后面，结果分别是负数，零，正数。</p>

<p>在执行比较之前执行以下步骤以预备好字符串：</p>

<ol>
  <li>以 this 值作为参数调用 CheckObjectCoercible。 </li>

  <li>令 S 为以 this 值作为参数调用 ToString 的结果 . </li>

  <li>令 That 为 ToString(that).</li>
</ol>

<p>如果将 localeCompare 方法看做是将 this 和 that 作为两个参数的函数，那么它是在所有字符串集合上的保持一致的比较函数（在 15.4.4.11 定义）。</p>

<p>实际返回值是实现定义的，允许实现者们在返回值里编码附加信息。但是函数需要定义一个在所有字符串上的总的顺序，并且，当比较的字符串们被认为是 Unicode 标准定义的标准等价，则返回 0。</p>

<p>如果宿主环境没有在所有字符串上语言敏感的比较，此函数可执行按位比较。</p>

<p>注：1. localeCompare 方法自身不适合直接作为 Array.prototype.sort 的参数，因为后者需要的是两个参数的函数。</p>

<p>注：2. 这个函数的目的是在宿主环境中任何依靠语言敏感的比较方式都可用于 ECMAScript 环境，并根据宿主环境当前语言环境设置的规则进行比较。强烈建议这个函数将 -- 根据 Unicode 标准的标准等价的 -- 字符串当做是相同的（也就是说，要比较的字符串仿佛是都先被转换为正常化形式 C 或正常化形式 D 了）。还建议这个函数不履行 Unicode 相容等价或分解。</p>

<p>注：3. 本标准的未来版本可能会使用这个函数的第二个参数；建议实现不将这个参数位用作其他用途。</p>

<p>注：4. localeCompare 函数被有意设计成通用的；它不要求它的 this 值是字符串对象。因此，他可以当做方法转移到其他类型对象。</p>



<h6>String.prototype.match (regexp)</h6>

<p>当以 regexp 作为参数调用 match 方法，采用以下步骤：</p>

<ol>
  <li>以 this 值作为参数调用 CheckObjectCoercible。 </li>

  <li>令 S 为以 this 值作为参数调用 ToString 的结果 . </li>

  <li>如果 Type(regexp) 是 Object 并且 regexp 的 [[Class]] 内部属性的值是 &quot;RegExp&quot;, 则令 rx 为 regexp; </li>

  <li>否则 , 令 rx 为 仿佛是用表达式 new RegExp( regexp) 创建的新正则对象，这里的 RegExp 是标准内置构造器名。 </li>

  <li>令 global 为 以 &quot;global&quot; 为参数调用 rx 的 [[Get]] 内部方法的结果 . </li>

  <li>令 exec 为 标准内置函数 RegExp.prototype.exec ( 见 15.10.6.2) </li>

  <li>如果 global 不是 true, 则 
    <ol>
      <li>以 rx 作为 this 值，用包含 S 的参数列表调用 exec 的 [[Call]] 内部方法，返回结果。</li>
    </ol>
  </li>

  <li>否则 , global 是 true 
    <ol>
      <li>以 &quot;lastIndex&quot; 和 0 作为参数调用 rx 的 [[Put]] 内部方法。 </li>

      <li>令 A 为 仿佛是用表达式 new Array() 创建的新数组，这里的 Array 是标准内置构造器名 . </li>

      <li>令 previousLastIndex 为 0. </li>

      <li>令 n 为 0. </li>

      <li>令 lastMatch 为 true. </li>

      <li>只要 lastMatch 是 true，就重复 
        <ol>
          <li>令 result 为 以 rx 作为 this 值，用包含 S 的参数列表调用 exec 的 [[Call]] 内部方法的结果。 </li>

          <li>如果 result 是 null, 则设定 lastMatch 为 false. </li>

          <li>否则 , result 不是 null 
            <ol>
              <li>令 thisIndex 为 以 &quot;lastIndex&quot; 为参数调用 rx 的 [[Get]] 内部方法的结果。 </li>

              <li>如果 thisIndex = previousLastIndex 则 
                <ol>
                  <li>以 &quot;lastIndex&quot; 和 thisIndex+1 为参数调用 rx 的 [[Put]] 内部方法。 </li>

                  <li>设定 previousLastIndex 为 thisIndex+1.</li>
                </ol>
              </li>

              <li>否则 , 设定 previousLastIndex 为 thisIndex. </li>

              <li>令 matchStr 为 以 0 为参数调用 result 的 [[Get]] 内部方法的结果。 </li>

              <li>以 ToString(n), 属性描述符 {[[Value]]: matchStr, [[Writable]]: true, [[Enumerable]]: true, [[configurable]]: true}, 和 false 作为参数调用 A 的 [[DefineOwnProperty]] 内部方法。 </li>

              <li>n 递增 1.</li>
            </ol>
          </li>
        </ol>
      </li>

      <li>如果 n = 0, 则返回 null. </li>

      <li>返回 A.</li>
    </ol>
  </li>
</ol>

<p>注： match 函数被有意设计成通用的；它不要求它的 this 值是字符串对象。因此，他可以当做方法转移到其他类型对象。</p>



<h6>String.prototype.replace (searchValue, replaceValue)</h6>

<p>首先根据以下步骤设定 string：</p>

<ol>
  <li>以 this 值作为参数调用 CheckObjectCoercible。 </li>

  <li>令 string 为 以 this 值作为为参数调用 ToString 的结果。</li>
</ol>

<p>如果 searchValue 是一个正则表达式（[[Class]] 内部属性是 &quot;RegExp&quot; 的对象），按照如下执行：如果 searchValue.global 是 false，则搜索 string，找出匹配正则表达式 searchValue 的第一个子字符串。如果 searchValue.global 是 true，则搜索 string，找出匹配正则表达式 searchValue 的所有子字符串。搜索的做法与 String.prototype.match 相同，包括对 searchValue.lastIndex 的更新。令 m 为 searchValue 的左捕获括号的个数（使用 15.10.2.1 指定的 NcapturingParens）。</p>

<p>如果 searchValue 不是正则表达式，令 searchString 为 ToString(searchValue)，并搜索 string，找出第一个出现的 searchString 的子字符串。令 m 为 0。</p>

<p>如果 replaceValue 是函数，则对每个匹配的子字符串，以 m + 3 个参数调用这个函数。第一个参数是匹配的子字符串。如果 searchValue 是正则表达式，接下来 m 个参数是 MatchResult（见 15.10.2.1）里的所有捕获值。第 m + 2 个参数是发生的匹配在 string 里的偏移量，第 m + 3 个参数是 string。结果是将输入的原字符串里的每个匹配子字符串替换为相应函数调用的返回值（必要的情况下转换为字符串）得到的字符串。</p>

<p>否则，令 newstring 表示 replaceValue 转换为字符串的结果。结果是将输入的原字符串里的每个匹配子字符串替换为 -- 将 newstring 里的字符替换为表 22 指定的替代文本得到的字符串 -- 得到的字符串。替换这些 $ 是由左到右进行的，并且一旦执行了这样的替换，新替换的文本不受进一步替换。例如 ，&quot;$1,$2&quot;.replace(/(\$(\d))/g, &quot;$$1-$1$2&quot;) 返回 &quot;$1-$11,$1-$22&quot;。newstring 里的一个 $ ，如果不符合以下任何格式，就保持原状。</p>
<div>
<p>表 22 — 替代文本符号替换</p>

<p>字符
  <br />替代文本</p>

<p>$$
  <br />$</p>

<p>$&amp;
  <br />匹配到的子字符串</p>

<p>$`( 译注：'\u0060')
  <br />string 中匹配到的子字符串之前部分。</p>

<p>$'( 译注：'\u0027')
  <br />string 中匹配到的子字符串之后部分。</p>

<p>$n
  <br />第 n 个捕获结果，n 是范围在 1 到 9 的单个数字，并且紧接着 $n 后面的不是十进制数字。如果 n≤m 且第 n 个捕获结果是 undefined，就用空字符串代替。如果 n&gt;m，结果是实现定义的。</p>

<p>$nn
  <br />第 nn 个捕获结果，nn 是范围在 01 到 99 的十进制两位数。如果 nn≤m 且第 nn 个捕获结果是 undefined，就用空字符串代替。如果 nn&gt;m，结果是实现定义的。</p>
</div>
<p>注： replace 函数被有意设计成通用的；它不要求它的 this 值是字符串对象。因此，他可以当做方法转移到其他类型对象。</p>



<h6>String.prototype.search (regexp)</h6>

<p>当用参数 regexp 调用 search 方法，采用以下步骤：</p>

<ol>
  <li>以 this 值作为参数调用 CheckObjectCoercible。 </li>

  <li>令 string 为 以 this 值作为参数调用 ToString 的结果。 </li>

  <li>如果 Type(regexp) 是 Object 且 regexp 的 [[Class]] 内部属性的值是 &quot;RegExp&quot;, 则令 rx 为 regexp; </li>

  <li>否则 , 令 rx 为仿佛是用表达式 new RegExp( regexp) 创建的新正则对象，这里的 RegExp 是标准内置构造器名。 </li>

  <li>从 string 开始位置搜索正则表达式模式 rx 的匹配。如果找到匹配，令 result 为匹配在 string 里的偏移量；如果没有找到匹配，令 result 为 -1。执行搜索时 regexp 的 lastIndex 和 global 属性是被忽略的。regexp 的 lastIndex 属性保持不变。 </li>

  <li>返回 result.</li>
</ol>

<p>注： search 函数被有意设计成通用的；它不要求它的 this 值是字符串对象。因此，他可以当做方法转移到其他类型对象。</p>



<h6>String.prototype.slice (start, end)</h6>

<p>slice 方法需要两个参数 start 和 end，将 this 对象转换为一个字符串，返回这个字符串中从 start 位置的字符到（但不包含）end 位置的字符的一个子字符串（或如果 end 是 undefined，就直接到字符串尾部）。用 sourceLength 表示字符串长度，如果 start 是负数，就把它看做是 sourceLength+start；如果 end 是负数，就把它看做是 sourceLength+end。返回结果是一个字符串值，不是字符串对象。采用以下步骤：</p>

<ol>
  <li>以 this 值作为参数调用 CheckObjectCoercible。 </li>

  <li>令 S 为以 this 值作为参数调用 ToString 的结果 . </li>

  <li>令 len 为 S 的字符数 . </li>

  <li>令 intStart 为 ToInteger(start). </li>

  <li>如果 end 是 undefined, 令 intEnd 为 len; 否则 令 intEnd 为 ToInteger(end). </li>

  <li>如果 intStart 是 negative, 令 from 为 max(len + intStart,0); 否则 令 from 为 min(intStart,len). </li>

  <li>如果 intEnd 是 negative, 令 to 为 max(len +intEnd,0); 否则 令 to 为 min(intEnd, len). </li>

  <li>令 span 为 max(to – from,0). </li>

  <li>返回 一个包含 --S 中从 form 位置的字符开始的 span 个连续字符 -- 的字符串。</li>
</ol>

<p>slice 方法的 length 属性是 2。</p>

<p>注： slice 函数被有意设计成通用的；它不要求它的 this 值是字符串对象。因此，他可以当做方法转移到其他类型对象。</p>



<h6>String.prototype.split (separator, limit)</h6>

<p>将 this 字符串转换为一个字符串，返回一个数组对象，里面存储了这个字符串的子字符串。子字符串是从左到右搜索 separator 的匹配来确定的；这些匹配结果不成为返回数组的任何子字符串元素，但被用来分割字符串。separator 的值可以是一个任意长度的字符串，也可以是一个正则对象（即，一个 [[Class]] 内部属性为 &quot;RegExp&quot; 的对象；见 15.10）。</p>

<p>separator 值可以是一个空字符串，一个空正则表达式，或一个可匹配空字符串的正则表达式。这种情况下，separator 不匹配输入字符串开头和末尾的空的子串，也不匹配分隔符的之前匹配结果末尾的空字串。（例如，如果 separator 是空字符串，要将字符串分割为单个字符们；结果数组的长度等于字符串长度，且每个字串都包含一个字符。）如果 separator 是正则表达式，在 this 字符串的给定位置中只考虑首次匹配结果，即使如果在这个位置上回溯可产生一个非空的子串。（例如，&quot;ab&quot;.split(/a*?/) 的执行结果是数组 [&quot;a&quot;,&quot;b&quot;]，而 &quot;ab&quot;.split(/a*/) 的执行结果是数组 [&quot;&quot;,&quot;b&quot;] 。）</p>

<p>如果 this 对象是（或转换成）空字符串，返回的结果取决于 separator 是否可匹配空字符串。如果可以，结果是不包含任何元素的数组。否则，结果是包含一个空字符串元素的数组。</p>

<p>如果 separator 是包含捕获括号的正则表达式，则对 separator 的每次匹配，捕获括号的结果 ( 包括 undefined) 都拼接为输出数组。例如，</p>

<pre> &quot;A&lt;B&gt;bold&lt;/B&gt;and&lt;CODE&gt;coded&lt;/CODE&gt;&quot;.split(/&lt;(\/)?([^&lt;&gt;]+)&gt;/)</pre>

<p>执行结果是数组：</p>

<pre> [&quot;A&quot;, undefined, &quot;B&quot;, &quot;bold&quot;, &quot;/&quot;, &quot;B&quot;, &quot;and&quot;, undefined,
 &quot;CODE&quot;, &quot;coded&quot;, &quot;/&quot;, &quot;CODE&quot;, &quot;&quot;]</pre>

<p>如果 separator 是 undefined，则返回结果是只包含 this 值（转换为字符串）一个字符串元素的数组。如果 limit 不是 undefined，则输出数组被切断为包含不大于 limit 个元素。</p>

<p>当调用 split 方法，采用以下步骤：</p>

<ol>
  <li>以 this 值作为参数调用 CheckObjectCoercible。 </li>

  <li>令 S 为以 this 值作为参数调用 ToString 的结果 . </li>

  <li>令 A 为 仿佛使用表达式 new Array() 创建的新对象，这里的 Array 是标准内置构造器名 . </li>

  <li>令 lengthA 为 0. </li>

  <li>如果 limit 是 undefined, 令 lim = 2<sup>32</sup>–1; 否则 令 lim = ToUint32(limit). </li>

  <li>令 s 为 S 的字符数 . </li>

  <li>令 p = 0. </li>

  <li>如果 separator 是正则对象 ( 它的 [[Class]] 是 &quot;RegExp&quot;), 令 R = separator; 否则，令 R = ToString(separator). </li>

  <li>如果 lim = 0, 返回 A. </li>

  <li>如果 separator 是 undefined, 则 
    <ol>
      <li>以 &quot;0&quot;, 属性描述符 {[[Value]]: S, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, 和 false 作为参数调用 A 的 [[DefineOwnProperty]] 内部方法。 </li>

      <li>返回 A.</li>
    </ol>
  </li>

  <li>如果 s = 0, 则 
    <ol>
      <li>调用 SplitMatch(S, 0, R) 并 令 z 为 它的 MatchResult 结果 . </li>

      <li>如果 z 不是 failure, 返回 A. </li>

      <li>以 &quot;0&quot;, 属性描述符 {[[Value]]: S, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, 和 false 作为参数调用 A 的 [[DefineOwnProperty]] 内部方法。 </li>

      <li>返回 A.</li>
    </ol>
  </li>

  <li>令 q = p. </li>

  <li>只要 q ≠ s，就重复 
    <ol>
      <li>调用 SplitMatch(S, q, R) 并 令 z 为 它的 MatchResult 结果 . </li>

      <li>如果 z 是 failure, 则 令 q = q+1. </li>

      <li>否则 , z 不是 failure 
        <ol>
          <li>z 必定是一个 State. 令 e 为 z 的 endIndex 并 令 cap 为 z 的 captures 数组 . </li>

          <li>如果 e = p, 则 令 q = q+1. </li>

          <li>否则 , e ≠ p 
            <ol>
              <li>令 T 为一个字符串，它的值等于包含 -- 在 S 中从 p（包括它）位置到 q（不包括）位置的字符 -- 的子字符串的值。 </li>

              <li>以 ToString(lengthA), 属性描述符 {[[Value]]: T, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, 和 false 作为参数调用 A 的 [[DefineOwnProperty]] 内部方法 . </li>

              <li>lengthA 递增 1. </li>

              <li>如果 lengthA = lim, 返回 A. </li>

              <li>令 p = e. </li>

              <li>令 i = 0. </li>

              <li>只要 i 不等于 cap 中的元素个数，就重复 . 
                <ol>
                  <li>令 i = i+1. </li>

                  <li>以 ToString(lengthA), 属性描述符 {[[Value]]: cap[i], [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, 和 false 作为参数调用 A 的 [[DefineOwnProperty]] 内部方法。 </li>

                  <li>lengthA 递增 1. </li>

                  <li>如果 lengthA = lim, 返回 A.</li>
                </ol>
              </li>

              <li>令 q = p.</li>
            </ol>
          </li>
        </ol>
      </li>
    </ol>
  </li>

  <li>令 T 为 为一个字符串，它的值等于包含 -- 在 S 中从 p（包括它）位置到 q（不包括）位置的字符 -- 的子字符串的值。 </li>

  <li>以 ToString(lengthA), 属性描述符 {[[Value]]: T, [[Writable]]: true, [[Enumerable]]: true, [[Configurable]]: true}, 和 false 作为参数调用 A 的 [[DefineOwnProperty]] 内部方法。 </li>

  <li>返回 A.</li>
</ol>

<p>SplitMatch 抽象操作需要三个参数，字符串 S，整数 q，字符串或正则对象 R，按照以下顺序执行并返回一个 MatchResult（见 15.10.2.1）：</p>

<ol>
  <li>如果 R 是个正则对象 ( 它的 [[Class]] 是 &quot;RegExp&quot;), 则 
    <ol>
      <li>以 S 和 q 作为参数调用 R 的 [[Match]] 内部方法，并返回 MatchResult 的结果。</li>
    </ol>
  </li>

  <li>否则，Type(R) 必定是 String. 令 r 为 R 的字符数 . </li>

  <li>令 s 为 S 的字符数 . </li>

  <li>如果 q+r &gt; s 则返回 MatchResult failure. </li>

  <li>如果存在一个在 0（包括）到 r（不包括）之间的整数 i，使得 S 的 q+i 位置上的字符和 R 的 i 位置上的字符不同，则返回 failure。 </li>

  <li>令 cap 为 captures 的空数组 ( 见 15.10.2.1). </li>

  <li>返回 State 数据结构 (q+r, cap). ( 见 15.10.2.1)</li>
</ol>

<p>split 方法的 length 属性是 2.</p>

<p>注：1. 分隔符是正则对象时，split 方法忽略 separator.global 的值。</p>

<p>注：2. split 函数被有意设计成通用的；它不要求它的 this 值是字符串对象。因此，他可以当做方法转移到其他类型对象。</p>



<h6>String.prototype.substring (start, end)</h6>

<p>substring 方法需要两个参数 start 和 end，将 this 对象转换为一个字符串，返回包含 -- 在转换结果字符串中从 start 位置字符一直到（但不包括）end 位置的字符（或如果 end 是 undefined，就到字符串末尾）-- 的一个子串。返回结果是字符串值，不是字符串对象。</p>

<p>如果任一参数是 NaN 或负数，它被零取代；如果任一参数大于字符串长度，它被字符串长度取代。</p>

<p>如果 start 大于 end，交换它们的值。</p>

<p>采用以下步骤：</p>

<ol>
  <li>以 this 值作为参数调用 CheckObjectCoercible。 </li>

  <li>令 S 为以 this 值作为参数调用 ToString 的结果 . </li>

  <li>令 len 为 S 的字符数 . </li>

  <li>令 intStart 为 ToInteger(start). </li>

  <li>如果 end 是 undefined, 令 intEnd 为 len; 否则 令 intEnd 为 ToInteger(end). </li>

  <li>令 finalStart 为 min(max(intStart, 0), len). </li>

  <li>令 finalEnd 为 min(max(intEnd, 0), len). </li>

  <li>令 from 为 min(finalStart, finalEnd). </li>

  <li>令 to 为 max(finalStart, finalEnd). </li>

  <li>返回 一个长度是 to - from 的字符串，它包含 S 中从索引值 form 到 to-1（按照索引升序）的所有字符。</li>
</ol>

<p>substring 方法的 length 属性是 2。</p>

<p>注： substring 函数被有意设计成通用的；它不要求它的 this 值是字符串对象。因此，他可以当做方法转移到其他类型对象。</p>



<h6>String.prototype.toLowerCase ( )</h6>

<p>采用以下步骤：</p>

<ol>
  <li>以 this 值作为参数调用 CheckObjectCoercible。 </li>

  <li>令 S 为以 this 值作为参数调用 ToString 的结果 . </li>

  <li>令 L 为一个字符串，L 的每个字符是 S 中相应字符的 Unicode 小写等量，或者（如果没有 Unicode 小写等量存在）是实际的 S 中相应字符值。 </li>

  <li>返回 L.</li>
</ol>

<p>为了此操作，字符串的 16 位代码单元被看作是 Unicode 基本多文种平面（Basic Multilingual Plane）中的代码点。代理代码点直接从 S 转移到 L，不做任何映射。</p>

<p>返回结果必须是根据 Unicode 字符数据库里的大小写映射得到的（对此数据库明确规定，不仅包括 UnicodeData.txt 文件，而且还包括 Unicode 2.1.8 和更高版本里附带的 SpecialCasings.txt 文件）。</p>

<p>注： 1. 某些字符的大小写映射可产生多个字符。这种情况下结果字符串与原字符串的长度未必相等。因为 toUpperCase 和 toLowerCase 都有上下文敏感的行为，所以这俩函数不是对称的。也就是说，s.toUpperCase().toLowerCase() 不一定等于 s.toLowerCase()。</p>

<p>注： 2. toLowerCase 函数被有意设计成通用的；它不要求它的 this 值是字符串对象。因此，他可以当做方法转移到其他类型对象。</p>



<h6>String.prototype.toLocaleLowerCase ( )</h6>

<p>此函数产生依照 -- 宿主环境的当前语言设置 -- 更正的结果，而不是独立于语言环境的结果，除此之外它的运作方式与 toLowerCase 完全一样。只有在少数情况下有一个区别（如，土耳其语），就是那个语言和正规 Unicode 大小写映射有冲突时的规则。</p>

<p>注： 1. 此函数的第一个参数可能会用于本标准的未来版本 ; 建议实现不以任何用途使用这个参数位置。</p>

<p>注： 2. toLocaleLowerCase 函数被有意设计成通用的；它不要求它的 this 值是字符串对象。因此，他可以当做方法转移到其他类型对象。</p>



<h6>String.prototype.toUpperCase ( )</h6>

<p>此函数的将字符映射到在 Unicode 字符数据库中与其等值的大写字符，除此之外此函数的行为采用与 String.prototype.toLowerCase 完全相同的方式。</p>

<p>注： toUpperCase 函数被有意设计成通用的；它不要求它的 this 值是字符串对象。因此，他可以当做方法转移到其他类型对象。</p>



<h6>String.prototype.toLocaleUpperCase ( )</h6>

<p>此函数产生依照 -- 宿主环境的当前语言设置 -- 更正的结果，而不是独立于语言环境的结果，除此之外它的运作方式与 toUpperCase 完全一样。只有在少数情况下有一个区别（如，土耳其语），就是那个语言和正规 Unicode 大小写映射有冲突时的规则。</p>

<p>注： 1. 此函数的第一个参数可能会用于本标准的未来版本 ; 建议实现不以任何用途使用这个参数位置。</p>

<p>注： 2. toLocaleUpperCase 函数被有意设计成通用的；它不要求它的 this 值是字符串对象。因此，他可以当做方法转移到其他类型对象。</p>



<h6>String.prototype.trim ( )</h6>

<p>采用以下步骤：</p>

<ol>
  <li>以 this 值作为参数调用 CheckObjectCoercible。 </li>

  <li>令 S 为以 this 值作为参数调用 ToString 的结果 . </li>

  <li>令 T 为一个字符串值，它是 S 的一个拷贝，并删除了开头和结尾中空白的。空白的定义是 WhiteSpace 和 LineTerminato r 的并集。 </li>

  <li>返回 T.</li>
</ol>

<p>注： trim 函数被有意设计成通用的；它不要求它的 this 值是字符串对象。因此，他可以当做方法转移到其他类型对象。</p>



<h5>String 实例的属性</h5>

<p>字符串实例从字符串原型对象继承属性，字符串实例的 [[Class]] 内部属性值是 &quot;String&quot;。字符串实例还有 [[PrimitiveValue]] 内部属性，length 属性，和一组属性名是数组索引的可遍历属性。</p>

<p>[[PrimitiveValue]] 内部属性是代表这个字符串对象的字符串值。以数组索引命名的属性对应字符串值里的单字符。一个特殊的 [[GetOwnProperty]] 内部方法用来为数组索引命名的属性指定数字，值，和特性。</p>



<h6>length</h6>

<p>在代表这个字符串对象的字符串值里的字符数。</p>

<p>一旦创建了一个字符串对象，这个属性是不可变的。它有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。</p>



<h6>[[GetOwnProperty]] ( P )</h6>

<p>数组对象使用一个，用在其他原生 ECMAscript 对象的 [[GetOwnProperty]] 内部方法 (8.12.1) 的变化版。这个特殊内部方法用来给命名属性添加访问器，对应到字符串对象的单字符。</p>

<p>设 S 为一个字符串对象，P 为一个字符串。</p>

<p>当以属性名 P 调用 S 的 [[GetOwnProperty]] 内部方法，采用以下步骤：</p>

<ol>
  <li>令 desc 为 以 P 为参数调用 S 的默认 [[GetOwnProperty]] 内部方法 (8.12.1) 的结果。 </li>

  <li>如果 desc 不是 undefined，返回 desc. </li>

  <li>如果 ToString(abs(ToInteger(P))) 与 P 的值不同 , 返回 undefined. </li>

  <li>令 str 为 S 的 [[PrimitiveValue]] 内部属性字符串值。 </li>

  <li>令 index 为 ToInteger(P). </li>

  <li>令 len 为 str 里的字符数 . </li>

  <li>如果 len ≤ index, 返回 undefined. </li>

  <li>令 resultStr 为一个长度为 1 的字符串 , 里面包含 str 中 index 位置的一个字符 , 在这里 str 中的第一个（最左边）字符被认为是在位置 0，下一个字符在位置 1，依此类推。 </li>

  <li>返回一个属性描述符 { [[Value]]: resultStr, [[Enumerable]]: true, [[Writable]]: false, [[Configurable]]: false }</li>
</ol>


<h4>布尔对象</h4>


<h5>作为函数调用布尔构造器</h5>

<p>当把 Boolean 作为函数来调用，而不是作为构造器，它执行一个类型转换。</p>



<h6>Boolean (value)</h6>

<p>返回由 ToBoolean(value) 计算出的布尔值（非布尔对象）。</p>



<h5>布尔构造器</h5>

<p>当 Boolean 作为 new 表达式的一部分来调用，那么它是一个构造器：它初始化新创建的对象。</p>



<h6>new Boolean (value)</h6>

<p>新构造对象的 [[Prototype]] 内部属性设定为原始布尔原型对象，它是 Boolean.prototype (15.6.3.1) 的初始值。</p>

<p>新构造对象的 [[Class]] 内部属性设定为 &quot;Boolean&quot;。</p>

<p>新构造对象的 [[PrimitiveValue]] 内部属性设定为 ToBoolean(value)。</p>

<p>新构造对象的 [[Extensible]] 内部属性设定为 true。</p>



<h5>布尔构造器的属性</h5>

<p>布尔构造器的 [[Prototype]] 内部属性的值是函数原型对象 (15.3.4)。</p>

<p>除了内部属性和 length 属性（值为 1）外，布尔构造器还有以下属性：</p>



<h6>Boolean.prototype</h6>

<p>Boolean.prototype 的初始值是布尔原型对象 (15.6.4)。</p>

<p>这个属性有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。</p>



<h5>布尔原型对象的属性</h5>

<p>布尔原型对象自身是一个值为 false 的布尔对象（它的 [[Class]] 是 &quot;Boolean&quot;）。</p>

<p>布尔原型对象的 [[Prototype]] 内部属性值是标准内置的对象原型对象（15.2.4）。</p>



<h6>Boolean.prototype.constructor</h6>

<p>Boolean.prototype.constructor 的初始值是内置的 Boolean 构造器。</p>



<h6>Boolean.prototype.toString ( )</h6>

<p>采用以下步骤：</p>

<ol>
  <li>令 B 为 this 值 . </li>

  <li>如果 Type(B) 是 Boolean, 则令 b 为 B. </li>

  <li>否则如果 Type(B) 是 Object 且 B 的 [[Class]] 内部属性值是 &quot;Boolean&quot;, 则令 b 为 B 的 [[PrimitiveValue]] 内部属性值。 </li>

  <li>否则抛出一个 TypeError 异常 . </li>

  <li>如果 b 是 true, 则返回 &quot;true&quot;; 否则返回 &quot;false&quot;.</li>
</ol>


<h6>Boolean.prototype.valueOf ( )</h6>

<p>采用以下步骤：</p>

<ol>
  <li>令 B 为 this 值 . </li>

  <li>如果 Type(B) 是 Boolean, 则令 b 为 B. </li>

  <li>否则如果 Type(B) 是 Object 且 B 的 [[Class]] 内部属性值是 &quot;Boolean&quot;, 则令 b 为 B 的 [[PrimitiveValue]] 内部属性值。 </li>

  <li>否则抛出一个 TypeError 异常 . </li>

  <li>返回 b.</li>
</ol>


<h5>布尔实例的属性</h5>

<p>布尔实例从布尔原型对象继承属性，且布尔实例的 [[Class]] 内部属性值是 &quot;Boolean&quot;。布尔实例还有一个 [[PrimitiveValue]] 内部属性。</p>

<p>[[PrimitiveValue]] 内部属性是代表这个布尔对象的布尔值。</p>



<h4>Number 对象</h4>


<h5>作为函数调用的 Number 构造器</h5>

<p>当把 Number 当作一个函数来调用，而不是作为构造器，它执行一个类型转换。</p>



<h6>Number ( [ value ] )</h6>

<p>如果提供了 value，返回 ToNumber(value) 计算出的数字值（非 Number 对象），否则返回 +0。</p>



<h5>Number 构造器</h5>

<p>当把 Number 作为 new 表达式的一部分来调用，它是构造器：它初始化新创建的对象。</p>



<h6>new Number ( [ value ] )</h6>

<p>新构造对象的 [[Prototype]] 内部属性设定为原始数字原型对象，它是 Number.prototype 的初始值（15.7.3.1）。</p>

<p>新构造对象的 [[Class]] 内部属性设定为 &quot;Number&quot;。</p>

<p>新构造对象的 [[PrimitiveValue]] 内部属性在提供了 value 时设定为 ToNumber(value)，否则设定为 +0。</p>

<p>新构造对象的 [[Extensible]] 内部属性设定为 true。</p>



<h5>Number 构造器的属性</h5>

<p>Number 构造器的 [[Prototype]] 内部属性值是函数原型对象 (15.3.4)。</p>

<p>除了内部属性和 length 属性（值为 1）之外，Number 构造器还有以下属性：</p>



<h6>Number.prototype</h6>

<p>Number.prototype 的初始值是数字原型对象。</p>

<p>这个属性有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。</p>



<h6>Number.MAX_VALUE</h6>

<p>Number.MAX_VALUE 的值是数字类型的最大正有限值，约为 1.7976931348623157 × 10<sup>308</sup>。</p>

<p>这个属性有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。</p>



<h6>Number.MIN_VALUE</h6>

<p>Number.MIN_VALUE 的值是数字类型的最小正有限值，约为 5 × 10<sup>-324</sup>。</p>

<p>这个属性有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。</p>



<h6>Number.NaN</h6>

<p>Number.NaN 的值是 NaN。</p>

<p>这个属性有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。</p>



<h6>Number.NEGATIVE_INFINITY</h6>

<p>Number.NEGATIVE_INFINITY 的值是−∞。</p>

<p>这个属性有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。</p>



<h6>Number.POSITIVE_INFINITY</h6>

<p>Number.POSITIVE_INFINITY 的值是 +∞。</p>

<p>这个属性有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。</p>



<h5>数字原型对象的属性</h5>

<p>数字原型对象其自身是 Number 对象（其 [[Class]] 是 &quot;Number&quot;），其值为 +0。</p>

<p>数字原型对象的 [[Prototype]] 内部属性值是标准内置 Object 原型对象 (15.2.4)。</p>

<p>除非另外明确声明，以下定义的数字原型对象的方法是非通用的，传递给它们的 this 值必须是数字值或 [[Class]] 内部属性值是 &quot;Number&quot; 的对象。</p>

<p>在以下对作为数字原型对象属性的函数的描述中，短语“this Number 对象”是指函数调用中的 this 值，或如果 Type(this 值 ) 是 Number，“this Number 对象”指仿佛是用表达式 new Number(this value) 创建的对象，这里 Number 是标准内置构造器名。此外，短语“this 数字值”是指代表 this Number 对象的数字值，也就是 this Number 对象的 [[PrimitiveValue]] 内部属性值；或如果 this 是数字类型，“this 数字值”指 this 值。如果 this 值不是 [[Class]] 内部属性为 &quot;Number&quot; 的对象，也不是数字类型的值，则抛出一个 TypeError 异常。</p>



<h6>Number.prototype.constructor</h6>

<p>Number.prototype.constructor 的初始值是内置 Number 构造器。</p>



<h6>Number.prototype.toString ( [ radix ] )</h6>

<p>可选参数 radix 应当是 2 到 36 闭区间上的整数。如果 radix 不存在或是 undefined，用数字 10 作为 radix 的值。如果 ToInteger(radix) 是数字 10，则将 this Number 对象作为一个参数传给 ToString 抽象操作；返回结果字符串值。</p>

<p>如果 ToInteger(radix) 不是在 2 到 36 闭区间上的整数，则抛出一个 RangeError 异常。如果 ToInteger(radix) 是 2 到 36 的整数，担不是 10，则结果是 this 数字值使用指定基数表示法的字符串。字母 a-z 用来指值为 10 到 35 的数字。基数不为 10 时的精确算法是依赖于实现的，然而算法应当是 9.8.1 指定算法的推广形式。</p>

<p>toString 函数不是通用的；如果 this 值不是数字或 Number 对象，抛出一个 TypeError 异常。因此它不能当作方法转移到其他类型对象上。</p>



<h6>Number.prototype.toLocaleString()</h6>

<p>根据宿主环境的当前语言环境惯例来格式化 this 数字值，生成代表这个值的字符串。此函数是依赖于实现的，允许但不鼓励它的返回值与 toString 相同。</p>

<p>注： 此函数的第一个参数可能会用于本标准的未来版本 ; 建议实现不以任何用途使用这个参数位置。</p>



<h6>Number.prototype.valueOf ( )</h6>

<p>返回 this 数字值。</p>

<p>valueOf 函数不是通用的；如果 this 值不是数字或 Number 对象，抛出一个 TypeError 异常。因此它不能当作方法转移到其他类型对象上。</p>



<h6>Number.prototype.toFixed (fractionDigits)</h6>

<p>返回一个包含了 -- 代表 this 数字值的留有小数点后 fractionDigits 个数字的十进制固定小数点记法 -- 的字符串。如果 fractionDigits 是 undefined，就认为是 0。具体来说，执行以下步骤：</p>

<ol>
  <li>令 f 为 ToInteger(fractionDigits). ( 如果 fractionDigits 是 undefined, 此步骤产生 0 值 ). </li>

  <li>如果 f &lt; 0 或 f &gt; 20, 抛出一个 RangeError 异常 . </li>

  <li>令 x 为 this 数字值 . </li>

  <li>如果 x 是 NaN, 返回字符串 &quot;NaN&quot;. </li>

  <li>令 s 为空字符串 . </li>

  <li>如果 x &lt; 0, 则 
    <ol>
      <li>令 s 为 &quot;-&quot;. </li>

      <li>令 x = –x.</li>
    </ol>
  </li>

  <li>如果 x ≥ 10<sup>21</sup>, 则 

    <ol>
      <li>令 m = ToString(x).</li>
    </ol>
  </li>

  <li>否则 , x &lt; 10<sup>21</sup>

    <ol>
      <li>令 n 为一个整数，让 n ÷ 10<sup>f</sup> – x 准确的数学值尽可能接近零。如果有两个这样 n 值，选择较大的 n。 </li>

      <li>如果 n = 0, 令 m 为字符串 &quot;0&quot;. 否则 , 令 m 为由 n 的十进制表示里的数组成的字符串（为了没有前导零）。 </li>

      <li>如果 f ≠ 0, 则 
        <ol>
          <li>令 k 为 m 里的字符数目 . </li>

          <li>如果 k ≤ f, 则 
            <ol>
              <li>令 z 为 f+1–k 个 ‘0’ 组成的字符串 . </li>

              <li>令 m 为 串联字符串 z 的 m 的结果 . </li>

              <li>令 k = f + 1.</li>
            </ol>
          </li>

          <li>令 a 为 m 的前 k–f 个字符，令 b 为其余 f 个字符。 </li>

          <li>令 m 为 串联三个字符串 a, &quot;.&quot;, 和 b 的结果。</li>
        </ol>
      </li>
    </ol>
  </li>

  <li>返回串联字符串 s 和 m 的结果。</li>
</ol>

<p>toFixed 方法的 length 属性是 1。</p>

<p>如果以多个参数调用 toFixed 方法，则行为是不确定的（见 15 章）。</p>

<p>实现是被允许在 fractionDigits 小于 0 或大于 20 时扩展 toFixed 的行为。在这种情况下，对这样的 fractionDigits 值 toFixed 将未必抛出 RangeError。</p>

<div><p>注： 对于某些值，toFixed 的输出可比 toString 的更精确，因为 toString 只打印区分相邻数字值的足够的有效数字。例如 , </p>

<p>(1000000000000000128).toString() 返回 &quot;1000000000000000100&quot;,</p>

<p>而 (1000000000000000128).toFixed(0) 返回 &quot;1000000000000000128&quot;.</p></div>



<h6>Number.prototype.toExponential (fractionDigits)</h6>

<p>返回一个代表 this 数字值的科学计数法的字符串，它的有效数字的小数点前有一个数字，有效数字的小数点后有 fractionDigits 个数字。如果 fractionDigits 是 undefined，包括指定唯一数字值需要的尽可能多的有效数字（就像 ToString，但在这里总是以科学计数法输出）。具体来说执行以下步骤：</p>

<ol>
  <li>令 x 为 this 数字值 . </li>

  <li>令 f 为 ToInteger(fractionDigits). </li>

  <li>如果 x 是 NaN, 返回字符串 &quot;NaN&quot;. </li>

  <li>令 s 为空字符串 . </li>

  <li>如果 x &lt; 0, 则 
    <ol>
      <li>令 s 为 &quot;-&quot;. </li>

      <li>令 x = –x.</li>
    </ol>
  </li>

  <li>如果 x = +∞, 则 
    <ol>
      <li>返回串联字符串 s 和 &quot;Infinity&quot; 的结果 .</li>
    </ol>
  </li>

  <li>如果 fractionDigits 不是 undefined 且 (f &lt; 0 或 f &gt; 20), 抛出一个 RangeError 异常 . </li>

  <li>如果 x = 0, 则 
    <ol>
      <li>令 f = 0. </li>

      <li>令 m 为包含 f+1 个‘0’的字符串。 </li>

      <li>令 e = 0.</li>
    </ol>
  </li>

  <li>否则 , x ≠ 0 
    <ol>
      <li>如果 fractionDigits 不是 undefined, 则 
        <ol>
          <li>令 e 和 n 为整数，使得满足 10<sup>f</sup> ≤ n &lt; 10<sup>f+1</sup> 且 n × 10<sup>e–f</sup> – x 的准确数学值尽可能接近零。如果 e 和 n 有两个这样的组合，选择使 n × 10<sup>e–f</sup> 更大的组合。</li>
        </ol>
      </li>

      <li>否则 , fractionDigits 是 undefined 
        <ol>
          <li>令 e, n, 和 f 为整数，使得满足 f ≥ 0, 10<sup>f</sup>≤ n &lt; 10<sup>f+1</sup>, n × 10<sup>e–f</sup> 的数字值是 x, 且 f 的值尽可能小。注：n 的十进制表示有 f+1 个数字，n 不能被 10 整除，并且 n 的最少有效位数不一定唯一由这些条件确定。</li>
        </ol>
      </li>

      <li>令 m 为由 n 的十进制表示里的数 组成的字符串（没有前导零）。</li>
    </ol>
  </li>

  <li>如果 f ≠ 0, 则 
    <ol>
      <li>令 a 为 m 中的第一个字符 , 令 b 为 m 中的其余字符 . </li>

      <li>令 m 为串联三个字符串 a, &quot;.&quot;, 的 b 的结果 .</li>
    </ol>
  </li>

  <li>如果 e = 0, 则 
    <ol>
      <li>令 c = &quot;+&quot;. </li>

      <li>令 d = &quot;0&quot;.</li>
    </ol>
  </li>

  <li>否则 
    <ol>
      <li>如果 e &gt; 0, 则 令 c = &quot;+&quot;. </li>

      <li>否则 , e ≤ 0 
        <ol>
          <li>令 c = &quot;-&quot;. </li>

          <li>令 e = –e.</li>
        </ol>
      </li>

      <li>令 d 为有 e 的十进制表示里的数 组成的字符串（没有前导零）。</li>
    </ol>
  </li>

  <li>令 m 为串联四个字符串 m, &quot;e&quot;, c, 和 d 的结果 . </li>

  <li>返回串联字符串 s 和 m 的结果 .</li>
</ol>

<p>toExponential 方法的 length 属性是 1。</p>

<p>如果用多于一个参数调用 toExponential 方法，则行为是未定义的 ( 见 15 章 )。</p>

<p>一个实现可以扩展 fractionDigits 的值小于 0 或大于 20 时 toExponential 的行为。这种情况下对这样的 fractionDigits 值，toExponential 不一定抛出 RangeError 异常 .</p>

<p>注： 对于需要提供比上述规则更准确转换的实现，建议用以下算法作为指引替代步骤 9.b.i ： </p>

<ol>
  <li>令 e, n, 和 f 为整数，使得满足 f ≥ 0, 10<sup>f</sup>≤ n &lt; 10<sup>f+1</sup>, n × 10<sup>e–f</sup> 的数字值是 x, 且 f 的值尽可能小。如果这样的 n 值可能多个，选择使 n × 10<sup>e–f</sup> 的值尽可能接近 x 的 n 值。如果有两个这样的 n 值，选择偶数。</li>
</ol>



<h6>Number.prototype.toPrecision (precision)</h6>

<p>返回一个字符串，它代表 this 数字值的科学计数法（有效数字的小数点前有一个数字，有效数字的小数点后有 precision-1 个数字）或十进制固定计数法（precision 个有效数字）。如果 precision 是 undefined，用 ToString (9.8.1) 调用代替。具体来说执行以下步骤：</p>

<ol>
  <li>令 x 为 this 数字值 . </li>

  <li>如果 precision 是 undefined, 返回 ToString(x). </li>

  <li>令 p 为 ToInteger(precision). </li>

  <li>如果 x 是 NaN, 返回字符串 &quot;NaN&quot;. </li>

  <li>令 s 为空字符串 . </li>

  <li>如果 x &lt; 0, 则 
    <ol>
      <li>令 s 为 &quot;-&quot;. </li>

      <li>令 x = –x.</li>
    </ol>
  </li>

  <li>如果 x = +∞, 则 
    <ol>
      <li>返回串联字符串 s 和 &quot;Infinity&quot; 的结果 .</li>
    </ol>
  </li>

  <li>如果 p &lt; 1 或 p &gt; 21, 抛出一个 RangeError 异常 . </li>

  <li>如果 x = 0, 则 
    <ol>
      <li>令 m 为 p 个 '0' 组成的字符串 . </li>

      <li>令 e = 0.</li>
    </ol>
  </li>

  <li>否则 x ≠ 0, 
    <ol>
      <li>令 e 和 n 为整数，使得满足 10<sup>p–1</sup> ≤ n &lt; 10<sup>p</sup> 且 n × 10<sup>e–p+1</sup> – x 的准确数学值尽可能接近零。如果 e 和 n 有两个这样的组合，选择使 n × 10<sup>e–p+1</sup> 更大的组合。 </li>

      <li>令 m 为由 n 的十进制表示里的数 组成的字符串（没有前导零）。 </li>

      <li>如果 e &lt; –6 或 e ≥ p, 则 
        <ol>
          <li>令 a 为 n 的第一个字符 , 令 b 为 m 的其余 p–1 个字符 . </li>

          <li>令 m 为串联三个字符串 a, &quot;.&quot;, 和 b 的结果 . </li>

          <li>如果 e = 0, 则 
            <ol>
              <li>令 c = &quot;+&quot; ，令 d = &quot;0&quot;.</li>
            </ol>
          </li>

          <li>否则 e ≠ 0, 
            <ol>
              <li>如果 e &gt; 0, 则 
                <ol>
                  <li>令 c = &quot;+&quot;.</li>
                </ol>
              </li>

              <li>否则 e &lt; 0, 
                <ol>
                  <li>令 c = &quot;-&quot;. </li>

                  <li>令 e = –e.</li>
                </ol>
              </li>

              <li>令 d 为由 e 的十进制表示里的数 组成的字符串（没有前导零）。</li>
            </ol>
          </li>

          <li>令 m 为串联五个字符串 s, m, &quot;e&quot;, c, 和 d 的结果 .</li>
        </ol>
      </li>
    </ol>
  </li>

  <li>如果 e = p–1, 则返回串联字符串 s 和 m 的结果 . </li>

  <li>如果 e ≥ 0, 则 
    <ol>
      <li>令 m 为 m 的前 e+1 个字符 , 字符‘.’, m 的其余 p– (e+1) 个字符 串联的结果 .</li>
    </ol>
  </li>

  <li>否则 e &lt; 0, 
    <ol>
      <li>令 m 为 字符串 &quot;0.&quot;, –(e+1) 个字符‘0’, 字符串 m 串联的结果 .</li>
    </ol>
  </li>

  <li>返回字符串 s 和 m 串联的结果 .</li>
</ol>

<p>toPrecision 方法的 length 属性是 1。</p>

<p>如果用多于一个参数调用 toPrecision 方法，则行为是未定义的 ( 见 15 章 )。</p>

<p>一个实现可以扩展 precision 的值小于 1 或大于 21 时 toPrecision 的行为。这种情况下对这样的 precision 值，toPrecision 不一定抛出 RangeError 异常 .</p>



<h5>数字实例的属性</h5>

<p>数字实例从数字原型对象继承属性，数字实例的 [[Class]] 内部属性是 &quot;Number&quot;。数字实例还有一个 [[PrimitiveValue]] 内部属性。</p>

<p>[[PrimitiveValue]] 内部属性是代表 this Number 对象的数字值。</p>



<h4>Math 对象</h4>

<p>Math 对象是拥有一些命名属性的单一对象，其中一些属性值是函数。</p>

<p>Math 对象的 [[Prototype]] 内部属性值是标准内置 Object 原型对象 (15.2.4)。Math 对象的 [[Class]] 内部属性值是 &quot;Math&quot;。</p>

<p>Math 对象没有 [[Construct]] 内部属性 ; Math 对象不能作为构造器被 new 运算符调用。</p>

<p>Math 对象没有 [[Call]] 内部属性；Math 对象不能作为函数被调用。</p>

<p>注： 本规范中，短语“x 的数字值”的技术含义定义在 8.5。</p>



<h5>Math 对象的值属性</h5>


<h6>E</h6>

<p>自然对数的底数 e 的数字值，约为 2.7182818284590452354。</p>

<p>此属性有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } 。</p>



<h6>LN10</h6>

<p>10 的自然对数的数字值，约为 2.302585092994046。</p>

<p>此属性有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } 。</p>



<h6>LN2</h6>

<p>2 的自然对数的数字值，约为 0.6931471805599453。</p>

<p>此属性有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } 。</p>



<h6>LOG2E</h6>

<p>自然对数的底数 e 的以 2 为底数的对数的数字值；约为 1.4426950408889634。</p>

<p>此属性有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } 。</p>

<p>注：Math.LOG2E 的值约为 Math.LN2 值的倒数。</p>



<h6>LOG10E</h6>

<p>自然对数的底数 e 的以 10 为底数的对数的数字值；约为 0.4342944819032518。</p>

<p>此属性有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } 。</p>

<p>注：Math.LOG10E 的值约为 Math.LN10 值的倒数。</p>



<h6>PI</h6>

<p>圆的周长与直径之比π的数字值，约为 3.1415926535897932。</p>

<p>此属性有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } 。</p>



<h6>SQRT1_2</h6>

<p>½ 的平方根的数字值，约为 0.7071067811865476。</p>

<p>此属性有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } 。</p>

<p>注：Math.SQRT1_2 的值约为 Math.SQRT2 值的倒数。</p>



<h6>SQRT2</h6>

<p>2 的平方根的数字值，约为 1.4142135623730951。</p>

<p>此属性有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false } 。</p>



<h5>Math 对象的函数属性</h5>

<p>对以下每个 Math 对象函数的每个参数（如果有多个，以左到右的顺序）应用 ToNumber 抽象操作，然后对结果数字值执行计算。</p>

<p>下面对函数的描述中，符号 NaN, −0, +0, −∞, +∞ 指 8.5 描述的数字值。</p>

<p>这里没有精确规定函数 acos, asin, atan, atan2, cos, exp, log, pow, sin, sqrt 的行为，除了需要特别说明对边界情况某些参数值的结果之外。对其他参数值，这些函数旨在计算计算常见数学函数的结果，但选择的近似算法中的某些范围是被允许的。The general intent is that an implementer should be able to use the same mathematical library for ECMAScript on a given hardware platform that is available to C programmers on that platform.</p>

<p>Although the choice of algorithms is left to the implementation, it is recommended (but not specified by this standard) that implementations use the approximation algorithms for IEEE 754 arithmetic contained in fdlibm, the freely distributable mathematical library from Sun Microsystems (<a href="http://www.netlib.org/fdlibm">http://www.netlib.org/fdlibm</a>).</p>



<h6>abs (x)</h6>

<p>返回 x 的绝对值。</p>

<ul>
  <li>若 x 是 NaN, 返回结果是 NaN. </li>

  <li>若 x 是 −0, 返回结果是 +0. </li>

  <li>若 x 是 −∞, 返回结果是 +∞.</li>
</ul>


<h6>acos (x)</h6>

<p>返回 x 的反余弦的依赖实现的近似值。结果以弧度形式表示，范围是 +0 到 +π。</p>

<ul>
  <li>若 x 是 NaN, 返回结果是 NaN. </li>

  <li>若 x 大于 1, 返回结果是 NaN. </li>

  <li>若 x 小于 −1, 返回结果是 NaN. </li>

  <li>若 x 正好是 1, 返回结果是 +0.</li>
</ul>


<h6>asin (x)</h6>

<p>返回 x 的反正弦的依赖实现的近似值。结果以弧度形式表示，范围是−π/2 到 +π/2。</p>

<ul>
  <li>若 x 是 NaN, 返回结果是 NaN. </li>

  <li>若 x 大于 1, 返回结果是 NaN. </li>

  <li>若 x 小于 –1, 返回结果是 NaN. </li>

  <li>若 x 是 +0, 返回结果是 +0. </li>

  <li>若 x 是 −0, 返回结果是 −0.</li>
</ul>


<h6>atan (x)</h6>

<p>返回 x 的反正切的依赖实现的近似值。结果以弧度形式表示，范围是−π/2 到 +π/2。</p>

<ul>
  <li>若 x 是 NaN, 返回结果是 NaN. </li>

  <li>若 x 是 +0, 返回结果是 +0. </li>

  <li>若 x 是 −0, 返回结果是 −0. </li>

  <li>若 x 是 +∞, 返回结果是 一个依赖于实现的近似值 +π/2. </li>

  <li>若 x 是 −∞, 返回结果是 一个依赖于实现的近似值 −π/2.</li>
</ul>


<h6>atan2 (y, x)</h6>

<p>返回 -- 参数 y 和 x 的商 y/x-- 的反正切的依赖实现的近似值，y 和 x 的符号用于确定返回值的象限。注：命名为 y 的参数为第一个，命名为 x 的参数为第二个，这是有意，是反正切函数俩参数的惯例。结果以弧度形式表示，范围是−π到 +π。</p>

<ul>
  <li>若 x 和 y 至少一个是 NaN, 返回结果是 NaN. </li>

  <li>若 y&gt;0 且 x 是 +0, 返回结果是 一个依赖于实现的近似值 +π/2. </li>

  <li>若 y&gt;0 且 x 是 −0, 返回结果是 一个依赖于实现的近似值 +π/2. </li>

  <li>若 y 是 +0 且 x&gt;0, 返回结果是 +0. </li>

  <li>若 y 是 +0 且 x 是 +0, 返回结果是 +0. </li>

  <li>若 y 是 +0 且 x 是 −0, 返回结果是 一个依赖于实现的近似值 +π. </li>

  <li>若 y 是 +0 且 x&lt;0, 返回结果是 一个依赖于实现的近似值 +π. </li>

  <li>若 y 是 −0 且 x&gt;0, 返回结果是 −0. </li>

  <li>若 y 是 −0 且 x 是 +0, 返回结果是 −0. </li>

  <li>若 y 是 −0 且 x 是 −0, 返回结果是 一个依赖于实现的近似值 −π. </li>

  <li>若 y 是 −0 且 x&lt;0, 返回结果是 一个依赖于实现的近似值 −π. </li>

  <li>若 y&lt;0 且 x 是 +0, 返回结果是 一个依赖于实现的近似值 −π/2. </li>

  <li>若 y&lt;0 且 x 是 −0, 返回结果是 一个依赖于实现的近似值 −π/2. </li>

  <li>若 y&gt;0 且 y 是 有限的 且 x 是 +∞, 返回结果是 +0. </li>

  <li>若 y&gt;0 且 y 是 有限的 且 x 是 −∞, 返回结果是 一个依赖于实现的近似值 +π. </li>

  <li>若 y&lt;0 且 y 是 有限的 且 x 是 +∞, 返回结果是 −0. </li>

  <li>若 y&lt;0 且 y 是 有限的 且 x 是 −∞, 返回结果是 一个依赖于实现的近似值 −π. </li>

  <li>若 y 是 +∞ 且 x 是 有限的 , 返回结果是 返回结果是 一个依赖于实现的近似值 +π/2. </li>

  <li>若 y 是 −∞ 且 x 是 有限的 , 返回结果是 返回结果是 一个依赖于实现的近似值 −π/2. </li>

  <li>若 y 是 +∞ 且 x 是 +∞, 返回结果是 一个依赖于实现的近似值 +π/4. </li>

  <li>若 y 是 +∞ 且 x 是 −∞, 返回结果是 一个依赖于实现的近似值 +3π/4. </li>

  <li>若 y 是 −∞ 且 x 是 +∞, 返回结果是 一个依赖于实现的近似值 −π/4. </li>

  <li>若 y 是 −∞ 且 x 是 −∞, 返回结果是 一个依赖于实现的近似值 −3π/4.</li>
</ul>


<h6>ceil (x)</h6>

<p>返回不小于 x 的且为数学整数的最小 ( 接近−∞) 数字值。如果 x 已是整数，则返回 x。</p>

<ul>
  <li>若 x 是 NaN, 返回结果是 NaN. </li>

  <li>若 x 是 +0, 返回结果是 +0. </li>

  <li>若 x 是 −0, 返回结果是 −0. </li>

  <li>若 x 是 +∞, 返回结果是 +∞. </li>

  <li>若 x 是 −∞, 返回结果是 −∞. </li>

  <li>若 x 小于 0 但大于 -1, 返回结果是 −0.</li>
</ul>

<p>注：Math.ceil(x) 的值与 -Math.floor(-x) 的值相同。</p>



<h6>cos (x)</h6>

<p>返回 x 的余弦的依赖实现的近似值。参数被当做是弧度值。</p>

<ul>
  <li>若 x 是 NaN, 返回结果是 NaN. </li>

  <li>若 x 是 +0, 返回结果是 1. </li>

  <li>若 x 是 −0, 返回结果是 1. </li>

  <li>若 x 是 +∞, 返回结果是 NaN. </li>

  <li>若 x 是 −∞, 返回结果是 NaN.</li>
</ul>


<h6>exp (x)</h6>

<p>返回 x 的指数的依赖实现的近似值（e 为 x 次方，e 为自然对数的底）。</p>

<ul>
  <li>若 x 是 NaN, 返回结果是 NaN. </li>

  <li>若 x 是 +0, 返回结果是 1. </li>

  <li>若 x 是 −0, 返回结果是 1. </li>

  <li>若 x 是 +∞, 返回结果是 +∞. </li>

  <li>若 x 是 −∞, 返回结果是 +0.</li>
</ul>


<h6>floor (x)</h6>

<p>返回不大于 x 的且为数学整数的最大 ( 接近 +∞) 数字值。如果 x 已是整数，则返回 x。</p>

<ul>
  <li>若 x 是 NaN, 返回结果是 NaN. </li>

  <li>若 x 是 +0, 返回结果是 +0. </li>

  <li>若 x 是 −0, 返回结果是 −0. </li>

  <li>若 x 是 +∞, 返回结果是 +∞. </li>

  <li>若 x 是 −∞, 返回结果是 −∞. </li>

  <li>若 x 大于 0 但小于 1, 返回结果是 +0.</li>
</ul>

<p>注：Math.floor(x) 的值与 -Math.ceil(-x) 的值相同。</p>



<h6>log (x)</h6>

<p>返回 x 的自然对数的依赖于实现的近似值 .</p>

<ul>
  <li>若 x 是 NaN, 返回结果是 NaN. </li>

  <li>若 x 小于 0, 返回结果是 NaN. </li>

  <li>若 x 是 +0 或 −0, 返回结果是 −∞. </li>

  <li>若 x 是 1, 返回结果是 +0. </li>

  <li>若 x 是 +∞, 返回结果是 +∞.</li>
</ul>


<h6>max ( [ value1 [ , value2 [ , … ] ] ] )</h6>

<p>给定零或多个参数，对每个参数调用 ToNumber 并返回调用结果里的最大值。</p>

<ul>
  <li>若 没有给定参数 , 返回结果是 −∞. </li>

  <li>若 任何值是 NaN, 返回结果是 NaN. </li>

  <li>按照 11.8.5 指定方式进行值比较，确定最大值，与 11.8.5 指定方式的一个不同点是在这里 +0 被看作大于 -0.</li>
</ul>

<p>max 方法的 length 属性是 2。</p>



<h6>min ( [ value1 [ , value2 [ , … ] ] ] )</h6>

<p>给定零或多个参数，对每个参数调用 ToNumber 并返回调用结果里的最小值。</p>

<ul>
  <li>若 没有给定参数 , 返回结果是 +∞. </li>

  <li>若 任何值是 NaN, 返回结果是 NaN. </li>

  <li>按照 11.8.5 指定方式进行值比较，确定最小值，与 11.8.5 指定方式的一个不同点是在这里 +0 被看作大于 -0.</li>
</ul>

<p>min 方法的 length 属性是 2。</p>



<h6>pow (x, y)</h6>

<p>返回 x 的 y 次方的依赖于实现的近似值 .</p>

<ul>
  <li>若 y 是 NaN, 返回结果是 NaN. </li>

  <li>若 y 是 +0, 返回结果是 1, 即使 x 是 NaN. </li>

  <li>若 y 是 −0, 返回结果是 1, 即使 x 是 NaN. </li>

  <li>若 x 是 NaN 且 y 是 非零 , 返回结果是 NaN. </li>

  <li>若 abs(x)&gt;1 且 y 是 +∞, 返回结果是 +∞. </li>

  <li>若 abs(x)&gt;1 且 y 是 −∞, 返回结果是 +0. </li>

  <li>若 abs(x)==1 且 y 是 +∞, 返回结果是 NaN. </li>

  <li>若 abs(x)==1 且 y 是 −∞, 返回结果是 NaN. </li>

  <li>若 abs(x)&lt;1 且 y 是 +∞, 返回结果是 +0. </li>

  <li>若 abs(x)&lt;1 且 y 是 −∞, 返回结果是 +∞. </li>

  <li>若 x 是 +∞ 且 y&gt;0, 返回结果是 +∞. </li>

  <li>若 x 是 +∞ 且 y&lt;0, 返回结果是 +0. </li>

  <li>若 x 是 −∞ 且 y&gt;0 且 y 是 一个奇数 , 返回结果是 −∞. </li>

  <li>若 x 是 −∞ 且 y&gt;0 且 y 不是 一个奇数 , 返回结果是 +∞. </li>

  <li>若 x 是 −∞ 且 y&lt;0 且 y 是 一个奇数 , 返回结果是 −0. </li>

  <li>若 x 是 −∞ 且 y&lt;0 且 y 不是 一个奇数 , 返回结果是 +0. </li>

  <li>若 x 是 +0 且 y&gt;0, 返回结果是 +0. </li>

  <li>若 x 是 +0 且 y&lt;0, 返回结果是 +∞. </li>

  <li>若 x 是 −0 且 y&gt;0 且 y 是 一个奇数 , 返回结果是 −0. </li>

  <li>若 x 是 −0 且 y&gt;0 且 y 不是 一个奇数 , 返回结果是 +0. </li>

  <li>若 x 是 −0 且 y&lt;0 且 y 是 一个奇数 , 返回结果是 −∞. </li>

  <li>若 x 是 −0 且 y&lt;0 且 y 不是 一个奇数 , 返回结果是 +∞. </li>

  <li>若 x&lt;0 且 x 是 有限的 且 y 是 有限的 and y 不是整数 , 返回结果是 NaN.</li>
</ul>


<h6>random ( )</h6>

<p>返回一个大于或等于 0 但小于 1 的符号为正的数字值，选择随机或在该范围内近似均匀分布的伪随机，用一个依赖与实现的算法或策略。此函数不需要参数。</p>



<h6>round (x)</h6>

<p>返回最接近 x 且为数学整数的数字值。如果两个整数同等接近 x，则结果是接近 +∞的数字值 。如果 x 已是整数，则返回 x。</p>

<ul>
  <li>若 x 是 NaN, 返回结果是 NaN. </li>

  <li>若 x 是 +0, 返回结果是 +0. </li>

  <li>若 x 是 −0, 返回结果是 −0. </li>

  <li>若 x 是 +∞, 返回结果是 +∞. </li>

  <li>若 x 是 −∞, 返回结果是 −∞. </li>

  <li>若 x 大于 0 但小于 0.5, 返回结果是 +0. </li>

  <li>若 x 小于 0 但大于或等于 -0.5, 返回结果是 −0.</li>
</ul>

<p>注： 1. Math.round(3.5) 返回 4, 但 Math.round(–3.5) 返回 –3.</p>

<p>注： 2. 当 x 为 −0 或 x 小于 0 当大于大于等于 -0.5 时，Math.round(x) 返回 −0, 但 Math.floor(x+0.5) 返回 +0，除了这种情况之外 Math.round(x) 的返回值与 Math.floor(x+0.5) 的返回值相同。</p>



<h6>sin (x)</h6>

<p>返回 x 的正弦的依赖实现的近似值。参数被当做是弧度值。</p>

<ul>
  <li>若 x 是 NaN, 返回结果是 NaN. </li>

  <li>若 x 是 +0, 返回结果是 +0. </li>

  <li>若 x 是 −0, 返回结果是 −0. </li>

  <li>若 x 是 +∞ 或 −∞, 返回结果是 NaN.</li>
</ul>


<h6>sqrt (x)</h6>

<p>返回 x 的平方根的依赖实现的近似值。</p>

<ul>
  <li>若 x 是 NaN, 返回结果是 NaN. </li>

  <li>若 x 小于 0, 返回结果是 NaN. </li>

  <li>若 x 是 +0, 返回结果是 +0. </li>

  <li>若 x 是 −0, 返回结果是 −0. </li>

  <li>若 x 是 +∞, 返回结果是 +∞.</li>
</ul>


<h6>tan (x)</h6>

<p>返回 x 的正切的依赖实现的近似值。参数被当做是弧度值。</p>

<ul>
  <li>若 x 是 NaN, 返回结果是 NaN. </li>

  <li>若 x 是 +0, 返回结果是 +0. </li>

  <li>若 x 是 −0, 返回结果是 −0. </li>

  <li>若 x 是 +∞ 或 −∞, 返回结果是 NaN.</li>
</ul>


<h4>Date 对象</h4>


<h5>Date 对象的概述和抽象操作的定义</h5>

<p>下面的抽象操作函数用来操作时间值（15.9.1.1 定义）。注：任何情况下，如果这些函数之一的任意参数是 NaN，则结果将是 NaN。</p>



<h6>时间值和时间范围</h6>

<p>一个 Date 对象包含一个表示特定时间瞬间的毫秒的数字值。这样的数字值叫做 <i>时间值 </i>。一个时间值也可以是 NaN，说明这个 Date 对象不表示特定时间瞬间。</p>

<p>ECMAScript 中测量的时间是从协调世界时 1970 年 1 月 1 日开始的毫秒数。在时间值中闰秒是被忽略的，假设每天正好有 86,400,000 毫秒。ECMAScript 数字值可表示的所有从–9,007,199,254,740,991 到 9,007,199,254,740,991 的整数；这个范围足以衡量协调世界时 1970 年 1 月 1 日前后约 285,616 年内任何时间瞬间的精确毫秒。</p>

<p>ECMAScript Date 对象支持的实际时间范围是略小一些的：相对协调世界时 1970 年 1 月 1 日午夜 0 点的精确的–100,000,000 天到 100,000,000 天。这给出了协调世界时 1970 年 1 月 1 日前后 8,640,000,000,000,000 毫秒的范围。</p>

<p>精确的协调世界时 1970 年 1 月 1 日午夜 0 点用 +0 表示。</p>



<h6>天数和天内时间</h6>

<p>一个给定时间值 t 所属的天数是</p>

<pre> Day(t) = floor(t / msPerDay)</pre>

<p>其中每天的毫秒数是</p>

<pre> msPerDay = 86400000</pre>

<p>余数叫做天内时间</p>

<pre> TimeWithinDay(t) = t modulo msPerDay</pre>



<h6>年数</h6>

<p>ECMAScript 使用一个推算公历系统，来将一个天数映射到一个年数，并确定在那年的月份的日期。在这个系统中，闰年是且仅是（可被 4 整除）且（（不可被 100 整除）或（可被 400 整除））的年份。因此，y 年的天的数目定义为</p>

<pre> DaysInYear(y) = 365 { 如果 (y 取模 4) ≠ 0 }
               = 366 { 如果 (y 取模 4) = 0 且 (y 取模 100) ≠ 0 }
               = 365 { 如果 (y 取模 100) = 0 且 (y 取模 400) ≠ 0 }
               = 366 { 如果 (y 取模 400) = 0 }</pre>

<p>所有非闰年有 365 天，其中每月的天的数目是常规的。闰年的二月里有个多出来的一天。 y 年第一天的天数是 :</p>

<pre> DayFromYear(y) = 365 × (y−1970) + floor((y−1969)/4) − floor((y−1901)/100) + floor((y−1601)/400)</pre>

<p>y 年的起始时间值是：</p>

<pre> TimeFromYear(y) = msPerDay × DayFromYear(y)</pre>

<p>一个时间值决定的年数是：</p>

<pre> YearFromTime(t) = 满足条件 TimeFromYear(y) ≤ t 的最大整数 y （接近正无穷）</pre>

<p>若时间值在闰年内，闰年函数返回 1，否则返回 0：</p>

<pre> InLeapYear(t) = 0 { 如果 DaysInYear(YearFromTime(t)) = 365 }
               = 1 { 如果 DaysInYear(YearFromTime(t)) = 366 }</pre>


<h6>月数</h6>

<p>月份是由闭区间 0 到 11 内的一个整数确定。一个时间值 t 到一个月数的映射 MonthFromTime(t) 的定义为：</p>

<pre> MonthFromTime(t) = 0 if 0 ≤ DayWithinYear(t) &lt; 31
   = 1 if 31 ≤ DayWithinYear (t) &lt; 59+InLeapYear(t)
   = 2 if 59+InLeapYear(t) ≤ DayWithinYear (t) &lt; 90+InLeapYear(t)
   = 3 if 90+InLeapYear(t) ≤ DayWithinYear (t) &lt; 120+InLeapYear(t)
   = 4 if 120+InLeapYear(t) ≤ DayWithinYear (t) &lt; 151+InLeapYear(t)
   = 5 if 151+InLeapYear(t) ≤ DayWithinYear (t) &lt; 181+InLeapYear(t)
   = 6 if 181+InLeapYear(t) ≤ DayWithinYear (t) &lt; 212+InLeapYear(t)
   = 7 if 212+InLeapYear(t) ≤ DayWithinYear (t) &lt; 243+InLeapYear(t)
   = 8 if 243+InLeapYear(t) ≤ DayWithinYear (t) &lt; 273+InLeapYear(t)
   = 9 if 273+InLeapYear(t) ≤ DayWithinYear (t) &lt; 304+InLeapYear(t)
   = 10 if 304+InLeapYear(t) ≤ DayWithinYear (t) &lt; 334+InLeapYear(t)
   = 11 if 334+InLeapYear(t) ≤ DayWithinYear (t) &lt; 365+InLeapYear(t)</pre>

<p>其中</p>

<pre> DayWithinYear(t) = Day(t)−DayFromYear(YearFromTime(t))</pre>

<p>月数值 0 指一月；1 指二月；2 指三月；3 指四月；4 指五月；5 指六月；6 指七月；7 指八月；8 指九月；9 指十月；10 指十一月；11 指十二月。注：MonthFromTime(0) = 0，对应 1970 年 1 月 1 日，星期四。</p>



<h6>日期数</h6>

<p>一个日期数用闭区间 1 到 31 内的一个整数标识。从一个时间值 t 到一个日期数的映射 DateFromTime(t) 的定义为：</p>

<pre> DateFromTime(t) = DayWithinYear(t)+1 if MonthFromTime(t)=0
   = DayWithinYear(t)−30 if MonthFromTime(t)=1
   = DayWithinYear(t)−58−InLeapYear(t) if MonthFromTime(t)=2
   = DayWithinYear(t)−89−InLeapYear(t) if MonthFromTime(t)=3
   = DayWithinYear(t)−119−InLeapYear(t) if MonthFromTime(t)=4
   = DayWithinYear(t)−150−InLeapYear(t) if MonthFromTime(t)=5
   = DayWithinYear(t)−180−InLeapYear(t) if MonthFromTime(t)=6
   = DayWithinYear(t)−211−InLeapYear(t) if MonthFromTime(t)=7
   = DayWithinYear(t)−242−InLeapYear(t) if MonthFromTime(t)=8
   = DayWithinYear(t)−272−InLeapYear(t) if MonthFromTime(t)=9
   = DayWithinYear(t)−303−InLeapYear(t) if MonthFromTime(t)=10
   = DayWithinYear(t)−333−InLeapYear(t) if MonthFromTime(t)=11</pre>


<h6>星期数</h6>

<p>特定时间值 t 对应的星期数的定义为：</p>

<pre> WeekDay(t) = (Day(t) + 4) modulo 7</pre>

<p>星期数的值 0 指星期日；1 指星期一；2 指星期二；3 指星期三；4 指星期四；5 指星期五；6 指星期六。注：WeekDay(0) = 4, 对应 1970 年 1 月 01 日 星期四。</p>



<h6>本地时区校准</h6>

<p>期望一个 ECMAScript 的实现确定本地时区校准。本地时区校准是一个毫秒为单位的值 LocalTZA，它加上 UTC 代表本地标准时间。LocalTZA 不体现夏令时。LocalTZA 值不随时间改变，但只取决于地理位置。</p>



<h6>夏令时校准</h6>

<p>期望一个 ECMAScript 的实现确定夏令时算法。确定夏令时校准的算法 DaylightSavingTA(t)，以毫秒为单位，必须只依赖下面四个项目：</p>

<p>(1) 自本年开始以来的时间</p>

<pre> t – TimeFromYear(YearFromTime(t))</pre>

<p>(2) t 是否在闰年内</p>

<pre> InLeapYear(t)</pre>

<p>(3) 本年第一天的星期数</p>

<pre> WeekDay(TimeFromYear(YearFromTime(t))</pre>

<p>(4) 地理位置。</p>

<p>The implementation of ECMAScript should not try to determine whether the exact time was subject to daylight saving time, but just whether daylight saving time would have been in effect if the current daylight saving time algorithm had been used at the time. This avoids complications such as taking into account the years that the locale observed daylight saving time year round.</p>

<p>If the host environment provides functionality for determining daylight saving time, the implementation of ECMAScript is free to map the year in question to an equivalent year (same leap-year-ness and same starting week day for the year) for which the host environment provides daylight saving time information. The only restriction is that all equivalent years should produce the same result.</p>



<h6>本地时间</h6>

<p>从协调世界时到本地时间的转换，定义为</p>

<pre> LocalTime(t) = t + LocalTZA + DaylightSavingTA(t)</pre>

<p>从本地时间到协调世界时的转换，定义为</p>

<pre> UTC(t) = t – LocalTZA – DaylightSavingTA(t – LocalTZA)</pre>

<p>注： UTC(LocalTime(t)) 不一定总是等于 t。</p>



<h6>小时 , 分钟 , 秒 , 毫秒</h6>

<p>以下函数用于分解时间值：</p>

<pre> HourFromTime(t) = floor(t / msPerHour) modulo HoursPerDay
 MinFromTime(t) = floor(t / msPerMinute) modulo MinutesPerHour
 SecFromTime(t) = floor(t / msPerSecond) modulo SecondsPerMinute
 msFromTime(t) = t modulo msPerSecond</pre>

<p>其中</p>

<pre> HoursPerDay = 24
 MinutesPerHour = 60
 SecondsPerMinute = 60
 msPerSecond = 1000
 msPerMinute = 60000 = msPerSecond × SecondsPerMinute
 msPerHour = 3600000 = msPerMinute × MinutesPerHour</pre>


<h6>MakeTime (hour, min, sec, ms)</h6>

<p>MakeTime 抽象操作用它的四个参数算出一个毫秒数，参数必须是 ECMAScript 数字值。此抽象操作运行如下：</p>

<ol>
  <li>如果 hour 不是有限的或 min 不是有限的或 sec 不是有限的或 ms 不是有限的 , 返回 NaN。 </li>

  <li>令 h 为 ToInteger(hour). </li>

  <li>令 m 为 ToInteger(min). </li>

  <li>令 s 为 ToInteger(sec). </li>

  <li>令 milli 为 ToInteger(ms). </li>

  <li>令 t 为 h * msPerHour + m * msPerMinute + s * msPerSecond + milli, 执行的四则运算根据 IEEE 754 规则（这就像使用 ECMAScript 运算符 * 和 + 一样）。 </li>

  <li>返回 t。</li>
</ol>


<h6>MakeDay (year, month, date)</h6>

<p>MakeDay 抽象操作用它的三个参数算出一个天数，参数必须是 ECMAScript 数字值。此抽象操作运行如下：</p>

<ol>
  <li>如果 year 不是有限的或 month 不是有限的或 date 不是有限的 , 返回 NaN. </li>

  <li>令 y 为 ToInteger(year). </li>

  <li>令 m 为 ToInteger(month). </li>

  <li>令 dt 为 ToInteger(date). </li>

  <li>令 ym 为 y + floor(m /12). </li>

  <li>令 mn 为 m modulo 12. </li>

  <li>找一个满足 YearFromTime(t) == ym 且 MonthFromTime(t) == mn 且 DateFromTime(t) == 1 的 t 值 ; 但如果这些条件是不可能的（因为有些参数超出了范围）, 返回 NaN. </li>

  <li>返回 Day(t) + dt − 1.</li>
</ol>


<h6>MakeDate (day, time)</h6>

<p>MakeDate 抽象操作用它的两个参数算出一个毫秒数，参数必须是 ECMAScript 数字值。此抽象操作运行如下：</p>

<ol>
  <li>如果 day 不是有限的或 time 不是有限的 , 返回 NaN. </li>

  <li>返回 day × msPerDay + time.</li>
</ol>


<h6>TimeClip (time)</h6>

<p>TimeClip 抽象操作用它的参数算出一个毫秒数，参数必须是 ECMAScript 数字值。此抽象操作运行如下：</p>

<ol>
  <li>如果 time 不是有限的 , 返回 NaN. </li>

  <li>如果 abs(time) &gt; 8.64 x 1015, 返回 NaN. </li>

  <li>返回 ToInteger(time) 和 ToInteger(time) + (+0) 之一，这依赖于实现 ( 加正一是为了将 −0 转换成 +0)。</li>
</ol>

<p>注： 第 3 步的重点是说允许实现自行选择时间值的内部表示形式，如 64 位有符号整数或 64 位浮点数。根据不同的实现，这个内部表示可能区分也可能无法区分 −0 和 +0。</p>



<h6>日期时间字符串格式</h6>

<p>ECMAScript 定义了一个基于简化的 ISO 8601 扩展格式的日期时间的字符串互换格式，格式为：YYYY-MM-DDTHH:mm:ss.sssZ</p>

<p>其中个字段为：</p>

<p>YYYY
  <br />是公历中年的十进制数字。</p>

<p>-
  <br />在字符串中直接以“-” ( 破折号 ) 出现两次。</p>

<p>MM
  <br />是一年中的月份，从 01 ( 一月 ) 到 12 ( 十二月 )。</p>

<p>DD
  <br />是月份中的日期，从 01 到 30。</p>

<p>T
  <br />在字符串中直接以“T”出现，用来表明时间元素的开始。</p>

<p>HH
  <br />是用两个十进制数字表示的，自午夜 0 点以来的小时数。</p>

<p> :
  <br />在字符串中直接以“:” ( 冒号 ) 出现两次。</p>

<p>mm
  <br />是用两个十进制数字表示的，自小时开始以来的分钟数。</p>

<p>ss
  <br />是用两个十进制数字表示的，自分开始以来的秒数。</p>

<p>.
  <br />在字符串中直接以“.” ( 点 ) 出现。</p>

<p>sss
  <br />是用三个十进制数字表示的，自秒开始以来的毫秒数。</p>

<p>Z
  <br />是时区偏移量，由（“Z” ( 指 UTC) 或“+” 或 “-”）和后面跟着的时间表达式 hh:mm 组成。</p>

<p>这个格式包括只表示日期的形式：</p>

<pre> YYYY
 YYYY-MM
 YYYY-MM-DD</pre>

<p>这个格式还包括“日期时间”形式，它由上面的只表示日期的形式之一和紧跟在后面的“T”和以下时间形式之一和可选的时区偏移量组成：</p>

<pre> THH:mm
 THH:mm:ss
 THH:mm:ss.sss</pre>

<p>所有数字必须是 10 进制的。如果缺少 MM 或 DD 字段，用“01”作为它们的值。如果缺少 mm 或 ss 字段，用“00”作为它们的值，对于缺少的 sss 用“000”作为它的值。对于缺少的时区偏移量用“Z”。</p>

<p>一个格式字符串里有非法值（越界以及语法错误），意味着这个格式字符串不是有效的本节描述格式的实例。</p>

<p>注：1. 由于每天的开始和结束都在午夜，俩符号 00:00 和 24:00 可区分这样的可以是同一时间的两个午夜。这意味着两个符号 1995-02-04T24:00 和 1995-02-05T00:00 精准的指向同一时刻。</p>

<p>注：2. 不存在用来规范像 CET, EST 这样的民间时区缩写的国际标准。有时相同的缩写甚至使用不同的时区。出于这个原因，ISO 8601 和这里的格式指定数字来表示时区。</p>



<h6>扩展的年</h6>

<p>ECMAScript 需要能表示 6 位数年份（扩展的年份）的能力；协调世界时 1970 年 1 月 1 日前后分别约 285,616 年。对于表示 0 年之前或 9999 年之后的年份，ISO 8601 允许对年的表示法进行扩展，但只能在发送和接受信息的双方有事先共同约定的情况下才能扩展。在已经简化的 ECMAScript 的格式中这样扩展的年份表示法有 2 个额外的数字和始终存在的前缀符号 + 或 - 。0 年被认为是正的，因此用 + 符号作为前缀。</p>

<pre>NOTE Examples of extended years:

-283457-03-21T15:00:59.008Z   283458 B.C.
-000001-01-01T00:00:00Z          2 B.C.
+000000-01-01T00:00:00Z         1 B.C.
+000001-01-01T00:00:00Z         1 A.D.
+001970-01-01T00:00:00Z         1970 A.D.
+002009-12-15T00:00:00Z         2009 A.D.
+287396-10-12T08:59:00.992Z 287396 A.D.</pre>

<h5>作为函数调用 Date 构造器</h5>

<p>当把 Date 作为函数来调用，而不作为构造器，它返回一个表示当前时间（协调世界时）的字符串。</p>

<p>注： 函数调用 Date(…) 的结果和用相同参数调用表达式 new Date(…) 创建的对象是不同的。</p>



<h6>Date ( [ year [, month [, date [, hours [, minutes [, seconds [, ms ] ] ] ] ] ] ] )</h6>

<p>所有参数都是可选的；接受提供的任何参数，但被完全忽略。返回一个仿佛是用表达式 (new Date()).toString() 创建的字符串，这里的 Date 是标准内置构造器，toString 是标准内置方法 Date.prototype.toString。</p>



<h5>Date 构造器</h5>

<p>当把 Date 作为 new 表达式的一部分来调用，它是个构造器：它初始化新创建的对象。</p>



<h6>new Date (year, month [, date [, hours [, minutes [, seconds [, ms ] ] ] ] ] )</h6>

<p>当用二到七个参数调用 Date 构造器，它用 year, month, 还有 ( 可选的 ) date, hours, minutes, seconds, ms 来计算时间。</p>

<p>新构造对象的 [[Prototype]] 内部属性设定为原始的时间原型对象，它是 Date.prototype(15.9.4.1) 的初始值。</p>

<p>新构造对象的 [[Class]] 内部属性设定为 &quot;Date&quot;。</p>

<p>新构造对象的 [[Extensible]] 内部属性设定为 ture。</p>

<p>新构造对象的 [[PrimitiveValue]] 内部属性按照以下步骤设定：</p>

<ol>
  <li>令 y 为 ToNumber(year). </li>

  <li>令 m 为 ToNumber(month). </li>

  <li>如果提供了 date ，则令 dt 为 ToNumber(date); 否则令 dt 为 1. </li>

  <li>如果提供了 hours ，则令 h 为 ToNumber(hours); 否则令 h 为 0. </li>

  <li>如果提供了 minutes ，则令 min 为 ToNumber(minutes); 否则令 min 为 0. </li>

  <li>如果提供了 seconds ，则令 s 为 ToNumber(seconds); 否则令 s 为 0. </li>

  <li>如果提供了 ms ，则令 milli 为 ToNumber(ms); 否则令 milli 为 0. </li>

  <li>如果 y 不是 NaN 且 0 ≤ ToInteger(y) ≤ 99, 则令 yr 为 1900+ToInteger(y); 否则令 yr 为 y. </li>

  <li>令 finalDate 为 MakeDate(MakeDay(yr, m, dt), MakeTime(h, min, s, milli)). </li>

  <li>设定新构造对象的 [[PrimitiveValue]] 内部属性为 TimeClip(UTC(finalDate)).</li>
</ol>


<h6>new Date (value)</h6>

<p>新构造对象的 [[Prototype]] 内部属性设定为原始的时间原型对象，它是 Date.prototype(15.9.4.1) 的初始值。</p>

<p>新构造对象的 [[Class]] 内部属性设定为 &quot;Date&quot;。</p>

<p>新构造对象的 [[Extensible]] 内部属性设定为 ture。</p>

<p>新构造对象的 [[PrimitiveValue]] 内部属性按照以下步骤设定：</p>

<ol>
  <li>令 v 为 ToPrimitive(value). </li>

  <li>如果 Type(v) 是 String, 则 
    <ol>
      <li>用与 parse 方法 (15.9.4.2) 完全相同的方式将 v 解析为一个日期时间；令 V 为这个日期时间的时间值。</li>
    </ol>
  </li>

  <li>否则 , 令 V 为 ToNumber(v). </li>

  <li>设定新构造对象的 [[PrimitiveValue]] 内部属性为 TimeClip(V)，并返回这个值。</li>
</ol>


<h6>new Date ( )</h6>

<p>新构造对象的 [[Prototype]] 内部属性设定为原始的时间原型对象，它是 Date.prototype(15.9.4.1) 的初始值。</p>

<p>新构造对象的 [[Class]] 内部属性设定为 &quot;Date&quot;。</p>

<p>新构造对象的 [[Extensible]] 内部属性设定为 ture。</p>

<p>新构造对象的 [[PrimitiveValue]] 内部属性设定为表示当前时间的时间值（协调世界时）。</p>



<h5>Date 构造器的属性</h5>

<p>Date 构造器的 [[Prototype]] 内部属性的值是函数原型对象 (15.3.4)。</p>

<p>除了内部属性和 length 属性 ( 值为 7) 之外，Date 构造器还有以下属性：</p>



<h6>Date.prototype</h6>

<p>Date.prototype 的初始值是内置的 Date 原型对象 (15.9.5)。</p>

<p>此属性有特性 { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。</p>



<h6>Date.parse (string)</h6>

<p>parse 函数对它的参数应用 ToString 操作并将结果字符串解释为一个日期和时间；返回一个数字值，是对应这个日期时间的 UTC 时间值。字符串可解释为本地时间，UTC 时间，或某个其他时区的时间，这取决于字符串里的内容。此函数首先尝试根据日期时间字符串格式（15.9.1.15）里的规则来解析字符串的格式。如果字符串不符合这个格式此函数可回退，用任意实现定义的试探方式或日期格式。无法识别的字符串或日期时间包含非法元素值，将导致 Date.parse 返回 NaN。</p>

<p>在所有属性都指向它们的初始值的情况下，如果 x 是一个在特定 ECMAScript 的实现里的毫秒数为零的任意 Date 对象，则在这个实现中以下所有表达式应产生相同数字值：</p>

<code> x.valueOf()</code>
 <code>Date.parse(x.toString())</code>
 <code>Date.parse(x.toUTCString())</code>
 <code>Date.parse(x.toISOString())</code>

<p>然而，表达式</p>

<pre> Date.parse( x.toLocaleString())</pre>

<p>是不需要产生与前面三个表达参数相同的数字值。通常，在给定的字符串不符合日期时间字符串格式（15.9.1.15）时，Date.parse 的产生值是依赖于实现，并且在同一实现中 toString 或 toUTCString 方法不能产生不符合日期时间字符串格式的字符串。</p>



<h6>Date.UTC (year, month [, date [, hours [, minutes [, seconds [, ms ] ] ] ] ])</h6>

<p>当用少于两个的参数调用 UTC 函数时，它的行为是依赖于实现的。当用二到七个参数调用 UTC 函数，它从 year, month 和 ( 可选的 ) date, hours, minutes, seconds, ms 计算出日期时间。采用以下步骤：</p>

<ol>
  <li>令 y 为 ToNumber(year). </li>

  <li>令 m 为 ToNumber(month). </li>

  <li>如果提供了 date ，则令 dt 为 ToNumber(date); 否则令 dt 为 1. </li>

  <li>如果提供了 hours ，则令 h 为 ToNumber(hours); 否则令 h 为 0. </li>

  <li>如果提供了 minutes ，则令 min 为 ToNumber(minutes); 否则令 min 为 0. </li>

  <li>如果提供了 seconds ，则令 s 为 ToNumber(seconds); 否则令 s 为 0. </li>

  <li>如果提供了 ms ，则令 milli 为 ToNumber(ms); 否则令 milli 为 0. </li>

  <li>如果 y 不是 NaN 且 0 ≤ ToInteger(y) ≤ 99, 则令 yr 为 1900+ToInteger(y); 否则令 yr 为 y. </li>

  <li>返回 TimeClip(MakeDate(MakeDay(yr, m, dt), MakeTime(h, min, s, milli))).</li>
</ol>

<p>UTC 函数的 length 属性是 7。</p>

<p>注： UTC 函数与 Date 构造器的不同点有：它返回一个时间值，而不是创建 Date 对象，还有它将参数解释为 UTC，而不是本地时间。</p>



<h6>Date.now ( )</h6>

<p>now 函数返回一个数字值，它表示调用 now 时的 UTC 日期时间的时间值。</p>



<h5>Date 原型对象的属性</h5>

<p>Date 原型对象自身是一个 Date 对象（其 [[Class]] 是 &quot;Date&quot;），其 [[PrimitiveValue]] 是 NaN。</p>

<p>Date 原型对象的 [[Prototype]] 内部属性的值是标准内置 Object 原型对象 (15.2.4)。</p>

<p>在以下对 Date 原型对象的函数属性的描述中，短语“this Date 对象”指调用函数时的 this 值对象。除非另外说明，这些函数不是通用的；如果 this 值不是 [[Class]] 内部属性为 &quot;Date&quot; 的对象，则抛出一个 TypeError 异常。短语“this 时间值”指代表 this Date 对象的时间值的数字值，它是 this Date 对象的 [[PrimitiveValue]] 内部属性的值。</p>



<h6>Date.prototype.constructor</h6>

<p>Date.prototype.constructor 的初始值是内置 Date 构造器。</p>



<h6>Date.prototype.toString ( )</h6>

<p>此函数返回一个字符串值。字符串中内容是依赖于实现的，但目的是用一种方便，人类可读的形式表示当前时区的时间。</p>

<p>注： 对毫秒数为零的任意 Date 值 d，Date.parse(d.toString()) 和 d.valueOf() 的结果相同。见 15.9.4.2</p>



<h6>Date.prototype.toDateString ( )</h6>

<p>此函数返回一个字符串值。字符串中内容是依赖于实现的，但目的是用一种方便，人类可读的形式表示当前时区时间的“日期”部分。</p>



<h6>Date.prototype.toTimeString ( )</h6>

<p>此函数返回一个字符串值。字符串中内容是依赖于实现的，但目的是用一种方便，人类可读的形式表示当前时区时间的“时间”部分。</p>



<h6>Date.prototype.toLocaleString ( )</h6>

<p>此函数返回一个字符串值。字符串中内容是依赖于实现的，但目的是用一种 -- 对应宿主环境的当前语言环境设定的 -- 方便，人类可读的形式表示当前时区的时间。</p>

<p>注： 这个函数的第一个参数可能会在此标准的未来版本中使用到；因此建议实现不要以任何目的使用这个位置参数。</p>



<h6>Date.prototype.toLocaleDateString ( )</h6>

<p>此函数返回一个字符串值。字符串中内容是依赖于实现的，但目的是用一种 -- 对应宿主环境的当前语言环境设定的 -- 方便，人类可读的形式表示当前时区时间的“日期”部分。</p>

<p>注： 这个函数的第一个参数可能会在此标准的未来版本中使用到；因此建议实现不要以任何目的使用这个位置参数。</p>



<h6>Date.prototype.toLocaleTimeString ( )</h6>

<p>此函数返回一个字符串值。字符串中内容是依赖于实现的，但目的是用一种 -- 对应宿主环境的当前语言环境设定的 -- 方便，人类可读的形式表示当前时区时间的“时间”部分。</p>

<p>注： 这个函数的第一个参数可能会在此标准的未来版本中使用到；因此建议实现不要以任何目的使用这个位置参数。</p>



<h6>Date.prototype.valueOf ( )</h6>

<p>valueOf 函数返回一个数字值，它是 this 时间值。</p>



<h6>Date.prototype.getTime ( )</h6>

<ol>
  <li>返回 this 时间值。</li>
</ol>


<h6>Date.prototype.getFullYear ( )</h6>

<ol>
  <li>令 t 为 this 时间值 . </li>

  <li>如果 t 是 NaN, 返回 NaN. </li>

  <li>返回 YearFromTime(LocalTime(t)).</li>
</ol>


<h6>Date.prototype.getUTCFullYear ( )</h6>

<ol>
  <li>令 t 为 this 时间值 . </li>

  <li>如果 t 是 NaN, 返回 NaN. </li>

  <li>返回 YearFromTime(t).</li>
</ol>


<h6>Date.prototype.getMonth ( )</h6>

<ol>
  <li>令 t 为 this 时间值 . </li>

  <li>如果 t 是 NaN, 返回 NaN. </li>

  <li>返回 MonthFromTime(LocalTime(t)).</li>
</ol>


<h6>Date.prototype.getUTCMonth ( )</h6>

<ol>
  <li>令 t 为 this 时间值 . </li>

  <li>如果 t 是 NaN, 返回 NaN. </li>

  <li>返回 MonthFromTime(t).</li>
</ol>


<h6>Date.prototype.getDate ( )</h6>

<ol>
  <li>令 t 为 this 时间值 . </li>

  <li>如果 t 是 NaN, 返回 NaN. </li>

  <li>返回 DateFromTime(LocalTime(t)).</li>
</ol>


<h6>Date.prototype.getUTCDate ( )</h6>

<ol>
  <li>令 t 为 this 时间值 . </li>

  <li>如果 t 是 NaN, 返回 NaN. </li>

  <li>返回 DateFromTime(t).</li>
</ol>


<h6>Date.prototype.getDay ( )</h6>

<ol>
  <li>令 t 为 this 时间值 . </li>

  <li>如果 t 是 NaN, 返回 NaN. </li>

  <li>返回 WeekDay(LocalTime(t)).</li>
</ol>


<h6>Date.prototype.getUTCDay ( )</h6>

<ol>
  <li>令 t 为 this 时间值 . </li>

  <li>如果 t 是 NaN, 返回 NaN. </li>

  <li>返回 WeekDay(t).</li>
</ol>


<h6>Date.prototype.getHours ( )</h6>

<ol>
  <li>令 t 为 this 时间值 . </li>

  <li>如果 t 是 NaN, 返回 NaN. </li>

  <li>返回 HourFromTime(LocalTime(t)).</li>
</ol>


<h6>Date.prototype.getUTCHours ( )</h6>

<ol>
  <li>令 t 为 this 时间值 . </li>

  <li>如果 t 是 NaN, 返回 NaN. </li>

  <li>返回 HourFromTime(t).</li>
</ol>


<h6>Date.prototype.getMinutes ( )</h6>

<ol>
  <li>令 t 为 this 时间值 . </li>

  <li>如果 t 是 NaN, 返回 NaN. </li>

  <li>返回 MinFromTime(LocalTime(t)).</li>
</ol>


<h6>Date.prototype.getUTCMinutes ( )</h6>

<ol>
  <li>令 t 为 this 时间值 . </li>

  <li>如果 t 是 NaN, 返回 NaN. </li>

  <li>返回 MinFromTime(t).</li>
</ol>


<h6>Date.prototype.getSeconds ( )</h6>

<ol>
  <li>令 t 为 this 时间值 . </li>

  <li>如果 t 是 NaN, 返回 NaN. </li>

  <li>返回 SecFromTime(LocalTime(t)).</li>
</ol>


<h6>Date.prototype.getUTCSeconds ( )</h6>

<ol>
  <li>令 t 为 this 时间值 . </li>

  <li>如果 t 是 NaN, 返回 NaN. </li>

  <li>返回 SecFromTime(t).</li>
</ol>


<h6>Date.prototype.getMilliseconds ( )</h6>

<ol>
  <li>令 t 为 this 时间值 . </li>

  <li>如果 t 是 NaN, 返回 NaN. </li>

  <li>返回 msFromTime(LocalTime(t)).</li>
</ol>


<h6>Date.prototype.getUTCMilliseconds ( )</h6>

<ol>
  <li>令 t 为 this 时间值 . </li>

  <li>如果 t 是 NaN, 返回 NaN. </li>

  <li>返回 msFromTime(t).</li>
</ol>


<h6>Date.prototype.getTimezoneOffset ( )</h6>

<p>返回本地时间和 UTC 时间之间相差的分钟数。</p>

<ol>
  <li>令 t 为 this 时间值 . </li>

  <li>如果 t 是 NaN, 返回 NaN. </li>

  <li>返回 (t − LocalTime(t)) / msPerMinute.</li>
</ol>


<h6>Date.prototype.setTime (time)</h6>

<ol>
  <li>令 v 为 TimeClip(ToNumber(time)). </li>

  <li>设定 this Date 对象的 [[PrimitiveValue]] 内部属性为 v. </li>

  <li>返回 v.</li>
</ol>


<h6>Date.prototype.setMilliseconds (ms)</h6>

<ol>
  <li>令 t 为 LocalTime(this 时间值 ) 的结果 . </li>

  <li>令 time 为 MakeTime(HourFromTime(t), MinFromTime(t), SecFromTime(t), ToNumber(ms)). </li>

  <li>令 u 为 TimeClip(UTC(MakeDate(Day(t), time))). </li>

  <li>设定 this Date 对象的 [[PrimitiveValue]] 内部属性为 u. </li>

  <li>返回 u.</li>
</ol>


<h6>Date.prototype.setUTCMilliseconds (ms)</h6>

<ol>
  <li>令 t 为 this 时间值 . </li>

  <li>令 time 为 MakeTime(HourFromTime(t), MinFromTime(t), SecFromTime(t), ToNumber(ms)). </li>

  <li>令 v 为 TimeClip(MakeDate(Day(t), time)). </li>

  <li>设定 this Date 对象的 [[PrimitiveValue]] 内部属性为 v. </li>

  <li>返回 v.</li>
</ol>


<h6>Date.prototype.setSeconds (sec [, ms ] )</h6>

<p>没指定 ms 参数时的行为是，仿佛 ms 被指定为调用 getMilliseconds() 的结果一样。</p>

<ol>
  <li>令 t 为 LocalTime(this 时间值 ) 的结果 . </li>

  <li>令 s 为 ToNumber(sec). </li>

  <li>如果没指定 ms , 则令 milli 为 msFromTime(t); 否则，令 milli 为 ToNumber(ms). </li>

  <li>令 date 为 MakeDate(Day(t), MakeTime(HourFromTime(t), MinFromTime(t), s, milli)). </li>

  <li>令 u 为 TimeClip(UTC(date)). </li>

  <li>设定 this Date 对象的 [[PrimitiveValue]] 内部属性为 u. </li>

  <li>返回 u.</li>
</ol>

<p>setSeconds 方法的 length 属性是 2。</p>



<h6>Date.prototype.setUTCSeconds (sec [, ms ] )</h6>

<p>没指定 ms 参数时的行为是，仿佛 ms 被指定为调用 getUTCMilliseconds() 的结果一样。</p>

<ol>
  <li>令 t 为 this 时间值 . </li>

  <li>令 s 为 ToNumber(sec). </li>

  <li>如果没指定 ms , 则令 milli 为 msFromTime(t); 否则，令 milli 为 ToNumber(ms). </li>

  <li>令 date 为 MakeDate(Day(t), MakeTime(HourFromTime(t), MinFromTime(t), s, milli)). </li>

  <li>令 v 为 TimeClip(date). </li>

  <li>设定 this Date 对象的 [[PrimitiveValue]] 内部属性为 v. </li>

  <li>返回 v.</li>
</ol>

<p>setUTCSeconds 方法的 length 属性是 2。</p>



<h6>Date.prototype.setMinutes (min [, sec [, ms ] ] )</h6>

<p>没指定 sec 参数时的行为是，仿佛 ms 被指定为调用 getSeconds() 的结果一样。</p>

<p>没指定 ms 参数时的行为是，仿佛 ms 被指定为调用 getMilliseconds() 的结果一样。</p>

<ol>
  <li>令 t 为 LocalTime(this 时间值 ) 的结果 . </li>

  <li>令 m 为 ToNumber(min). </li>

  <li>如果没指定 sec , 则令 s 为 SecFromTime(t); 否则 , 令 s 为 ToNumber(sec). </li>

  <li>如果没指定 ms , 则令 milli 为 msFromTime(t); 否则 , 令 milli 为 ToNumber(ms). </li>

  <li>令 date 为 MakeDate(Day(t), MakeTime(HourFromTime(t), m, s, milli)). </li>

  <li>令 u 为 TimeClip(UTC(date)). </li>

  <li>设定 this Date 对象的 [[PrimitiveValue]] 内部属性为 u. </li>

  <li>返回 u.</li>
</ol>

<p>setMinutes 方法的 length 属性是 3。</p>



<h6>Date.prototype.setUTCMinutes (min [, sec [, ms ] ] )</h6>

<p>没指定 sec 参数时的行为是，仿佛 ms 被指定为调用 getUTCSeconds() 的结果一样。</p>

<p>没指定 ms 参数时的行为是，仿佛 ms 被指定为调用 getUTCMilliseconds() 的结果一样。</p>

<ol>
  <li>令 t 为 this 时间值 . </li>

  <li>令 m 为 ToNumber(min). </li>

  <li>如果没指定 sec , 则令 s 为 SecFromTime(t); 否则 , 令 s 为 ToNumber(sec). </li>

  <li>如果没指定 ms , 则令 milli 为 msFromTime(t); 否则 , 令 milli 为 ToNumber(ms). </li>

  <li>令 date 为 MakeDate(Day(t), MakeTime(HourFromTime(t), m, s, milli)). </li>

  <li>令 v 为 TimeClip(date). </li>

  <li>设定 this Date 对象的 [[PrimitiveValue]] 内部属性为 v. </li>

  <li>返回 v.</li>
</ol>

<p>setUTCMinutes 方法的 length 属性是 3。</p>



<h6>Date.prototype.setHours (hour [, min [, sec [, ms ] ] ] )</h6>

<p>没指定 min 参数时的行为是，仿佛 min 被指定为调用 getMinutes() 的结果一样。</p>

<p>没指定 sec 参数时的行为是，仿佛 ms 被指定为调用 getSeconds() 的结果一样。</p>

<p>没指定 ms 参数时的行为是，仿佛 ms 被指定为调用 getMilliseconds() 的结果一样。</p>

<ol>
  <li>令 t 为 LocalTime(this 时间值 ) 的结果 . </li>

  <li>令 h 为 ToNumber(hour). </li>

  <li>如果没指定 min , 则令 m 为 MinFromTime(t); 否则 , 令 m 为 ToNumber(min). </li>

  <li>如果没指定 sec , 则令 s 为 SecFromTime(t); 否则 , 令 s 为 ToNumber(sec). </li>

  <li>如果没指定 ms , 则令 milli 为 msFromTime(t); 否则 , 令 milli 为 ToNumber(ms). </li>

  <li>令 date 为 MakeDate(Day(t), MakeTime(h, m, s, milli)). </li>

  <li>令 u 为 TimeClip(UTC(date)). </li>

  <li>设定 this Date 对象的 [[PrimitiveValue]] 内部属性为 u. </li>

  <li>返回 u.</li>
</ol>

<p>setHours 方法的 length 属性是 4。</p>



<h6>Date.prototype.setUTCHours (hour [, min [, sec [, ms ] ] ] )</h6>

<p>没指定 min 参数时的行为是，仿佛 min 被指定为调用 getUTCMinutes() 的结果一样。</p>

<p>没指定 sec 参数时的行为是，仿佛 ms 被指定为调用 getUTCSeconds() 的结果一样。</p>

<p>没指定 ms 参数时的行为是，仿佛 ms 被指定为调用 getUTCMilliseconds() 的结果一样。</p>

<ol>
  <li>令 t 为 this 时间值 . </li>

  <li>令 h 为 ToNumber(hour). </li>

  <li>如果没指定 min , 则令 m 为 MinFromTime(t); 否则 , 令 m 为 ToNumber(min). </li>

  <li>如果没指定 sec , 则令 s 为 SecFromTime(t); 否则 , 令 s 为 ToNumber(sec). </li>

  <li>如果没指定 ms , 则令 milli 为 msFromTime(t); 否则 , 令 milli 为 ToNumber(ms). </li>

  <li>令 date 为 MakeDate(Day(t), MakeTime(h, m, s, milli)). </li>

  <li>令 v 为 TimeClip(date). </li>

  <li>设定 this Date 对象的 [[PrimitiveValue]] 内部属性为 v. </li>

  <li>返回 v.</li>
</ol>

<p>setUTCHours 方法的 length 属性是 4。</p>



<h6>Date.prototype.setDate (date)</h6>

<ol>
  <li>令 t 为 LocalTime(this 时间值 ) 的结果 . </li>

  <li>令 dt 为 ToNumber(date). </li>

  <li>令 newDate 为 MakeDate(MakeDay(YearFromTime(t), MonthFromTime(t), dt), TimeWithinDay(t)). </li>

  <li>令 u 为 TimeClip(UTC(newDate)). </li>

  <li>设定 this Date 对象的 [[PrimitiveValue]] 内部属性为 u. </li>

  <li>返回 u.</li>
</ol>


<h6>Date.prototype.setUTCDate (date)</h6>

<ol>
  <li>令 t 为 this 时间值 . </li>

  <li>令 dt 为 ToNumber(date). </li>

  <li>令 newDate 为 MakeDate(MakeDay(YearFromTime(t), MonthFromTime(t), dt), TimeWithinDay(t)). </li>

  <li>令 v 为 TimeClip(newDate). </li>

  <li>设定 this Date 对象的 [[PrimitiveValue]] 内部属性为 v. </li>

  <li>返回 v.</li>
</ol>


<h6>Date.prototype.setMonth (month [, date ] )</h6>

<p>没指定 date 参数时的行为是，仿佛 ms 被指定为调用 getDate() 的结果一样。</p>

<ol>
  <li>令 t 为 LocalTime(this 时间值 ) 的结果 . </li>

  <li>令 m 为 ToNumber(month). </li>

  <li>如果没指定 date , 则令 dt 为 DateFromTime(t); 否则 , 令 dt 为 ToNumber(date). </li>

  <li>令 newDate 为 MakeDate(MakeDay(YearFromTime(t), m, dt), TimeWithinDay(t)). </li>

  <li>令 u 为 TimeClip(UTC(newDate)). </li>

  <li>设定 this Date 对象的 [[PrimitiveValue]] 内部属性为 u. </li>

  <li>返回 u.</li>
</ol>

<p>setMonth 方法的 length 属性是 2。</p>



<h6>Date.prototype.setUTCMonth (month [, date ] )</h6>

<p>没指定 date 参数时的行为是，仿佛 ms 被指定为调用 getUTCDate() 的结果一样。</p>

<ol>
  <li>令 t 为 this 时间值 . </li>

  <li>令 m 为 ToNumber(month). </li>

  <li>如果没指定 date , 则令 dt 为 DateFromTime(t); 否则 , 令 dt 为 ToNumber(date). </li>

  <li>令 newDate 为 MakeDate(MakeDay(YearFromTime(t), m, dt), TimeWithinDay(t)). </li>

  <li>令 v 为 TimeClip(newDate). </li>

  <li>设定 this Date 对象的 [[PrimitiveValue]] 内部属性为 v. </li>

  <li>返回 v.</li>
</ol>

<p>setUTCMonth 方法的 length 属性是 2。</p>



<h6>Date.prototype.setFullYear (year [, month [, date ] ] )</h6>

<p>没指定 month 参数时的行为是，仿佛 ms 被指定为调用 getMonth() 的结果一样。</p>

<p>没指定 date 参数时的行为是，仿佛 ms 被指定为调用 getDate() 的结果一样。</p>

<ol>
  <li>令 t 为 LocalTime(this 时间值 ) 的结果 ; 但如果 this 时间值是 NaN, 则令 t 为 +0. </li>

  <li>令 y 为 ToNumber(year). </li>

  <li>如果没指定 month , 则令 m 为 MonthFromTime(t); 否则 , 令 m 为 ToNumber(month). </li>

  <li>如果没指定 date , 则令 dt 为 DateFromTime(t); 否则 , 令 dt 为 ToNumber(date). </li>

  <li>令 newDate 为 MakeDate(MakeDay(y, m, dt), TimeWithinDay(t)). </li>

  <li>令 u 为 TimeClip(UTC(newDate)). </li>

  <li>设定 this Date 对象的 [[PrimitiveValue]] 内部属性为 u. </li>

  <li>返回 u.</li>
</ol>

<p>setFullYear 方法的 length 属性是 3。</p>



<h6>Date.prototype.setUTCFullYear (year [, month [, date ] ] )</h6>

<p>没指定 month 参数时的行为是，仿佛 ms 被指定为调用 getUTCMonth() 的结果一样。</p>

<p>没指定 date 参数时的行为是，仿佛 ms 被指定为调用 getUTCDate() 的结果一样。</p>

<ol>
  <li>令 t 为 this 时间值 ; 但如果 this 时间值是 NaN, 则令 t 为 +0. </li>

  <li>令 y 为 ToNumber(year). </li>

  <li>如果没指定 month , 则令 m 为 MonthFromTime(t); 否则 , 令 m 为 ToNumber(month). </li>

  <li>如果没指定 date , 则令 dt 为 DateFromTime(t); 否则 , 令 dt 为 ToNumber(date). </li>

  <li>令 newDate 为 MakeDate(MakeDay(y, m, dt), TimeWithinDay(t)). </li>

  <li>令 v 为 TimeClip(newDate). </li>

  <li>设定 this Date 对象的 [[PrimitiveValue]] 内部属性为 v. </li>

  <li>返回 v.</li>
</ol>

<p>setUTCFullYear 方法的 length 属性是 3。</p>



<h6>Date.prototype.toUTCString ( )</h6>

<p>此函数返回一个字符串值。字符串中内容是依赖于实现的，但目的是用一种方便，人类可读的形式表示 UTC 时间。</p>

<p>注： 此函数的目的是为日期时间产生一个比 15.9.1.15 指定的格式更易读的字符串表示。没必要选择明确的或易于机器解析的格式。如果一个实现没有一个首选的人类可读格式，建议使用 15.9.1.15 定义的格式，但用空格而不是“T”分割日期和时间元素。</p>



<h6>Date.prototype.toISOString ( )</h6>

<p>此函数返回一个代表 --this Date 对象表示的时间的实例 -- 的字符串。字符串的格式是 15.9.1.15 定义的日期时间字符串格式。字符串中包含所有的字段。字符串表示的时区总是 UTC，用后缀 Z 标记。如果 this 对象的时间值不是有限的数字值，抛出一个 RangeError 异常。</p>



<h6>Date.prototype.toJSON ( key )</h6>

<p>此函数为 JSON.stringify (15.12.3) 提供 Date 对象的一个字符串表示。</p>

<p>当用参数 key 调用 toJSON 方法，采用以下步骤：</p>

<ol>
  <li>令 O 为 以 this 值为参数调用 toObject 的结果。 </li>

  <li>令 tv 为 ToPrimitive(O, hint Number). </li>

  <li>如果 tv 是一个数字值且不是有限的 , 返回 null. </li>

  <li>令 toISO 为以 &quot;toISOString&quot; 为参数调用 O 的 [[Get]] 内部方法的结果。 </li>

  <li>如果 IsCallable(toISO) 是 false, 抛出一个 TypeError 异常 . </li>

  <li>O 作为以 this 值并用空参数列表调用 toISO 的 [[Call]] 内部方法，返回结果。</li>
</ol>

<p>注：1. 参数是被忽略的。</p>

<p>注：2. toJSON 函数是故意设计成通用的；它不需要其 this 值必须是一个 Date 对象。因此，它可以作为方法转移到其他类型的对象上。但转移到的对象必须有 toISOString 方法。对象可自由使用参数 key 来过滤字符串化的方式。</p>



<h5>Date 实例的属性</h5>

<p>Date 实例从 Date 原型对象继承属性，Date 实例的 [[Class]] 内部属性值是 &quot;Date&quot;。Date 实例还有一个 [[PrimitiveValue]] 内部属性。</p>

<p>[[PrimitiveValue]] 内部属性是代表 this Date 对象的时间值。</p>



<h4>RegExp ( 正则表达式 ) 对象</h4>

<p>一个 RegExp 对象包含一个正则表达式和关联的标志。</p>

<p>注： 正则表达式的格式和功能是以 Perl 5 程序语言的正则表达式设施为蓝本的。</p>



<h5>模式</h5>

<p>RegExp 构造器对输入模式字符串应用以下文法。如果文法无法将字符串解释为 Pattern 的一个展开形式，则发生错误。</p>

<p>语法：</p>

<pre> Pattern ::
   Disjunction</pre>

<pre> Disjunction ::
   Alternative
   Alternative | Disjunction</pre>

<pre> Alternative ::
   [empty]
   Alternative Term</pre>

<pre> Term ::
   Assertion
   Atom
   Atom Quantifier</pre>

<pre> Assertion ::
   ^ 
   $ 
   \ b 
   \ B
   ( ? = Disjunction ) 
   ( ? ! Disjunction )</pre>

<pre> Quantifier ::
   QuantifierPrefix
   QuantifierPrefix ?</pre>

<pre> QuantifierPrefix ::
   *
   +&#160; ? 
   { DecimalDigits } 
   { DecimalDigits , } 
   { DecimalDigits , DecimalDigits }</pre>

<pre> Atom ::
   PatternCharacter
   .
   \ AtomEscape
   CharacterClass
   ( Disjunction ) 
   ( ? : Disjunction )</pre>

<pre> PatternCharacter :: SourceCharacter but not any of: 
   ^ $ \ . * + ? ( ) [ ] { } |</pre>

<pre> AtomEscape ::
   DecimalEscape
   CharacterEscape
   CharacterClassEscape</pre>

<pre> CharacterEscape ::
   ControlEscape
   c ControlLetter
   HexEscapeSequence
   UnicodeEscapeSequence
   IdentityEscape</pre>

<pre> ControlEscape :: one of
   f n r t v</pre>

<pre> ControlLetter :: one of
   a b c d e f g h i j k l m n o p q r s t u v w x y z
   A B C D E F G H I J K L M N O P Q R S T U V W X Y Z</pre>

<pre> IdentityEscape ::
   SourceCharacter but not IdentifierPart
   &lt;ZWJ&gt;
   &lt;ZWNJ&gt;</pre>

<pre> DecimalEscape ::
   DecimalIntegerLiteral [lookahead ∉ DecimalDigit]
   </pre><pre>CharacterClassEscape :: one of
   d D s S w W</pre>

<pre> CharacterClass ::
   [ [lookahead ∉ {^}] ClassRanges ] 
   [ ^ ClassRanges ]</pre>

<pre> ClassRanges ::
   [empty]
   NonemptyClassRanges</pre>

<pre> NonemptyClassRanges ::
   ClassAtom
   ClassAtom NonemptyClassRangesNoDash
   ClassAtom - ClassAtom ClassRanges</pre>

<pre> NonemptyClassRangesNoDash ::
   ClassAtom
   ClassAtomNoDash NonemptyClassRangesNoDash
   ClassAtomNoDash - ClassAtom ClassRanges</pre>

<pre> ClassAtom ::
   - 
   ClassAtomNoDash</pre>

<pre> ClassAtomNoDash ::
   SourceCharacter but not one of \ or ] or - 
   \ ClassEscape</pre>

<pre> ClassEscape ::
   DecimalEscape
   b 
   CharacterEscape
   CharacterClassEscape</pre>


<h5>模式语义</h5>

<p>使用下面描述的过程来将一个正则表达式模式转换为一个内部程序。实现使用比下面列出的算法跟高效的算法是被鼓励的，只要结果是相同的。内部程序用作 RegExp 对象的 [[Match]] 内部属性的值。</p>



<h6>表示法</h6>

<p>后面的描述用到以下变量：</p>

<ul>
  <li>input，是正则表达式模式要匹配的字符串。符号 input[n] 表示 input 的第 n 个字符，这里的 n 可以是 0( 包括 ) 和 InputLength( 不包括 ) 之间的。 </li>

  <li>InputLength，是 input 字符串里的字符数目。 </li>

  <li>NcapturingParens，是在模式中左捕获括号的总数 ( 即，Atom :: ( Disjunction ) 产生式被展开的总次数 )。一个左捕获括号是匹配产生式 Atom :: ( Disjunction ) 中的 终结符 <b>(</b> 的任意 <b>(</b> 模式字符。 </li>

  <li>IgnoreCase，是 RegExp 对象的 ignoreCase 属性的设定值。 </li>

  <li>Multiline，是 RegExp 对象的 multiline 属性的设定值。</li>
</ul>

<p>此外，后面的描述用到以下内部数据结构：</p>

<ul>
  <li>CharSet，是字符的一个数学上的集合。 </li>

  <li>State，是一个有序对 (endIndex, captures) ，这里 endIndex 是一个整数，captures 是有 NcapturingParens 个值的内部数组。 States 用来表示正则表达式匹配算法里的局部匹配状态。endIndex 是到目前为止模式匹配的最后一个输入字符的索引值加上一，而 captures 持有捕获括号的捕获结果。captures 的第 n 个元素是一个代表第 n 个捕获括号对捕获值的字符串，或如果第 n 个捕获括号对未能达到目的，captures 的第 n 个元素是 undefined。由于回溯，很多 States 可能在匹配过程中的任何时候被使用。 </li>

  <li>MatchResult，值为 State 或表示匹配失败特殊 token--failure。 </li>

  <li>Continuation 程序，是一个内部闭包（即，一些参数已经绑定了值的内部程序），它用一个 State 参数返回一个 MatchResult 结果。 如果一个内部闭包引用的变量是绑定在创建这个闭包的函数里 , 则闭包使用在创建闭包时的这些变量值。Continuation 尝试从其 State 参数给定的中间状态开始用模式的其余部分（由闭包的已绑定参数指定）匹配输入字符串。如果匹配成功，Continuation 返回最终的 State；如果匹配失败，Continuation 返回 failure。 </li>

  <li>Matcher 程序，是一个需要两个参数 -- 一个 State 和一个 Continuation -- 的内部闭包，它返回一个 MatchResult 结果。 Matcher 尝试从其 State 参数给定的中间状态开始用模式的一个中间子模式（由闭包的已绑定参数指定）匹配输入字符串。Continuation 参数是去匹配模式中剩余部分的闭包。用模式的子模式匹配之后获得一个新 State，之后 Matcher 用新 State 去调用 Continuation 来测试模式的剩余部分是否能匹配成功。如果匹配成功，matcher 返回 Continuation 返回的 State；如果匹配失败，Matcher 尝试用不同的可选位置重复调用 Continuation，直到 Continuation 匹配成功或用尽所有的可选位置。 </li>

  <li>AssertionTester 程序，是需要一个 State 参数并返回一个布尔结果的内部闭包。 AssertionTester 测试输入字符串的当前位置是否满足一个特定条件 ( 由闭包的已绑定参数指定 ) ，如果匹配了条件，返回 true；如果不匹配，返回 false。 </li>

  <li>EscapeValue，是一个字符或一个整数。EscapeValue 用来表示 DecimalEscape 转移序列的解释结果：一个字符 ch 在转义序列里时，它被解释为字符 ch；而一个整数 n 在转义序列里时，它被解释为对第 n 个捕获括号组的反响引用。</li>
</ul>


<h6>模式（Pattern）</h6>

<p>产生式 Pattern :: Disjunction 按照以下方式解释执行 :</p>

<ol>
  <li>解释执行 Disjunction ，获得一个 Matcher m. </li>

  <li>返回一个需要两个参数的内部闭包，一个字符串 str 和一个整数 index, 执行方式如下 : 
    <ol>
      <li>令 Input 为给定的字符串 str。15.10.2 中的算法都将用到此变量。 </li>

      <li>令 InputLength 为 Input 的长度。15.10.2 中的算法都将用到此变量。 </li>

      <li>令 c 为 一个 Continuation ，它始终对它的任何 State 参数都返回成功匹配的 MatchResult。 </li>

      <li>令 cap 为一个有 NcapturingParens 个 undefined 值的内部数组，索引是从 1 到 NcapturingParens。 </li>

      <li>令 x 为 State (index, cap). </li>

      <li>调用 m(x, c)，并返回结果 .</li>
    </ol>
  </li>
</ol>

<p>注： 一个模式解释执行（“编译”）为一个内部程序值。RegExp.prototype.exec 可将这个内部程序应用于一个字符串和字符串的一个偏移位，来确定从这个偏移位开始 , 模式是否能够匹配，如果能匹配，将返回捕获括号的值。15.10.2 中的算法被设计为只在编译一个模式时可抛出一个 SyntaxError 异常；反过来说，一旦模式编译成功，应用编译生成的内部程序在字符串中寻找匹配结果时不可抛出异常（除非是宿主定义的可在任何时候出现的异常，如内存不足）。</p>



<h6>析取（Disjunction）</h6>

<p>产生式 Disjunction :: Alternative 的解释执行，是解释执行 Alternative 来获得 Matcher 并返回这个 Matcher。</p>

<p>产生式 Disjunction :: Alternative | Disjunction 按照以下方式解释执行：</p>

<ol>
  <li>解释执行 Alternative 来获得一个 Matcher m1. </li>

  <li>解释执行 Disjunction 来获得一个 Matcher m2. </li>

  <li>返回一个需要两个参数的内部闭包 Matcher ，参数分别是一个 State x 和一个 Continuation c，此内部闭包的执行方式如下： 
    <ol>
      <li>调用 m1(x, c) 并令 r 为其结果。 </li>

      <li>如果 r 不是 failure, 返回 r. </li>

      <li>调用 m2(x, c) 并返回其结果。</li>
    </ol>
  </li>
</ol>
<div>
<p>注： 正则表达式运算符 | 用来分隔两个选择项。模式首先尝试去匹配左侧的 Alternative( 紧跟着是正则表达式的后续匹配结果 )；如果失败，尝试匹配右侧的 Disjunction（紧跟着是正则表达式的后续匹配结果）。如果左侧的 Alternative，右侧的 Disjunction，还有后续匹配结果，全都有可选的匹配位置，则后续匹配结果的所有可选位置是在左侧的 Alternative 移动到下一个可选位置之前确定的。如果左侧 Alternative 的可选位置被用尽了，右侧 Disjunction 试图替代左侧 Alternative。一个模式中任何被 | 跳过的捕获括号参数 undefined 值还代替字符串。因此，如：</p>

<pre> /a|ab/.exec(&quot;abc&quot;)</pre>

<p>返回结果是 &quot;a&quot;，而不是 &quot;ab&quot;。此外</p>

<pre> /((a)|(ab))((c)|(bc))/.exec(&quot;abc&quot;)</pre>

<p>返回的数组是</p>

<pre> [&quot;abc&quot;, &quot;a&quot;, &quot;a&quot;, undefined, &quot;bc&quot;, undefined, &quot;bc&quot;]</pre>

<p>而不是</p>

<pre> [&quot;abc&quot;, &quot;ab&quot;, undefined, &quot;ab&quot;, &quot;c&quot;, &quot;c&quot;, undefined]</pre>
</div>


<h6>选择项（Alternative）</h6>

<p>产生式 Alternative :: [empty] 解释执行返回一个 Matcher，它需要两个参数，一个 State x 和 一个 Continuation c，并返回调用 c(x) 的结果。</p>

<p>产生式 Alternative :: Alternative Term 按照如下方式解释执行：</p>

<ol>
  <li>解释执行 Alternative 来获得一个 Matcher m1. </li>

  <li>解释执行 Term 来获得一个 Matcher m2. </li>

  <li>返回一个内部闭包 Matcher，它需要两个参数，一个 State x 和一个 Continuation c, 执行方式如下 : 
    <ol>
      <li>创建一个 Continuation d ，它需要一个 State 参数 y ，返回调用 m2(y, c) 的结果 . </li>

      <li>调用 m1(x, d) 并返回结果 .</li>
    </ol>
  </li>
</ol>

<p>注： 连续的 Term 试着同时去匹配连续输入字符串的连续部分。如果左侧的 Alternative，右侧的 Term，还有后续匹配结果，全都有可选的匹配位置，则后续匹配结果的所有可选位置是在右侧的 Term 移动到下一个可选位置之前确定的，并且则右侧的 Term 的所有可选位置是在左侧的 Alternative 移动到下一个可选位置之前确定的。</p>



<h6>匹配项（Term）</h6>

<p>产生式 Term :: Assertion 解释执行，返回一个需要两个参数 State x 和 Continuation c 的内部闭包 Matcher，它的执行方式如下：</p>

<ol>
  <li>解释执行 Assertion 来获得一个 AssertionTester t. </li>

  <li>调用 t(x) 并令 r 为调用结果布尔值 . </li>

  <li>如果 r 是 false, 返回 failure. </li>

  <li>调用 c(x) 并返回结果 .</li>
</ol>

<p>产生式 Term :: Atom 的解释执行方式是，解释执行 Atom 来获得一个 Matcher 并返回这个 Matcher。</p>

<p>产生式 Term :: Atom Quantifier 的解释执行方式如下 :</p>

<ol>
  <li>解释执行 Atom 来获得一个 Matcher m. </li>

  <li>解释执行 Quantifier 来获得三个结果值：一个整数 min, 一个整数 ( 或 ∞) max, 和一个布尔值 greedy. </li>

  <li>如果 max 是有限的 且小于 min, 则抛出一个 SyntaxError 异常 . </li>

  <li>令 parenIndex 为整个正则表达式中在此产生式 Term 展开形式左侧出现的左匹配括号的数目。这是此产生式 Term 前面展开的 Atom :: ( Disjunction ) 产生式总数与此 Term 里面的 Atom :: ( Disjunction ) 产生式总数之和。 </li>

  <li>令 parenCount 为在展开的 Atom 产生式里的左捕获括号数目。这是 Atom 产生式里面 Atom :: ( Disjunction ) 产生式的总数。 </li>

  <li>返回一个需要两个参数 State x 和 Continuation c 的内部闭包 Matcher，执行方式如下 : 
    <ol>
      <li>调用 RepeatMatcher(m, min, max, greedy, x, c, parenIndex, parenCount) ，并返回结果 .</li>
    </ol>
  </li>
</ol>

<p>抽象操作 RepeatMatcher 需要八个参数，一个 Matcher m, 一个整数 min, 一个整数 ( 或 ∞) max, 一个布尔值 greedy, 一个 State x, 一个 Continuation c, 一个整数 parenIndex, 一个整数 parenCount, 执行方式如下 :</p>

<ol>
  <li>如果 max 是零 , 则调用 c(x) ，并返回结果 . </li>

  <li>创建需要一个 State 参数 y 的内部 Continuation 闭包 d ，执行方式如下 : 
    <ol>
      <li>如果 min 是零 且 y 的 endIndex 等于 x 的 endIndex, 则返回 failure. </li>

      <li>如果 min 是零，则令 min2 为零 ; 否则令 min2 为 min–1. </li>

      <li>如果 max 是 ∞, 则令 max2 为 ∞; 否则令 max2 为 max–1. </li>

      <li>调用 RepeatMatcher(m, min2, max2, greedy, y, c, parenIndex, parenCount) ，并返回结果 .</li>
    </ol>
  </li>

  <li>令 cap 为 x 的捕获内部数组的一个拷贝。 </li>

  <li>对所有满足条件 parenIndex &lt; k 且 k ≤ parenIndex+parenCount 的整数 k，设定 cap[k] 为 undefined。 </li>

  <li>令 e 为 x 的 endIndex. </li>

  <li>令 xr 为 State 值 (e, cap). </li>

  <li>如果 min 不是零 , 则调用 m(xr, d)，并返回结果 . </li>

  <li>如果 greedy 是 false, 则 
    <ol>
      <li>令 z 为调用 c(x) 的结果 . </li>

      <li>如果 z 不是 failure, 返回 z. </li>

      <li>调用 m(xr, d)，并返回结果 .</li>
    </ol>
  </li>

  <li>令 z 为调用 m(xr, d) 的结果 . </li>

  <li>如果 z 不是 failure, 返回 z. </li>

  <li>调用 c(x) ，并返回结果 .</li>
</ol>

<div>NOTE 1 An Atom followed by a Quantifier is repeated the number of times specified by the Quantifier. A Quantifier can be non-greedy, in which case the Atom pattern is repeated as few times as possible while still matching the sequel, or it can be greedy, in which case the Atom pattern is repeated as many times as possible while still matching the sequel. The Atom pattern is repeated rather than the input String that it matches, so different repetitions of the Atom can match different input substrings.
</div>
<div>NOTE 2 If the Atom and the sequel of the regular expression all have choice points, the Atom is first matched as many (or as few, if non-greedy) times as possible. All choices in the sequel are tried before moving on to the next choice in the last repetition of Atom. All choices in the last (nth) repetition of Atom are tried before moving on to the next choice in the next-to-last (n–1)st repetition of Atom; at which point it may turn out that more or fewer repetitions of Atom are now possible; these are exhausted (again, starting with either as few or as many as possible) before moving on to the next choice in the (n-1)st repetition of Atom and so on.
Compare

/a[a-z]{2,4}/.exec("abcdefghi")
which returns "abcde" with

/a[a-z]{2,4}?/.exec("abcdefghi")
which returns "abc".

Consider also

/(aa|aabaac|ba|b|c)*/.exec("aabaac")
which, by the choice point ordering above, returns the array

["aaba", "ba"]
and not any of:

["aabaac", "aabaac"]
["aabaac", "c"]
The above ordering of choice points can be used to write a regular expression that calculates the greatest common divisor of two numbers (represented in unary notation). The following example calculates the gcd of 10 and 15:

"aaaaaaaaaa,aaaaaaaaaaaaaaa".replace(/^(a+)\1*,\1+$/,"$1")
</div>

<p>which returns the gcd in unary notation "aaaaa".</p>

<div>NOTE 3 Step 4 of the RepeatMatcher clears Atom's captures each time Atom is repeated. We can see its behaviour in the regular expression

/(z)((a+)?(b+)?(c))*/.exec("zaacbbbcac")
which returns the array

["zaacbbbcac", "z", "ac", "a", undefined, "c"]
and not

["zaacbbbcac", "z", "ac", "a", "bbb", "c"]</div>

<p>because each iteration of the outermost * clears all captured Strings contained in the quantified Atom, which in this case includes capture Strings numbered 2, 3, 4, and 5.</p>

<div>NOTE 4 Step 1 of the RepeatMatcher's d closure states that, once the minimum number of repetitions has been satisfied, any more expansions of Atom that match the empty String are not considered for further repetitions. This prevents the regular expression engine from falling into an infinite loop on patterns such as:

/(a*)*/.exec("b")
or the slightly more complicated:

/(a*)b\1+/.exec("baaaac")
which returns the array

["b", ""]</div>

<h6>Assertion</h6>

<p>产生式<i>Assertion</i> :: ^ 解释执行返回一个 AssertionTester ， 它需要1个参数 State x，并按如下算法执行：</p>

<ol>
  <li>使 e 为 x的 <i>endIndex</i></li>

  <li>若 e = 0， 返回 true </li>

  <li>若 <i>Multiline</i> 为 false，返回false </li>

  <li>若 Input[e - 1] 的字符为 LineTerminator，返回 true </li>

  <li>返回false</li>
</ol>

<p>产生式<i>Assertion</i> :: $ 解释执行返回一个 AssertionTester ， 它需要1个参数 State x，并按如下算法执行：</p>

<ol>
  <li>使 e 为 x的 <i>endIndex</i></li>

  <li>若 e = <i>InputLength</i>， 返回 true </li>

  <li>若 <i>Multiline</i> 为 false，返回false </li>

  <li>若 Input[e - 1] 的字符为 LineTerminator，返回 true </li>

  <li>返回false</li>
</ol>

<p>产生式<i>Assertion</i> :: \ b 解释执行返回一个 AssertionTester ， 它需要1个参数 State x，并按如下算法执行：</p>

<ol>
  <li>使 e 为 x的 <i>endIndex</i></li>

  <li>调用IsWordChar(e–1)，返回Boolean值赋给a </li>

  <li>调用IsWordChar(e)，返回Boolean值赋给b </li>

  <li>若 a 为true，b为false，返回true </li>

  <li>若 b 为false，b为true，返回true </li>

  <li>若 Input[e - 1] 的字符为 LineTerminator，返回 true </li>

  <li>返回false</li>
</ol>

<p>产生式<i>Assertion</i> :: \ B 解释执行返回一个 AssertionTester ， 它需要1个参数 State x，并按如下算法执行：</p>

<ol>
  <li>使 e 为 x的 <i>endIndex</i></li>

  <li>调用IsWordChar(e–1)，返回Boolean值赋给a </li>

  <li>调用IsWordChar(e)，返回Boolean值赋给b </li>

  <li>若 a 为true，b为false，返回false </li>

  <li>若 b 为false，b为true，返回false </li>

  <li>若 Input[e - 1] 的字符为 LineTerminator，返回 true </li>

  <li>返回true</li>
</ol>

<p>产生式<i>Assertion</i> :: (? = <i>Disjunction</i>) 按如下算法执行：</p>

<ol>
  <li>执行<i>Disjunction</i> ，得到 <i>Matcher</i> m </li>

  <li>返回一个需要两个参数的内部闭包 <i>Matcher</i> ，参数分别是一个 <i>State</i> x 和一个 <i>Continuation</i> c，此内部闭包的执行方式如下：： 

    <ol>
      <li>使 d 为一个<i>Continuation</i>，它始终对它的任何 <i>State</i> 参数都返回成功匹配的 <i>MatchResult</i></li>

      <li>调用m(x, d)，令r为其结果 </li>

      <li>若r为<i>failure</i>，返回 <i>failure</i></li>

      <li>使y 为 r的<i>State</i></li>

      <li>使cap 为 r的<i>captures</i></li>

      <li>使xe为 r的<i>endIndex</i></li>

      <li>使z为<i> State (xe, cap)</i></li>

      <li>调用c(z)，返回结果</li>
    </ol>
  </li>
</ol>

<p>产生式<i>Assertion</i> :: (? ! <i>Disjunction</i>) 按如下算法执行：</p>

<ol>
  <li>执行<i>Disjunction</i> ，得到 <i>Matcher</i> m </li>

  <li>返回一个需要两个参数的内部闭包 <i>Matcher</i> ，参数分别是一个 <i>State</i> x 和一个 <i>Continuation</i> c，此内部闭包的执行方式如下：： 

    <ol>
      <li>使 d 为一个<i>Continuation</i>，它始终对它的任何 <i>State</i> 参数都返回成功匹配的 <i>MatchResult</i></li>

      <li>调用m(x, d)，令r为其结果 </li>

      <li>若r为<i>failure</i>，返回 <i>failure</i></li>

      <li>调用c(z)，返回结果</li>
    </ol>
  </li>
</ol>

<p>抽象操作 <i>IsWordChar </i>，拥有一个integer类型的参数e，按如下方式执行：</p>

<ol>
  <li>若 e == -1 或 e == InputLength，返回 false </li>

  <li>令 c 为 Input[e] </li>

  <li>若 c 为 以下63个字符，返回 true</li>
</ol>

<pre>  a b c d e f g h i j k l m n o p q r s t u v w x y z 
  A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 
  0 1 2 3 4 5 6 7 8 9 _</pre>

<ol>
  <li>返回 false</li>
</ol>


<h6>Quantifier</h6>

<p>产生式 Quantifier :: QuantifierPrefix 按如下方式执行：</p>

<ol>
  <li>执行 QuantifierPrefix 得到 2个数 min 和 max（或 ∞） </li>

  <li>返回 min，max，true</li>
</ol>

<p>产生式 Quantifier :: QuantifierPrefix ? 按如下方式执行：</p>

<ol>
  <li>执行 QuantifierPrefix 得到 2个数 min 和 max（或 ∞） </li>

  <li>返回 min，max，true</li>
</ol>

<p>产生式 Quantifier :: * 返回 0 和 ∞</p>

<p>产生式 Quantifier :: + 返回 1 和 ∞</p>

<p>产生式 Quantifier :: ? 返回 0 和 1</p>

<p>产生式 Quantifier :: { DecimalDigits } 按如下方式执行：</p>

<ol>
  <li>令 i 为 DecimalDigits 的 <i>MV</i></li>

  <li>返回2个结果 i，i</li>
</ol>

<p>产生式 Quantifier :: { DecimalDigits, } 按如下方式执行：</p>

<ol>
  <li>令 i 为 DecimalDigits 的 <i>MV</i></li>

  <li>返回2个结果 i，∞</li>
</ol>

<p>产生式 Quantifier :: { DecimalDigits, DecimalDigits} 按如下方式执行：</p>

<ol>
  <li>令 i 为 <i>DecimalDigits</i> 的 <i>MV</i></li>

  <li>令 j 为 <i>DecimalDigits</i> 的 <i>MV</i></li>

  <li>返回2个结果 i，j</li>
</ol>


<h6>Atom</h6>

<p>产生式 Atom :: PatternCharacter 执行方式如下：</p>

<ol>
  <li>令 ch 为 <i>PatternCharacter</i>表示的字符 </li>

  <li>令 A 为单元素 <i>CharSet</i>，包含ch </li>

  <li>调用 <i>CharacterSetMatcher</i>(A, false)，返回<i>Matcher</i></li>
</ol>

<p>产生式 Atom :: . 执行方式如下：</p>

<ol>
  <li>令 A为 除去 LineTerminator外的所有字符 </li>

  <li>调用 <i>CharacterSetMatcher</i>(A, false)，返回<i>Matcher</i></li>
</ol>

<p>产生式 Atom :: \ AtomEscape 通过执行 <i>AtomEscape</i> 返回 <i>Matcher</i>。</p>

<p>产生式 Atom :: CharacterClass 执行方式如下：</p>

<ol>
  <li>执行 <i>CharacterClass</i> 得到 CharSet A 和 Boolean invert </li>

  <li>调用 <i>CharacterSetMatcher</i>(A, false)，返回<i>Matcher</i></li>
</ol>

<p>产生式 Atom :: ( Disjunction ) 执行方式如下：</p>

<ol>
  <li>执行 <i>Disjunction</i> 得到 <i>Matcher</i></li>

  <li>令 <i>parenIndex</i> 为 在整个正则表达式中从产生式展开初始化左括号时，当前展开左捕获括号的索引。<i>parenIndex</i> 为在产生式的 Atom 被展开之前，Atom :: ( <i>Disjunction</i> )产生式被展开的次数，加上Atom :: ( <i>Disjunction</i> ) 闭合 这个Atom的次数 </li>

  <li>返回一个内部闭包 Matcher，拥有2个参数：一个 State x 和 Continuation c，执行方式如下： 
    <ol>
      <li>创建内容闭包 Continuation d，参数为State y，并按如下方式执行： 
        <ol>
          <li>令cap为y的capture数组的一个拷贝 </li>

          <li>令xe为x的endIndex </li>

          <li>令ye为y的endIndex </li>

          <li>令s为Input从索引xe（包括）至 ye（不包括）范围的新创建的字符串 </li>

          <li>令s为cap[parenIndex+1] </li>

          <li>令z为 State (ye, cap) </li>

          <li>调用c(z)，返回其结果</li>
        </ol>
      </li>

      <li>执行m(x, d)，返回其结果</li>
    </ol>
  </li>
</ol>

<p>产生式 Atom :: ( ? : Disjunction ) 通过执行Disjunction 得到并返回一个Matcher。</p>

<p>抽象操作 <i>CharacterSetMatcher</i> ，拥有2个参数：一个 CharSet A 和 Boolean invert标志，按如下方式执行：</p>

<ol>
  <li>返回一个内部闭包 Matcher，拥有2个参数：一个 State x 和 Continuation c，执行方式如下： 
    <ol>
      <li>令e为x的endIndex </li>

      <li>若e == InputLength，返回failure </li>

      <li>令ch为字符Input[e] </li>

      <li>令cc为Canonicalize(ch)的结果 </li>

      <li>若invert为false，如果A中不存在a使得Canonicalize(a) == cc，返回failure </li>

      <li>若invert为true，如果A中存在a使得Canonicalize(a) == cc， 返回failure </li>

      <li>令cap为x的内部captures数组 </li>

      <li>令y为 State (e+1, cap) </li>

      <li>调用c(y)，返回结果</li>
    </ol>
  </li>
</ol>

<p>抽象操作 <i>Canonicalize</i>，拥有一个字符参数 ch，按如下方式执行：</p>

<ol>
  <li>若IgnoreCase为false，返回ch </li>

  <li>令u为ch转换为大写后的结果，仿佛通过调用标准内置方法String.prototype.toUpperCase </li>

  <li>若u不含单个字符，返回ch </li>

  <li>令cu为u的字符 </li>

  <li>若ch的<i>code unit value</i>&gt;= 128 且 cu的<i>code unit value</i>&lt;= 128，返回ch </li>

  <li>返回cu</li>
</ol>

<p>注： ( Disjunction ) 的括号 用来组合 Disjunction 模式，并保存匹配结果。该结果可以通过后向引用（一个非零数，前置\），在一个替换字符串中的引用，或者作为正则表达式内部匹配过程的部分结果。使用(?: Disjunction )来避免括号的捕获行为。</p>

<div>
<p><i>注：(? = Disjunction )指定一个零宽正向预查。为了保证匹配成功，其 Disjunction 必须首先能够匹配成功，但在匹配后续字符前，其当前位置会不变。如果 Disjunction 能在当前位置以多种方式匹配，那么只会取第一次匹配的结果。不像其他正则表达式运算符，(?= 内部不会回溯（这个特殊的行为是从Perl继承过来的）。在 Disjunction 含有捕获括号，模式的后续字符包括后向引用时匹配结果会有影响。</i></p>


<p>例如，</p>

<pre>/(?=(a+))/.exec(&quot;baaabac&quot;)</pre>

<p>会匹配第一个b后的空白字符串，得到：</p>

<pre>[&quot;&quot;, &quot;aaa&quot;]</pre>

<p>为了说明预查不会回溯，</p>

<pre>/(?=(a+))a*b\1/.exec(&quot;baaabac&quot;)</pre>

<p>得到：</p>

<pre>[&quot;aba&quot;, &quot;a&quot;]</pre>

<p>而不是：</p>

<pre>[&quot;aaaba&quot;, &quot;a&quot;]</pre></div>

<div>
<p>注： (?! Disjunction ) 指定一个零宽正向否定预查。为了保证匹配成功，其 Disjunction 必须首先能够匹配失败，但在匹配后续字符前，其当前位置会不变。Disjunction 能含有捕获括号，但是对这些捕获分组的后向引用只在Disjunction中有效。在当前模式的其他位置后向引用捕获分组都会返回undefined。因为否定预查必须满足预查失败来保证模式成功匹配。例如，</p>

<pre>/(.*?)a(?!(a+)b\2c)\2(.*)/.exec(&quot;baaabaac&quot;)</pre>



<p>搜索a，其后有n个a，一个b，n个a（\2指定）和一个c。第二个\2位于负向预查模式的外部，因此它匹配undefined，且总是成功的。整个表达式返回一个数组：</p>

<pre>[&quot;baaabaac&quot;, &quot;ba&quot;, undefined, &quot;abaac&quot;]</pre>
</div>

<p>在发生比较前，一次不区分大小写的匹配中所有的字符都会隐式转换为大写。然而，如果某些单个字符在转换为大写时扩展为多个字符，那么该字符会保持原样。当某些非ASCII字符在转换为大写时变成ASCII字符，该字符也会保持原样。这样会阻止Unicode字符（例如\u0131和\u017F）匹配正则表达式 （例如仅匹配ASCII字符的正则表达式/[a z]/i）。而且，如果转换允许，/[^\W]/i会匹配除去i或s外的每一个a，b，......，h。</p>


<h6>AtomEscape</h6>

<p>产生式 AtomEscape :: DecimalEscape 执行方式如下：</p>

<ol>
  <li>执行DecimalEscape得到 EscapeValue E </li>

  <li>如果E为一个字符， 
    <ol>
      <li>令ch为E的字符 </li>

      <li>令A为包含ch字符的单元素字符集CharSet </li>

      <li>调用 CharacterSetMatcher(A, false) 返回Matcher结果</li>
    </ol>
  </li>

  <li>E必须是一个数。令n为该数。 </li>

  <li>如果n=0或n&gt;NCapturingParens，抛出 SyntaxError 异常 </li>

  <li>返回一个内部闭包 Matcher，拥有2个参数：一个 State x 和 Continuation c，执行方式如下： 
    <ol>
      <li>令cap为x的captures内部数组 </li>

      <li>令s为cap[n] </li>

      <li>如果s为undefined，调用c（x），返回结果 </li>

      <li>令e为x的endIndex </li>

      <li>令len为s的length </li>

      <li>令f为e+len </li>

      <li>如果f&gt;InputLength，返回failure </li>

      <li>如果存在位于0（包括）到len（不包括）的整数i使得 Canonicalize(s[i])等于 Canonicalize(Input [e+i])，那么返回failure </li>

      <li>令y为State(f, cap) </li>

      <li>调用c(y)，返回结果</li>
    </ol>
  </li>
</ol>

<p>产生式 AtomEscape :: CharacterEscape 执行方式如下：</p>

<ol>
  <li>执行CharacterEscape 得到一个ch字符 </li>

  <li>令A为包含ch字符的单元素字符集CharSet </li>

  <li>调用 CharacterSetMatcher(A, false) 返回Matcher结果</li>
</ol>

<p>产生式 AtomEscape :: CharacterClassEscape 执行方式如下：</p>

<ol>
  <li>执行CharacterClassEscape 得到一个CharSet A </li>

  <li>调用 CharacterSetMatcher(A, false) 返回Matcher结果</li>
</ol>

<p>注： 格式\后为非零数n的转义序列匹配捕获分组的第n次匹配结果。如果正则表达式少于n个捕获括号，会报错。如果正则表达式大于等于n个捕获括号，由于没有捕获到任何东西，导致第n个捕获分组结果为undefined，那么后向引用总是成功的。</p>



<h6>CharacterEscape</h6>

<p>产生式 CharacterEscape :: ControlEscape 执行返回一个根据表23定义的字符：</p>
<div>
<p>Table 23 - ControlEscape Character Values</p>

<p>ControlEscape
  <br />Code Unit

  <br />Name

  <br />Symbol</p>

<p>t
  <br />\u0009

  <br />horizontal tab

  <br />&lt;HT&gt;</p>

<p>n
  <br />\u000A

  <br />line feed (new line)

  <br />&lt;LF&gt;</p>

<p>v
  <br />\u000B

  <br />vertical tab

  <br />&lt;VT&gt;</p>

<p>f
  <br />\u000C

  <br />form feed

  <br />&lt;FF&gt;</p>

<p>r
  <br />\u000D

  <br />carriage return

  <br />&lt;CR&gt;</p></div>

<p>产生式 CharacterEscape :: c ControlLetter 执行过程如下：</p>

<ol>
  <li>令ch为通过ControlLetter表示的字符 </li>

  <li>令i为ch的code unit value </li>

  <li>令j为i/32的余数 </li>

  <li>返回j</li>
</ol>

<p>产生式 CharacterEscape :: HexEscapeSequence 执行HexEscapeSequence的CV，返回其字符结果。</p>

<p>产生式 CharacterEscape :: UnicodeEscapeSequence 执行UnicodeEscapeSequence的CV，返回其字符结果。</p>

<p>产生式 CharacterEscape :: IdentityEscape执行返回由IdentityEscape表示的字符。</p>



<h6>DecimalEscape</h6>

<p>产生式 DecimalEscape :: DecimalIntegerLiteral [lookahead ∉ DecimalDigit] 按如下方式执行：</p>

<ol>
  <li>令i为DecimalIntegerLiteral的CV值 </li>

  <li>如果i为0，返回包含一个&lt;NUL&gt;字符（Unicode值为0000）的EscapeValue </li>

  <li>返回包含整数i的EscapeValue</li>
</ol>

<p>“the MV of DecimalIntegerLiteral”在7.8.3节定义。</p>

<p>注： 如果\后面是一个数字，且首位为0，那么，该转义序列被认为是一个后向引用。如果n比在整个正则表达式左捕获括号个数大，那么会出错。\0 表示 &lt;NUL&gt;字符，其后不能再有数字。</p>



<h6>CharacterClassEscape</h6>

<p>产生式 CharacterClassEscape :: d执行返回包含0到9之间的十元素字符集。</p>

<p>产生式 CharacterClassEscape :: D执行返回不包括 CharacterClassEscape :: d的字符集。</p>

<p>产生式 CharacterClassEscape :: s执行返回包含 <i>WhiteSpace</i> 或 <i>LineTerminator</i> 产生式右部分字符的字符集。</p>

<p>产生式 CharacterClassEscape :: S执行返回不包括 CharacterClassEscape :: s的字符集。</p>

<p>产生式 CharacterClassEscape :: w执行返回包含如下63个字符的字符集：</p>

<pre>a b c d e f g h i j k l m n o p q r s t u v w x y z 
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 
0 1 2 3 4 5 6 7 8 9 _</pre>

<p>产生式 CharacterClassEscape :: W执行返回不包括CharacterClassEscape :: w的字符集。</p>



<h6>CharacterClass</h6>

<p>产生式 CharacterClass :: [ [lookahead ∉ {^}] ClassRanges ] 通过执行ClassRanges获得并返回这个CharSet和Boolean false。</p>

<p>产生式 CharacterClass :: [ ^ ClassRanges ] 通过执行ClassRanges获得并返回这个CharSet和Boolean true。</p>



<h6>ClassRanges</h6>

<p>产生式 ClassRanges :: [empty]执行返回一个空的<i>CharSet</i>。</p>

<p>产生式 ClassRanges :: NonemptyClassRanges 通过执行 NonemptyClassRanges 获得并返回这个<i>CharSet</i>。</p>



<h6>NonemptyClassRanges</h6>

<p>产生式 NonemptyClassRanges :: ClassAtom 通过执行<i>ClassAtom</i>获得一个<i>CharSet</i>并返回这个<i>CharSet</i>。</p>

<p>产生式 NonemptyClassRanges :: ClassAtom NonemptyClassRangesNoDash 按如下方式执行：</p>

<ol>
  <li>执行 ClassAtom 得到一个CharSet A </li>

  <li>执行 NonemptyClassRangesNoDash 得到一个CharSet B </li>

  <li>返回A与B的并集</li>
</ol>

<p>产生式 NonemptyClassRanges :: ClassAtom - ClassAtom ClassRanges 按如下方式执行：</p>

<ol>
  <li>执行第一个ClassAtom 得到一个CharSet A </li>

  <li>执行第二个ClassAtom 得到一个CharSet B </li>

  <li>执行ClassRanges 得到一个CharSet C </li>

  <li>调用 CharacterRange(A, B)，令D为其结果CharSet </li>

  <li>返回D与C的并集</li>
</ol>

<p>抽象操作 CharacterRange，拥有2个CharSet参数A和B，执行方式如下：</p>

<ol>
  <li>如果A或B为空，抛出SyntaxError异常 </li>

  <li>令a为CharSet A的一个字符 </li>

  <li>令b为CharSet B的一个字符 </li>

  <li>令i为a的<i>code unit value</i></li>

  <li>令j为b的<i>code unit value</i></li>

  <li>如果i&gt;j，抛出SyntaxError异常 </li>

  <li>返回位于在i到j（包括边界）之间的所有字符的字符集</li>
</ol>


<h6>NonemptyClassRangesNoDash</h6>

<p>The production NonemptyClassRangesNoDash :: ClassAtom evaluates by evaluating ClassAtom to obtain a CharSet and returning that CharSet.
</p>
<p>The production NonemptyClassRangesNoDash :: ClassAtomNoDash NonemptyClassRangesNoDash evaluates as follows:
</p>

<p>Evaluate ClassAtomNoDash to obtain a CharSet A.
Evaluate NonemptyClassRangesNoDash to obtain a CharSet B.
Return the union of CharSets A and B.</p>

<p>The production NonemptyClassRangesNoDash :: ClassAtomNoDash - ClassAtom ClassRanges evaluates as follows:
</p>

<p>Evaluate ClassAtomNoDash to obtain a CharSet A.
Evaluate ClassAtom to obtain a CharSet B.
Evaluate ClassRanges to obtain a CharSet C.
Call CharacterRange(A, B) and let D be the resulting CharSet.
Return the union of CharSets D and C.</p>
<p>NOTE 1 ClassRanges can expand into single ClassAtoms and/or ranges of two ClassAtoms separated by dashes. In the latter case the ClassRanges includes all characters between the first ClassAtom and the second ClassAtom, inclusive; an error occurs if either ClassAtom does not represent a single character (for example, if one is \w) or if the first ClassAtom's code unit value is greater than the second ClassAtom's code unit value.
</p>
<p>NOTE 2 Even if the pattern ignores case, the case of the two ends of a range is significant in determining which characters belong to the range. Thus, for example, the pattern /[E-F]/i matches only the letters E, F, e, and f, while the pattern /[E-f]/i matches all upper and lower-case ASCII letters as well as the symbols [, \, ], ^, _, and `.
</p>
<p>NOTE 3 A - character can be treated literally or it can denote a range. It is treated literally if it is the first or last character of ClassRanges, the beginning or end limit of a range specification, or immediately follows a range specification.
</p>

<h6>ClassAtom</h6>

<p>产生式 ClassAtom :: - 执行返回包含单个字符 - 的字符集。</p>

<p>产生式 ClassAtom :: ClassAtomNoDash 通过执行 ClassAtomNoDash 获得并返回这个 CharSet。</p>



<h6>ClassAtomNoDash</h6>

<p>产生式 ClassAtomNoDash :: SourceCharacter 不包括\，]，- 执行返回包含由 SourceCharacter 表示的字符的单元素字符集。</p>

<p>产生式 ClassAtomNoDash :: \ ClassEscape 通过执行ClassEscape 得到并返回这个CharSet。</p>



<h6>ClassEscape</h6>

<p>产生式 ClassEscape :: DecimalEscape 按如下方式执行：</p>

<ol>
  <li>执行 DecimalEscape 得到 EscapeValue E </li>

  <li>如果E不是一个字符，抛出 SyntaxError异常 </li>

  <li>令ch为E的字符 </li>

  <li>返回包含字符ch的单元素CharSet</li>
</ol>

<p>产生式 ClassEscape :: b 执行返回包含一个&lt;BS&gt;字符（Unicode值0008）的字符集。</p>

<p>产生式 ClassEscape :: CharacterEscape 通过执行 CharacterEscape 获得一个字符Charset并返回包含该字符的单元素字符集CharSet。</p>

<p>产生式 ClassEscape :: CharacterClassEscape 通过执行 CharacterClassEscape 获得并返回这个CharSet。</p>

<p>注： ClassAtom 可以使用除\b，\B，后向引用外的转义序列。在CharacterClass中，\b表示退格符。然而，\B和后向引用会报错。同样，在一个ClassAtom中使用后向引用会报错。</p>



<h5>The RegExp Constructor Called as a Function</h5>


<h6>RegExp(pattern, flags)</h6>

<p>如果pattern是一个对象R，其内部属性[[Class]]为 RegExp且flags 为undefined，返回R。否则，调用内置RegExp构造器，通过表达式 new RegExp（pattern，flags）返回由该构造器构造的对象。</p>



<h5>The RegExp Constructor</h5>

<p>当RegExp作为 new 表达式一部分调用时，它是一个构造器，用来初始化一个新创建的对象。</p>



<h6>new RegExp(pattern, flags)</h6>

<p>如果 pattern 是一个对象R，其内部 [[CLASS]] 属性为RegExp，且 flags 为 undefined，那么，令 P 为 pattern 和令 F 为 flags 用来构造 R。如果pattern是一个对象R，其内部[[CLASS]]属性为RegExp，且flags为undefined，那么，抛出TypeError异常。否则，如果pattern为undefined且ToString（pattern），令P为空的字符串；如果flags为undefined且ToString（flags）令F为空字符串。</p>

<p>如果字符P不满足Pattern语义，那么抛出SyntaxError异常。否则，令新构造的对象拥有内部[[Match]]属性，该属性通过执行（编译）字符P作为在15.10.2节描述的Pattern。</p>

<p>如果F含有除“g”,“i”，“m”外的任意字符，或者F中包括出现多次的字符，那么，抛出SyntaxError异常。</p>

<p>如果SyntaxError异常未抛出，那么：</p>

<p>令S为一个字符串，其等价于P表示的Pattern，S中的字符按如下描述进行转义。这样，S可能或者不会与P或者pattern相同；然而，由执行S作为一个Pattern的内部处理程序必须和通过构造对象的内部[[Match]]属性的内部处理程序完全相同。</p>

<p>如果pattern里存在字符/或者\，那么这些字符应该被转义，以确保由“/”，S，“/”构成的的字符串的S值有效，而且F能被解析（在适当的词法上下文中）为一个与构造的正则表达式行为完全相同的 <i>RegularExpressionLiteral</i> 。例如，如果P是“/”，那么S应该为“\/”或“\u002F”，而不是“/”，因为F后的 /// 会被解析为一个 SingleLineComment，而不是一个 RegularExpressionLiteral。 如果P为空字符串，那么该规范定义为令S为“(?:)”。</p>

<p>这个新构造对象的如下属性为数据属性，其特性在15.10.7中定义。各属性的[[Value]]值按如下方式设置：</p>

<p>其source属性置为S。</p>

<p>其global属性置为一个Boolean值。当F含有字符g时，为true，否则，为false。</p>

<p>其ignoreCase属性置为一个Boolean值。当F含有字符i时，为true，否则，为false。</p>

<p>其multiline属性置为一个Boolean值。当F含有字符m时，为true，否则，为false。</p>

<p>其lastIndex属性置为0。</p>

<p>其内部[[Prototype]]属性置为15.10.6中定义的内置RegExp原型对象。</p>

<p>其内部[[Class]]属性置为“RegExp”。</p>

<p>注： 如果pattern为 StringLiteral，一般的转义字符替换发生在被RegExp处理前。如果pattern必须含有RegExp识别的转义字符，那么当构成 StringLiteral的内容时，为了防止被移除\被移除，在 StringLiteral中的任何\必须被转义</p>



<h5>Properties of the RegExp Constructor</h5>

<p>RegExp构造器的[[Prototype]]值为内置Function的原型（15.3.4）。</p>

<p>除了内部的一些属性和length属性（其值为2），RegExp构造器还有如下属性：</p>



<h6>RegExp.prototype</h6>

<p>RegExp.prototype的初始值为RegExp的原型（15.10.6）。</p>

<p>该属性有这些特性： { [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。</p>



<h5>Properties of the RegExp Prototype Object</h5>

<p>RegExp的原型的内部[[Prototype]]属性为Object的原型（15.2.4）。RegExp的原型为其本身的一个普通的正则表达式对象；它的[[Class]]为“RegExp”。RegExp的原型对象的数据式属性的初始值被设置为仿佛由内置RegExp构造器深生成的表达式new RegExp()创建的对象。</p>

<p>RegExp的原型本身没有valueOf属性；然而，该valueOf属性是继承至Object的原型。</p>

<p>在作为RegExp原型对象的属性的如下函数描述中，“this RegExp object”是指函数激活时this对象；如果this值不是一个对象，或者一个其内部[[Class]]属性值不是“RegExp”的对象，那么一个TypeError会抛出。</p>



<h6>RegExp.prototype.constructor</h6>

<p>RegExp.prototype.constructor 的初始值为内置 RegExp 构造器。</p>



<h6>RegExp.prototype.exec(string)</h6>

<p>Performs a regular expression match of string against the regular expression and returns an Array object containing the results of the match, or null if string did not match.
</p>
<p>The String ToString(string) is searched for an occurrence of the regular expression pattern as follows:
</p>
<pre>Let R be this RegExp object.
Let S be the value of ToString(string).
Let length be the length of S.
Let lastIndex be the result of calling the [[Get]] internal method of R with argument "lastIndex".
Let i be the value of ToInteger(lastIndex).
Let global be the result of calling the [[Get]] internal method of R with argument "global".
If global is false, then let i = 0.
Let matchSucceeded be false.
Repeat, while matchSucceeded is false
If i < 0 or i > length, then
Call the [[Put]] internal method of R with arguments "lastIndex", 0, and true.
Return null.
Call the [[Match]] internal method of R with arguments S and i.
If [[Match]] returned failure, then
Let i = i+1.
else
Let r be the State result of the call to [[Match]].
Set matchSucceeded to true.
Let e be r's endIndex value.
If global is true,
Call the [[Put]] internal method of R with arguments "lastIndex", e, and true.
Let n be the length of r's captures array. (This is the same value as 15.10.2.1's NCapturingParens.)
Let A be a new array created as if by the expression new Array() where Array is the standard built-in constructor with that name.
Let matchIndex be i.
Call the [[DefineOwnProperty]] internal method of A with arguments "index", Property Descriptor {[[Value]]: matchIndex, [[Writable]: true, [[Enumerable]]: true, [[Configurable]]: true}, and true.
Call the [[DefineOwnProperty]] internal method of A with arguments "input", Property Descriptor {[[Value]]: S, [[Writable]: true, [[Enumerable]]: true, [[Configurable]]: true}, and true.
Call the [[DefineOwnProperty]] internal method of A with arguments "length", Property Descriptor {[[Value]]: n + 1}, and true.
Let matchedSubstr be the matched substring (i.e. the portion of S between offset i inclusive and offset e exclusive).
Call the [[DefineOwnProperty]] internal method of A with arguments "0", Property Descriptor {[[Value]]: matchedSubstr, [[Writable]: true, [[Enumerable]]: true, [[Configurable]]: true}, and true.
For each integer i such that i > 0 and i ≤ n
Let captureI be ith element of r's captures array.
Call the [[DefineOwnProperty]] internal method of A with arguments ToString(i), Property Descriptor {[[Value]]: captureI, [[Writable]: true, [[Enumerable]]: true, [[Configurable]]: true}, and true.
Return A.</pre>

<h6>RegExp.prototype.test(string)</h6>

<p>采用如下步骤：</p>

<ol>
  <li>令match为在这个RegExp对象上使用string作为参数执行 RegExp.prototype.exec (15.10.6.2) 的结果。</li>
  <li>如果match不为null，返回true；否则返回false。</li>
</ol>


<h6>RegExp.prototype.toString()</h6>

<p>返回一个String，由“/”，RegExp对象的source属性值，“/”与“g”（如果global属性为true），“i”（如果ignoreCase为true），“m”（如果multiline为true）通过连接组成。</p>

<p>注： 如果返回的字符串包含一个RegularExpressionLiteral，那么该RegularExpressionLiteral用同样的方式解释执行。</p>



<h5>Properties of RegExp Instances</h5>

<p>RegExp实例继承至RegExp原型对象，其[[CLASS]]内部属性值为“RegExp”。RegExp实例也拥有一个[[Match]]内部属性和一个length属性。</p>

<p>内部属性[[Match]]的值是正则表达式对象的Pattern的依赖实现的表示形式。</p>

<p>RegExp实例还有如下属性。</p>



<h6>source</h6>

<p>source属性为构成正则表达式Pattern的字符串。该属性拥有这些特性{ [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。</p>



<h6>global</h6>

<p>global属性是一Boolean值，表示正则表达式flags是否有“g”。该属性拥有这些特性{ [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。</p>



<h6>ignoreCase</h6>

<p>ignoreCase属性是一Boolean值，表示正则表达式flags是否有“i”。该属性拥有这些特性{ [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。</p>



<h6>multiline</h6>

<p>multiline属性是一Boolean值，表示正则表达式flags是否有“m”。该属性拥有这些特性{ [[Writable]]: false, [[Enumerable]]: false, [[Configurable]]: false }。</p>



<h6>lastIndex</h6>

<p>lastIndex属性指定从何处开始下次匹配的一个字符串类型的位置索引。当需要时该值会转换为一个整型数。该属性拥有这些特性{ [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }。</p>

<p>注： 不同于其他RegExp实例内置属性，lastIndex是可写的。</p>



<h4>Error Objects</h4>

<p>Error对象的实例在运行时遇到错误的情况下会被当做异常抛出。Error对象也可以作为用户自定义异常类的基对象。</p>



<h5>The Error Constructor Called as a Function</h5>

<p>当Error被作为函数而不是构造器调用时，它创建并初始化一个新的Error对象。这样函数调用Error(…)与同样参数的对象创建表达式new Error(…)是等效的。</p>



<h6>Error (message)</h6>

<p>新构造的对象内部属性<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Prototype&amp;action=edit&amp;redlink=1">Prototype</a>会被设为原本的Error原型对象，也就是Error.prototype的初始值。(15.11.3.1)</p>

<p>新构造的对象内部属性<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Class&amp;action=edit&amp;redlink=1">Class</a>会被设为&quot;Error&quot;。</p>

<p>新构造的对象内部属性<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Extensible&amp;action=edit&amp;redlink=1">Extensible</a>会被设为true。</p>

<p>如果形参message不是undefined，新构造的对象本身属性message则被设为ToString(message)。</p>



<h5>The Error Constructor</h5>

<p>当Error作为new表达式的一部分被调用时，它是一个构造器：它初始化新创建的对象。</p>



<h6>new Error (message)</h6>

<p>新构造的对象内部属性<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Prototype&amp;action=edit&amp;redlink=1">Prototype</a>会被设为原本的Error原型对象，也就是Error.prototype的初始值。(15.11.3.1)</p>

<p>新构造的对象内部属性<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Class&amp;action=edit&amp;redlink=1">Class</a>会被设为&quot;Error&quot;。</p>

<p>新构造的对象内部属性<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Extensible&amp;action=edit&amp;redlink=1">Extensible</a>会被设为true。</p>

<p>如果形参message不是undefined，新构造的对象本身属性message则被设为ToString(message)。</p>



<h5>Properties of the Error Constructor</h5>

<p>Error构造器的内部属性<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Prototype&amp;action=edit&amp;redlink=1">Prototype</a>值为Function原型对象(15.3.4)。</p>

<p>除内部属性和length属性（其值为1）以外，Error构造器还有以下属性：</p>



<h6>Error.prototype</h6>

<p>Error.prototype的初始值为Error原型对象(15.11.4)。</p>

<p>此属性有以下特性： { <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Writable&amp;action=edit&amp;redlink=1">Writable</a>: false, <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Enumerable&amp;action=edit&amp;redlink=1">Enumerable</a>: false, <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Configurable&amp;action=edit&amp;redlink=1">Configurable</a>: false }。</p>



<h5>Properties of the Error Prototype Object</h5>

<p>Error原型对象本身是一个Error对象（其<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Class&amp;action=edit&amp;redlink=1">Class</a>为&quot;Error&quot;）。</p>

<p>Error原型对象的内部属性<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Prototype&amp;action=edit&amp;redlink=1">Prototype</a>为标准内置的Object原型对象(15.2.4)。</p>



<h6>Error.prototype.constructor</h6>

<p>Error.prototype.constructor初始值为内置的Error构造器。</p>



<h6>Error.prototype.name</h6>

<p>rror.prototype.name初始值为&quot;Error&quot;。</p>



<h6>Error.prototype.message</h6>

<p>Error.prototype.message初始值为空字符串。</p>



<h6>Error.prototype.toString ( )</h6>

<p>执行以下步骤</p>

<ol>
  <li>令o为this值 </li>

  <li>如果Type(O)不是对象，抛出一个TypeError异常。 </li>

  <li>令name为以&quot;name&quot;为参数调用O的<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Get&amp;action=edit&amp;redlink=1">Get</a>内置方法的结果。 </li>

  <li>如果name为undefined, 令name为&quot;Error&quot;;否则令name为ToString(name)。 </li>

  <li>令msg为以&quot;message&quot;为参数调用O的<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Get&amp;action=edit&amp;redlink=1">Get</a>内置方法的结果。 </li>

  <li>如果msg为undefined,令msg为空字符串;否则令msg为ToString(msg)。 </li>

  <li>如果name与msg都是空字符串，返回&quot;Error&quot;。 </li>

  <li>如果name为空字符串，返回msg。 </li>

  <li>如果msg为空字符串，返回name。 </li>

  <li>返回拼接name,&quot;:&quot;,一个空格字符，以及msg的结果。</li>
</ol>


<h5>Error实例的属性</h5>

<p>Error实例从Error原型对象继承属性，且它们的内部属性<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Class&amp;action=edit&amp;redlink=1">class</a>值为&quot;Error&quot;。Error实例没有特殊属性。</p>



<h5>Native Error Types Used in This Standard</h5>

<p>以下原生Error对象之一会在运行时错误发生时被抛出。所有这些对象共享同样的结构，如15.11.7所述。</p>



<h6>EvalError</h6>

<p>本规范现在已经不再使用这个异常，这个对象保留用于跟规范之前版本的兼容性。</p>



<h6>RangeError</h6>

<p>表示一个数值超出了允许的范围，见15.4.2.2, 15.4.5.1, 15.7.4.2, 15.7.4.5, 15.7.4.6, 以及15.7.4.7, 15.9.5.43.</p>



<h6>ReferenceError</h6>

<p>表示一个不正确的引用值被检测到。见8.7.1, 8.7.2, 10.2.1, 10.2.1.1.4, 10.2.1.2.4, 以及 11.13.1</p>



<h6>SyntaxError</h6>

<p>表示一个解析错误发生。见11.1.5, 11.3.1, 11.3.2, 11.4.1, 11.4.4, 11.4.5, 11.13.1, 11.13.2, 12.2.1, 12.10.1, 12.14.1, 13.1, 15.1.2.1, 15.3.2.1, 15.10.2.2, 15.10.2.5, 15.10.2.9, 15.10.2.15, 15.10.2.19, 15.10.4.1, 以及15.12.2</p>



<h6>TypeError</h6>

<p>表示一个操作数的真实类型与期望类型不符。见8.6.2, 8.7.2, 8.10.5, 8.12.5, 8.12.7, 8.12.8, 8.12.9, 9.9, 9.10, 10.2.1, 10.2.1.1.3, 10.6, 11.2.2, 11.2.3, 11.4.1, 11.8.6, 11.8.7, 11.3.1, 13.2, 13.2.3, 15, 15.2.3.2, 15.2.3.3, 15.2.3.4, 15.2.3.5, 15.2.3.6, 15.2.3.7, 15.2.3.8, 15.2.3.9, 15.2.3.10, 15.2.3.11, 15.2.3.12, 15.2.3.13, 15.2.3.14, 15.2.4.3, 15.3.4.2, 15.3.4.3, 15.3.4.4, 15.3.4.5, 15.3.4.5.2, 15.3.4.5.3, 15.3.5, 15.3.5.3, 15.3.5.4, 15.4.4.3, 15.4.4.11, 15.4.4.16, 15.4.4.17, 15.4.4.18, 15.4.4.19, 15.4.4.20, 15.4.4.21, 15.4.4.22, 15.4.5.1, 15.5.4.2, 15.5.4.3, 15.6.4.2, 15.6.4.3, 15.7.4, 15.7.4.2, 15.7.4.4, 15.7.4.8 [?], 15.9.5, 15.9.5.44, 15.10.4.1, 15.10.6, 15.11.4.4 以及 15.12.3</p>



<h6>URIError</h6>

<p>表示全局URI处理函数被以不符合其定义的方式使用。见 15.1.3。</p>



<h5>NativeError对象结构</h5>

<p>当ECMAScript实现探测到一个运行时错误时，它抛出一个15.11.6所定义的NativeError对象的实例。每个这些对象都有如下所述结构，不同仅仅是在name属性中以构造器名称替换掉NativeError，以及原型对象由实现自定义的message属性。</p>

<p>对于每个错误对象，定义中到NativeError的引用应当用15.11.6中具体的对象名替换。</p>



<h6>NativeError Constructors Called as Functions</h6>

<p>当NativeError被作为函数而不是构造器调用时，它创建并初始化一个新的NativeError对象。这样函数调用NativeError(…)与同样参数的对象创建表达式new NativeError(…)是等效的。</p>



<h6>NativeError (message)</h6>

<p>新构造的对象内部属性Prototype会被设为这一错误构造器附带的原型对象。新构造的对象内部属性Class会被设为&quot;Error&quot;。新构造的对象内部属性Extensible会被设为true。</p>

<p>如果形参message不是undefined，新构造的对象本身属性message则被设为ToString(message)。</p>



<h6>The NativeError Constructors</h6>

<p>当NativeError作为new表达式的一部分被调用时，它是一个构造器：它初始化新创建的对象。</p>



<h6>New NativeError (message)</h6>

<p>新构造的对象内部属性Prototype会被设为这一错误构造器附带的原型对象。新构造的对象内部属性Class会被设为&quot;Error&quot;。新构造的对象内部属性Extensible会被设为true。</p>

<p>如果形参message不是undefined，新构造的对象本身属性message则被设为ToString(message)。</p>



<h6>Properties of the NativeError Constructors</h6>

<p>NativeError构造器的内部属性Prototype值为Function原型对象(15.3.4)。</p>

<p>除内部属性和length属性（其值为1）以外，Error构造器还有以下属性：</p>



<h6>NativeError.prototype</h6>

<p>NativeError.prototype的初始值为一个Error(15.11.4)。</p>

<p>此属性有以下特性： { Writable: false, Enumerable: false, Configurable: false }。</p>



<h6>Properties of the NativeError Prototype Objects</h6>

<p>每个NativeError的prototype的初始值为一个Error（其Class为&quot;Error&quot;）。</p>

<p>NativeError原型对象的内部属性Prototype为标准内置的Error对象(15.2.4)。</p>



<h6>NativeError.prototype.constructor</h6>

<p>对于特定的NativeError，Error.prototype.constructor初始值为NativeError构造器本身。</p>



<h6>NativeError.prototype.name</h6>

<p>对于特定的NativeError，Error.prototype.name初始值为构造器的名字。</p>



<h6>NativeError.prototype.message</h6>

<p>对于特定的NativeError，NativeError.prototype.message初始值为空字符串。</p>

<p>NOTE The prototypes for the NativeError constructors do not themselves provide a toString function, but instances of errors will inherit it from the Error prototype object.</p>

<h6>NativeError实例的属性</h6>

<p>NativeError实例从NativeError原型对象继承属性，且它们的内部属性class值为&quot;Error&quot;。Error实例没有特殊属性。</p>



<h4>JSON 对象</h4>

<p>JSON 对象是一个单一的对象，它包含两个函数，parse 和 stringify，是用于解析和构造 JSON 文本的。JSON 数据的交换格式在 RFC4627 里进行了描述。 &lt;<a href="http://www.ietf.org/rfc/rfc4627.txt">http://www.ietf.org/rfc/rfc4627.txt</a>&gt;。本规范里面的 JSON 交换格式会使用 RFC4627 里所描述的，以下两点除外：</p>

<ul>
  <li>ECMAScript JSON 文法中的顶级 JSONText 产生式是由 JSONValue 构成，而不是 RFC4627 中限制成的 JSONObject 或者 JSONArray。 </li>

  <li>确认 JSON.parse 和 JSON.stringify 的实现，它们必须准确的支持本规范描述的交换格式，而不允许对格式进行删除或扩展。这一点要区别于 RFC4627，它允许 JSON 解析器接受 non-JSON 的格式和扩展。</li>
</ul>

<p>JSON 对象内部属性 [[Prototype]] 的值是标准内建的 Object 原型对象（15.2.4）。内部属性 [[Class]] 的值是“JSON”。内部属性 [[Extensible]] 的值设置为 true。</p>

<p>JSON 对象没有内部属性 [[Construct]]；不能把 JSON 对象当作构造器来使用 new 操作符。</p>

<p>JSON 对象没有内部属性 [[Call]]; 不能把 JSON 对象当作函数来调用。</p>



<h5>JSON 语法</h5>

<p>JSON.stringify 会产生一个符合 JSON 语法的字符串。JSON.parse 接受的是一个符合 JSON 语法的字符串。</p>



<h6>JSON 词法</h6>

<p>类似于 ECMAScript 源文本，JSON 是由一系列符合 SourceCharacter 规则的字符构成的。JSON 词法定义的 tokens 使得 JSON 文本类似于 ECMAScript 词法定义的 tokens 得到的 ECMAScript 源文本。JSON 词法仅能识别由 JSONWhiteSpace 产生式得到的空白字符。在语法上，所有非终止符均不是由“JSON”字符开始，而是由 ECMAScript 词法产生式定义的。</p>

<p>语法</p>

<pre>   JSONWhiteSpace ::
       &lt;TAB&gt;
       &lt;CR&gt;
       &lt;LF&gt;
       &lt;SP&gt;</pre>

<pre>   JSONString ::
       &quot; JSONStringCharacters<sub>opt</sub> &quot;</pre>

<pre>   JSONStringCharacters ::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E6%A0%87%E5%87%86_ECMAScript_%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1#JSONStringCharacter">JSONStringCharacter</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E6%A0%87%E5%87%86_ECMAScript_%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1#JSONStringCharacters">JSONStringCharacters</a><sub>opt</sub></pre>

<pre>   JSONStringCharacter ::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E6%A0%87%E5%87%86_ECMAScript_%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1#SourceCharacter">SourceCharacter</a> 但非 双引号 &quot; 或反斜杠 \ 或 U+0000 抑或是 U+001F
       \ <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E6%A0%87%E5%87%86_ECMAScript_%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1#JSONEscapeSequence">JSONEscapeSequence</a></pre>

<pre>   JSONEscapeSequence ::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E6%A0%87%E5%87%86_ECMAScript_%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1#JSONEscapeCharacter">JSONEscapeCharacter</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E6%A0%87%E5%87%86_ECMAScript_%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1#UnicodeEscapeSequence">UnicodeEscapeSequence</a></pre>

<pre>   JSONEscapeCharacter :: 以下之一 
       &quot; / \ b f n r t</pre>

<pre>   JSONNumber ::
       -<sub>opt</sub><a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E6%A0%87%E5%87%86_ECMAScript_%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1#DecimalIntegerLiteral">DecimalIntegerLiteral</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E6%A0%87%E5%87%86_ECMAScript_%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1#JSONFraction">JSONFraction</a><sub>opt</sub> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E6%A0%87%E5%87%86_ECMAScript_%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1#ExponentPart">ExponentPart</a><sub>opt</sub></pre>

<pre>   JSONFraction ::
       . <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E6%A0%87%E5%87%86_ECMAScript_%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1#DecimalDigits">DecimalDigits</a></pre>

<pre>   JSONNullLiteral ::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E6%A0%87%E5%87%86_ECMAScript_%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1#NullLiteral">NullLiteral</a></pre>

<pre>   JSONBooleanLiteral ::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E6%A0%87%E5%87%86_ECMAScript_%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1#BooleanLiteral">BooleanLiteral</a></pre>


<h6>JSON 句法</h6>

<p>根据 JSON 词法定义的 tokens，JSON 句法定义了一个合法的 JSON 文本。语法的目标符号是 JSONText。</p>

<p>语法</p>

<pre>   JSONText :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E6%A0%87%E5%87%86_ECMAScript_%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1#JSONValue">JSONValue</a></pre>

<pre>   JSONValue :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E6%A0%87%E5%87%86_ECMAScript_%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1#JSONNullLiteral">JSONNullLiteral</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E6%A0%87%E5%87%86_ECMAScript_%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1#JSONBooleanLiteral">JSONBooleanLiteral</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E6%A0%87%E5%87%86_ECMAScript_%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1#JSONObject">JSONObject</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E6%A0%87%E5%87%86_ECMAScript_%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1#JSONArray">JSONArray</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E6%A0%87%E5%87%86_ECMAScript_%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1#JSONString">JSONString</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E6%A0%87%E5%87%86_ECMAScript_%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1#JSONNumber">JSONNumber</a></pre>

<pre>   JSONObject :
       { } 
       { <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E6%A0%87%E5%87%86_ECMAScript_%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1#JSONMemberList">JSONMemberList</a> }</pre>

<pre>   JSONMember :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E6%A0%87%E5%87%86_ECMAScript_%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1#JSONString">JSONString</a> : <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E6%A0%87%E5%87%86_ECMAScript_%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1#JSONValue">JSONValue</a></pre>

<pre>   JSONMemberList :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E6%A0%87%E5%87%86_ECMAScript_%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1#JSONMember">JSONMember</a> 
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E6%A0%87%E5%87%86_ECMAScript_%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1#JSONMemberList">JSONMemberList</a> , <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E6%A0%87%E5%87%86_ECMAScript_%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1#JSONMember">JSONMember</a></pre>

<pre>   JSONArray :
       [ ] 
       [ <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E6%A0%87%E5%87%86_ECMAScript_%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1#JSONElementList">JSONElementList</a> ]</pre>

<pre>   JSONElementList :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E6%A0%87%E5%87%86_ECMAScript_%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1#JSONValue">JSONValue</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E6%A0%87%E5%87%86_ECMAScript_%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1#JSONElementList">JSONElementList</a> , <a href="http://www.w3.org/html/ig/zh/wiki/ES5/%E6%A0%87%E5%87%86_ECMAScript_%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1#JSONValue">JSONValue</a></pre>


<h5>parse ( text [ , reviver ] )</h5>

<p>parse函数解析一段JSON文本（JSON格式字符串），生成一个ECMAScript值。JSON格式是ECMAScript直接量 的受限模式。JSON对象可以被理解为ECMAScript对象。JSON数组可以被理解为ECMAScript数组。JSON字符串、数字、布尔值以及null可以被认为是ECMAScript字符串、数字、布尔值以及null。JSON使用受限更多的空白字符集合，并且允许Unicode码点U+2028和U+2029直接出现在JSONString直接量当中而无需使用转义序列。解析流程与11.1.4和11.1.5一样，但是由JSON语法限定。</p>

<p>可选参数reviver是一个接受两个参数的函数（key和value）。它可以过滤和转换结果。它在每个key/value对产生时被调用，它的返回值可以用于替代原本的值。如果它原样返回接收到的，那么结构不会被改变。如果它返回undefined，那么属性会被从结果中删除。</p>

<ol>
  <li>令JText为ToString(text) </li>

  <li>以15.12.1所述语法解析JText。如果JText不能以JSON grammar解析成JSONText，则抛出SyntaxError异常。 </li>

  <li>令unfiltered为按ECMAScript程序（但是用JSONString替换StringLiteral）解析和执行JText的结果。注因JText符合JSON语法，这个结果要么是原始值类型要么是ArrayLiteral或者ObjectLiteral所定义的对象。 </li>

  <li>若IsCallable(reviver)为true则 
    <ol>
      <li>令root为由表达式new Object()创建的新对象，其中Object是以Object为名的标准内置的构造器。 </li>

      <li>以空字符串和属性描述{<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Value&amp;action=edit&amp;redlink=1">Value</a>: unfiltered, <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Writable&amp;action=edit&amp;redlink=1">Writable</a>: true, <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Enumerable&amp;action=edit&amp;redlink=1">Enumerable</a>: true, <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Configurable&amp;action=edit&amp;redlink=1">Configurable</a>: true}以及false为参数调用root的<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=DefineOwnProperty&amp;action=edit&amp;redlink=1">DefineOwnProperty</a>内置方法。 </li>

      <li>返回传入root和空字符串为参数调用抽象操作Walk的结果，抽象操作Walk如下文所定义。</li>
    </ol>
  </li>

  <li>否则，返回unfiltered。</li>
</ol>

<p>抽象操作Walk是一个递归的抽象操作，它接受两个参数：一个持有对象和表示一个该对象的属性名的String。Walk使用最开始被传入parse函数的reviver的值。</p>

<ol>
  <li>令val为以参数name调用hold的<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Get&amp;action=edit&amp;redlink=1">get</a>内部方法的结果。 </li>

  <li>若val为对象，则 
    <ol>
      <li>若val的<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Class&amp;action=edit&amp;redlink=1">Class</a>内部属性为&quot;Array&quot; 

        <ol>
          <li>设I为0 </li>

          <li>令len为以参数&quot;length&quot;调用val的<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Get&amp;action=edit&amp;redlink=1">get</a>内部方法的结果 </li>

          <li>当I&lt;len时重复 
            <ol>
              <li>令newElement为调用抽象操作Walk的结果，传入val和ToString(I)为参数。 </li>

              <li>若newElement为undefined，则 
                <ol>
                  <li>以ToString(I)和false做参数，调用val的内部方法<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Delete&amp;action=edit&amp;redlink=1">Delete</a></li>

                  <li>否则，以ToString(I)，属性描述{<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Value&amp;action=edit&amp;redlink=1">Value</a>: newElement, <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Writable&amp;action=edit&amp;redlink=1">Writable</a>: true, <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Enumerable&amp;action=edit&amp;redlink=1">Enumerable</a>: true, <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Configurable&amp;action=edit&amp;redlink=1">Configurable</a>: true}以及false做参数调用调用val的内部方法<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=DefineOwnProperty&amp;action=edit&amp;redlink=1">DefineOwnProperty</a></li>
                </ol>
              </li>

              <li>对I加1</li>
            </ol>
          </li>
        </ol>
      </li>

      <li>否则 
        <ol>
          <li>令keys为包含val所有的具有<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Enumerable&amp;action=edit&amp;redlink=1">Enumerable</a>特征的属性名String值的内部类型List。字符串的顺序应当与内置函数Object.keys一致。 </li>

          <li>对于keys中的每个字符串P做一下 
            <ol>
              <li>令newElement为调用抽象操作Walk的结果，传入val和P为参数。 </li>

              <li>若newElement为undefined，则 
                <ol>
                  <li>以P和false做参数，调用val的内部方法<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Delete&amp;action=edit&amp;redlink=1">Delete</a></li>

                  <li>否则，以P，属性描述{<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Value&amp;action=edit&amp;redlink=1">Value</a>: newElement, <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Writable&amp;action=edit&amp;redlink=1">Writable</a>: true, <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Enumerable&amp;action=edit&amp;redlink=1">Enumerable</a>: true, <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Configurable&amp;action=edit&amp;redlink=1">Configurable</a>: true}以及false做参数调用调用val的内部方法<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=DefineOwnProperty&amp;action=edit&amp;redlink=1">DefineOwnProperty</a></li>
                </ol>
              </li>
            </ol>
          </li>
        </ol>
      </li>
    </ol>
  </li>

  <li>返回传入holder作为this值以及以name和val构成的参数列表调用reviver的<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Call&amp;action=edit&amp;redlink=1">Call</a>内部属性的结果。</li>
</ol>

<p>实现不允许更改JSON.parse的实现以扩展JSON语法。如果一个实现想要支持更改或者扩展过的JSON交换格式它必须以定义一个不同的parse函数的方式做这件事。</p>

<p>注：在对象中存在同名字符串的情况下，同一key的值会被按照文本顺序覆盖掉。</p>



<h5>stringify ( value [ , replacer [ , space ] ] )</h5>

<p>stringify函数返回一个JSON格式的字符串，用以表示一个ECMAScript值。它可以接受三个参数。第一个参数是必选的。value参数是一个ECMAScript值，它通常是对象或者数组，尽管它也可以是String, Boolean, Number 或者是 null。可选的replacer参数要么是个可以修改对象和数组字符串化的方式的函数，要么是个扮演选择对象字符串化的属性的白名单这样的角色的String和Number组成的数组。可选的space参数是一个String或者Number，可以允许结果中插入空白符以改善人类可读性。</p>

<p>以下为字符串化一对象的步骤：</p>

<ol>
  <li>令stack为空List </li>

  <li>令indent为空String </li>

  <li>令PropertyList和ReplacerFunction为undefined </li>

  <li>若Type(replacer)为Object,则 
    <ol>
      <li>若IsCallable(replacer)为true,则 
        <ol>
          <li>令ReplacerFunction为replacer</li>
        </ol>
      </li>

      <li>否则若replacer的内部属性<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Class&amp;action=edit&amp;redlink=1">Class</a>为&quot;Array&quot;,则 

        <ol>
          <li>令PropertyList为一空内部类型List </li>

          <li>对于所有名是数组下标的replacer的属性v.以数组下标递增顺序枚举属性 
            <ol>
              <li>令item为undefined </li>

              <li>若Type(v)为String则 令item为v. </li>

              <li>否则若Type(v)为Number则 令item为ToString(v). </li>

              <li>否则若Type(v)为Object则, 
                <ol>
                  <li>若v的<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Class&amp;action=edit&amp;redlink=1">Class</a>内部属性为&quot;String&quot; or &quot;Number&quot;则 令item为ToString(v).</li>
                </ol>
              </li>

              <li>若item is not undefined and item为not currently an element of PropertyList则, 
                <ol>
                  <li>Append item to the end of PropertyList.</li>
                </ol>
              </li>
            </ol>
          </li>
        </ol>
      </li>
    </ol>
  </li>

  <li>若Type(space)为Object则, 
    <ol>
      <li>若space的<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Class&amp;action=edit&amp;redlink=1">Class</a>内部属性为&quot;Number&quot;则, 

        <ol>
          <li>令space为ToNumber(space)</li>
        </ol>
      </li>

      <li>否则若space的<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Class&amp;action=edit&amp;redlink=1">Class</a>内部属性为&quot;String&quot;则, 

        <ol>
          <li>令space为ToString(space)</li>
        </ol>
      </li>
    </ol>
  </li>

  <li>若Type(space)为Number 令space为min(10, ToInteger(space)) 设gap为一包含space个空格的String. 这将会是空String加入space小于1. </li>

  <li>否则若Type(space)为String 
    <ol>
      <li>若space中字符个数为10或者更小, 设gap为space，否则设gap为包含前10个space中字符的字符串</li>
    </ol>
  </li>

  <li>否则 设gap为空String. </li>

  <li>令wrapper为一个如同以表达式new Object()创建的新对象,其中Object是这个名字的标准内置构造器。 </li>

  <li>以参数空String, 属性描述{<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Value&amp;action=edit&amp;redlink=1">Value</a>: value, <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Writable&amp;action=edit&amp;redlink=1">Writable</a>: true, <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Enumerable&amp;action=edit&amp;redlink=1">Enumerable</a>: true, <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Configurable&amp;action=edit&amp;redlink=1">Configurable</a>: true}, 和false调用wrapper的<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=DefineOwnProperty&amp;action=edit&amp;redlink=1">DefineOwnProperty</a>内部方法。 </li>

  <li>返回以空String和wrapper调用抽象方法Str的结果。</li>
</ol>

<p>抽象操作Str(key, holder)可以访问调用它的stringify方法中的ReplacerFunction。其算法如下：</p>

<ol>
  <li>令value为以key为参数调用holder的内部方法<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Get&amp;action=edit&amp;redlink=1">Get</a></li>

  <li>若Type(value)为Object,则 
    <ol>
      <li>令toJSON为以&quot;toJSON&quot;为参数调用value的内部方法<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Get&amp;action=edit&amp;redlink=1">Get</a></li>

      <li>If IsCallable(toJSON) is true 
        <ol>
          <li>令value为以调用toJSON的内部方法<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Call&amp;action=edit&amp;redlink=1">Call</a>的结果，传入value为this值以及由key构成的参数列表</li>
        </ol>
      </li>
    </ol>
  </li>

  <li>若ReplacerFunction为not undefined,则 
    <ol>
      <li>令value为以调用ReplacerFunction的内部方法<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Call&amp;action=edit&amp;redlink=1">Call</a>的结果，传入holder为this值以及由key and value构成的参数列表</li>
    </ol>
  </li>

  <li>若Type(value)为Object则, 
    <ol>
      <li>若value的<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Class&amp;action=edit&amp;redlink=1">Class</a>内部属性为&quot;Number&quot;则, 

        <ol>
          <li>令value为ToNumber(value)</li>
        </ol>
      </li>

      <li>否则若value的<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Class&amp;action=edit&amp;redlink=1">Class</a>内部属性为&quot;String&quot;则, 

        <ol>
          <li>令value为ToString(value)</li>
        </ol>
      </li>

      <li>否则若value的<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Class&amp;action=edit&amp;redlink=1">Class</a>内部属性为&quot;Boolean&quot;则, 

        <ol>
          <li>令value为value的value of the <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=PrimitiveValue&amp;action=edit&amp;redlink=1">PrimitiveValue</a>内部属性</li>
        </ol>
      </li>
    </ol>
  </li>

  <li>若value为null则 返回 &quot;null&quot;. </li>

  <li>若value为true则 返回 &quot;true&quot;. </li>

  <li>若value为false则 返回 &quot;false&quot;. </li>

  <li>若Type(value)为String,则返回以value调用Quote抽象操作的结果。 </li>

  <li>若Type(value)为Number 
    <ol>
      <li>若value为finite则 返回 ToString(value). </li>

      <li>否则, 返回&quot;null&quot;.</li>
    </ol>
  </li>

  <li>若Type(value)为Object,且IsCallable(value)为false 
    <ol>
      <li>若value的<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Class&amp;action=edit&amp;redlink=1">Class</a>内部属性为&quot;Array&quot;则 

        <ol>
          <li>返回以value为参数调用抽象操作JA的结果</li>
        </ol>
      </li>

      <li>否则, 返回以value.为参数调用抽象操作value的结果</li>
    </ol>
  </li>

  <li>返回undefined.</li>
</ol>

<p>抽象操作Quote(value)将一个String值封装在双引号中，并且对其中的字符转义。</p>

<ol>
  <li>令product为双引号字符 </li>

  <li>对value中的每一个字符C 
    <ol>
      <li>若C为双引号字符或者反斜杠字符 
        <ol>
          <li>令product为product和反斜杠连接的结果 </li>

          <li>令product为product与C的连接</li>
        </ol>
      </li>

      <li>否则若C为退格，formfeed换行回车挥着tab 
        <ol>
          <li>令product为product与反斜杠字符的连接 </li>

          <li>令abbrev为如下表所示C对应的字符: backspace &quot;b&quot; formfeed &quot;f&quot; newline &quot;n&quot; carriage return &quot;r&quot; tab &quot;t&quot; </li>

          <li>令product为product与abbrev的连接</li>
        </ol>
      </li>

      <li>否则若C为代码值小于space的控制字符 
        <ol>
          <li>令product为product与反斜杠字符的连接 </li>

          <li>令product为product与&quot;u&quot;的连接 </li>

          <li>令hex为转换C代码值按十六进制转换到四位字符串的结果 </li>

          <li>令product为product与hex的连接</li>
        </ol>
      </li>

      <li>否则 
        <ol>
          <li>令product为product与C的连接</li>
        </ol>
      </li>
    </ol>
  </li>

  <li>令product为product与双引号字符的连接 </li>

  <li>返回 product.</li>
</ol>

<p>抽象操作JO(value)序列化一个对象，它可以访问调用它的方法中的stack, indent, gap, PropertyList,ReplacerFunction以及space</p>

<ol>
  <li>若stack包含value，则抛出一个TypeError，因为对象结构中存在循环。 </li>

  <li>将value添加到stack. </li>

  <li>令stepback为indent </li>

  <li>令indent为indent与gap的连接 </li>

  <li>若PropertyList没有被定义,则 
    <ol>
      <li>令K为PropertyList</li>
    </ol>
  </li>

  <li>否则 
    <ol>
      <li>令K为以由所有<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Enumerable&amp;action=edit&amp;redlink=1">Enumerable</a>特性为true的自身属性名构成的内部String列表类型.</li>
    </ol>
  </li>

  <li>令partial为空List </li>

  <li>对于K的每一个元素P 
    <ol>
      <li>令strP为以P和value为参数调用抽象操作Str的结果 </li>

      <li>若strP没有被定义 
        <ol>
          <li>令member为以P为参数调用抽象操作P的结果 </li>

          <li>令member为member与冒号字符的连接 </li>

          <li>若gap不为空String </li>

          <li>令member为member与空格字符的连接 </li>

          <li>令member为member与strP的连接 </li>

          <li>将member添加到partial.</li>
        </ol>
      </li>
    </ol>
  </li>

  <li>若partial为empty,则 
    <ol>
      <li>令final为&quot;{}&quot;</li>
    </ol>
  </li>

  <li>否则 
    <ol>
      <li>若gap为空String 
        <ol>
          <li>令properties为一个连接所有partial中的字符串而成的字符串，键值对之间用逗号分隔。第一个字符串之前和最后一个字符串之后没有逗号。 </li>

          <li>令final为连接 &quot;{&quot;, properties, 和&quot;}&quot;的结果</li>
        </ol>
      </li>

      <li>否则 gap 不是空String 
        <ol>
          <li>令separator为连接 逗号字符，换行字符以及indent而成的字符串。 </li>

          <li>令properties为一个连接所有partial中的字符串而成的字符串，键值对之间用separator分隔。第一个字符串之前和最后一个字符串之后没有separator。 </li>

          <li>令final为连接&quot;{&quot;, 换行符, indent, properties, 换行符, stepback, 和&quot;}&quot;的结果。</li>
        </ol>
      </li>
    </ol>
  </li>

  <li>移除stack中的最后一个元素。 </li>

  <li>令indent为stepback </li>

  <li>返回final.</li>
</ol>

<p>抽象操作JA(value)序列化一个数组。它可以访问调用它的stringify方法中的stack, indent, gap, PropertyList,ReplacerFunction以及space。数组的表示中仅包扩零到array.length-1的区间。命名的属性将会被从字符串化操作中排除。数组字符串化成开头的左方括号，逗号分隔的元素，以及结束的右方括号。</p>

<ol>
  <li>若stack包含value，则抛出一个TypeError，因为对象结构中存在循环。 </li>

  <li>将value添加到stack. </li>

  <li>令stepback为indent </li>

  <li>令indent为indent与gap的连接 </li>

  <li>令partial为空List </li>

  <li>令len为以&quot;length&quot;为参数调用value的内部方法<a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Get&amp;action=edit&amp;redlink=1">Get</a></li>

  <li>令index为0 </li>

  <li>当index &lt; len时重复以下 
    <ol>
      <li>令strP为the result of calling the abstract operation Str with arguments ToString(index) and value </li>

      <li>若strP没有被定义 
        <ol>
          <li>添加null到 partial.</li>
        </ol>
      </li>

      <li>否则 
        <ol>
          <li>添加strP到 partial.</li>
        </ol>
      </li>

      <li>使index增加1.</li>
    </ol>
  </li>

  <li>若partial为空,则 
    <ol>
      <li>令final为&quot;[]&quot;</li>
    </ol>
  </li>

  <li>否则 
    <ol>
      <li>若gap为空String 
        <ol>
          <li>令properties为为一个连接所有partial中的字符串而成的字符串，键值对之间用逗号分隔。第一个字符串之前和最后一个字符串之后没有逗号。 </li>

          <li>令final为连接 &quot;[&quot;, properties, 和&quot;]&quot;的结果</li>
        </ol>
      </li>

      <li>否则 
        <ol>
          <li>令separator为逗号字符，换行字符以及indent而成的字符串。 </li>

          <li>令properties为一个连接所有partial中的字符串而成的字符串，键值对之间用separator分隔。第一个字符串之前和最后一个字符串之后没有separator。 </li>

          <li>令final为连接&quot;[&quot;, 换行符, indent, properties, 换行符, stepback, 和&quot;]&quot;的结果。</li>
        </ol>
      </li>
    </ol>
  </li>

  <li>移除stack中的最后一个元素。 </li>

  <li>令indent为stepback </li>

  <li>返回final.</li>
</ol>

<div>
<p>注1 JSON结构允许任何深度的嵌套，但是不能够循环引用。若value是或者包含了一个循环结构，则stringify函数必须抛出一个TypeError异常。以下是一个不能够被字符串化的值的例子：</p>

<pre>a = [];
a[0] = a;
my_text = JSON.stringify(a); // This must throw an TypeError.</pre>
</div>
<div>
<p>注2 符号式简单值按以下方式表示：</p>

<ol>
  <li>null值在JSON文本中表示为字符串null </li>

  <li>undefined 值不出现 </li>

  <li>true值在JSON文本中表示为字符串true </li>

  <li>false值在JSON文本中表示为字符串false</li>
</ol>
</div>
<p>注3 字符串值用双引号括起。字符&quot;和\会被转义成带\前缀的。控制字符用转义序列\uHHHH替换，或者使用简略形式 \b(backspace), \f (formfeed), \n (newline), \r (carriage return), \t (tab)</p>

<p>注4 有穷的数字按照调用ToString(number)字符串化。NaN和不论正负的Infinity都表示为字符串null</p>

<p>注5 没有JSON表示的值（如undefined和函数）不会产生字符串。而是会产生undefined值。在数组中这些值表示为字符串null。在对象中不能表示的值会导致属性被排除在字符串化过程之外。</p>

<p>注6 对象表示为开头的左大括号跟着零个或者多个属性，以逗号分隔，以右大括号结束。属性是用用来表示key或者属性名的引号引起的字符串，冒号然后是字符串化的属性值。数组表示为开头的左方括号，后跟零个或者多个值，以逗号分隔，以右方括号结束。</p>

<h4>错误</h4>

<p>在 EMCAScript 相关语言构造被求值之时，实现报告大部分错误。早期的错误是一种可以检测和优先报告程序中所有错误内任何构造的求值问题。具体实现一定要在一个程序首次执行评估时报告早期错误。早期错误在 <b>eval</b> 被调用时报告 <b>eval</b> 错误代码，但是在 eval 代码内之优先评估任意构造。</p>

<p>一个实现要处理任意实例中的以下几种误差作为早期错误 :</p>

<ol>
  <li>任意语法错误 </li>

  <li>试图定义一个有多个相同名字的 <b>get</b> 属性设置或有多个相同名字的 <b>set</b> 属性设置的 <i>对象字面量</i></li>

  <li>试图定义一个数据属性设置并且 <b>get</b> 或 <b>set</b> 具有相同的名称属性设置的 <i>对象字面量</i></li>

  <li>错误在正则表达式字面量中没有实现语法扩展 </li>

  <li>试图在严格代码模式下定义一个有多个相同名称属性设置数据的 <i>对象字面量</i></li>

  <li>with 语句在严格代码模式下出现 </li>

  <li>在严格模式下的函数定义或函数表达的参数列表内不止一次出现标识符值的情况 </li>

  <li>使用 return, break 和 continue 不当 </li>

  <li>试图在早期已经确定为非引用的任意值上调用 PutValue（例如，执行赋值语句 3 = 4）</li>
</ol>

<p>一个实现不应过早处理其他种类的错误，即使编译器可以证实某一构造会在任何情况下产生执行错误。</p>

<p>一个实现应报告所有的指定错误，但以下情况除外：</p>

<ol>
  <li>实现可以扩展程序语法和正则表达式或标志语法。使用此功能，当它们遇到一个实现程序语法定义扩展或正则表达式或标记语法时，所有操作（如调用 eval，使用正则表达式字面，或使用 Function 或 RegExp 构造）被获准展现实现定义扩展的行为，而非抛出 SyntaxError 。 </li>

  <li>一个实现可以提供超出本规范中所描述的功能范围外的类型，值，对象，属性。这可能会导致构造（如寻找一个在全局作用域内的变量）实现定义的行为而非抛出一个错误（如 ReferenceError）。 </li>

  <li>当在 fractionDigits 或 precision 参数是在指定的范围之外，一个实现可以为 toFixed, toExponential, 和 toPrecision 定义 RangeError 以外的其他行为。</li>
</ol>


<h4>附录 A 文法摘要</h4>


<h5>A.1 词法</h5>

<pre>   SourceCharacter ::
       任意 Unicode 编码单元 </pre>

<pre>   InputElementDiv ::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#WhiteSpace">WhiteSpace</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#LineTerminator">LineTerminator</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Comment">Comment</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Token">Token</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#DivPunctuator">DivPunctuator</a></pre>

<pre>   InputElementRegExp ::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#WhiteSpace">WhiteSpace</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#LineTerminator">LineTerminator</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Comment">Comment</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Token">Token</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#RegularExpressionLiteral">RegularExpressionLiteral</a></pre>

<pre>   WhiteSpace ::
       <TAB>
       <VT>
       <FF>
       <SP>
       <#x0a>
       <BOM>
       <USP></pre>

<pre>   LineTerminator ::
       <LF>
       <CR>
       <LS>
       <PS></pre>

<pre>   LineTerminatorSequence ::
       <LF>
       <CR> [lookahead ∉ <LF> ]
       <LS>
       <PS>
       <CR>
       <LF></pre>

<pre>   Comment ::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#MultiLineComment">MultiLineComment</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#SingleLineComment">SingleLineComment</a></pre>

<pre>   MultiLineComment ::
       /* <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#MultiLineCommentChars">MultiLineCommentChars</a><sub>opt</sub> */</pre>

<pre>   MultiLineCommentChars ::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#MultiLineNotAsteriskChar">MultiLineNotAsteriskChar</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#MultiLineCommentChars">MultiLineCommentChars</a><sub>opt</sub>
       * <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#PostAsteriskCommentChars">PostAsteriskCommentChars</a><sub>opt</sub></pre>

<pre>   PostAsteriskCommentChars ::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#MultiLineNotForwardSlashorAsteriskChar">MultiLineNotForwardSlashorAsteriskChar</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#MultiLineCommentChars">MultiLineCommentChars</a><sub>opt</sub>
       * <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#PostAsteriskCommentChars">PostAsteriskCommentChars</a><sub>opt</sub></pre>

<pre>   MultiLineNotAsteriskChar ::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#SourceCharacter">SourceCharacter</a> 但非 星号 *</pre>

<pre>   MultiLineNotForwardSlashorAsteriskChar ::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#SourceCharacter">SourceCharacter</a> 但非 正斜杠 / 或 星号 *</pre>

<pre>   SingleLineComment ::
       // <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#SingleLineCommentChars">SingleLineCommentChars</a><sub>opt</sub></pre>

<pre>   SingleLineCommentChars ::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#SingleLineCommentChar">SingleLineCommentChar</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#SingleLineCommentChars">SingleLineCommentChars</a><sub>opt</sub></pre>

<pre>   SingleLineCommentChar ::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#SourceCharacter">SourceCharacter</a> 但非 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#LineTerminator">LineTerminator</a></pre>

<pre>   Token ::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#IdentifierName">IdentifierName</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Punctuator">Punctuator</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#NumericLiteral">NumericLiteral</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#StringLiteral">StringLiteral</a></pre>

<pre>   Identifier ::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#IdentifierName">IdentifierName</a> 但非 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#ReservedWord">ReservedWord</a></pre>

<pre>   IdentifierName ::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#IdentifierStart">IdentifierStart</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#IdentifierName">IdentifierName</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#IdentifierPart">IdentifierPart</a></pre>

<pre>   IdentifierStart ::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#UnicodeLetter">UnicodeLetter</a>
       $
       _ 
       \ <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#UnicodeEscapeSequence">UnicodeEscapeSequence</a></pre>

<pre>   IdentifierPart ::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#IdentifierStart">IdentifierStart</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#UnicodeCombiningMark">UnicodeCombiningMark</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#UnicodeDigit">UnicodeDigit</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#UnicodeConnectorPunctuation">UnicodeConnectorPunctuation</a>
       <ZWNJ>
       <ZWJ></pre>

<pre>   UnicodeLetter
       在以下 Unicode 分类中的字符：“Uppercase letter (Lu)”, “Lowercase letter (Ll)”, “Titlecase letter (Lt)”,
       “Modifier letter (Lm)”, “Other letter (Lo)”, 或 “Letter number (Nl)”.</pre>

<pre>   UnicodeCombiningMark
       在以下 Unicode 分类中的字符：“Non-spacing mark (Mn)” 或 “Combining spacing mark (Mc)”</pre>

<pre>   UnicodeDigit
       在以下 Unicode 分类中的字符：“Decimal number (Nd)”</pre>

<pre>   UnicodeConnectorPunctuation
       在以下 Unicode 分类中的字符：“Connector punctuation (Pc)”</pre>

<pre>   ReservedWord ::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Keyword">Keyword</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#FutureReservedWord">FutureReservedWord</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#NullLiteral">NullLiteral</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#BooleanLiteral">BooleanLiteral</a></pre>

<pre>   Keyword :: 以下之一 
       break do instanceof typeof case else new var catch finally return 
       void continue for switch while debugger function this with default
       if throw delete in try </pre>

<pre>   FutureReservedWord :: 以下之一 
       class enum extends super const export import 
       或在严格模式下以下之一 
       implements let private public interface package protected static yield </pre>

<pre>   Punctuator :: 以下之一 
       { } ( ) [ ] . ; , < > <= >= == != === !== + - * % ++ -- << >> >>> & | ^ ! ~ && || ? : = += -= *= %= <<= >>= >>>= &= |= ^= </pre>

<pre>   DivPunctuator :: 以下之一 
       / /=</pre>

<pre>   Literal ::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#NullLiteral">NullLiteral</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#BooleanLiteral">BooleanLiteral</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#NumericLiteral">NumericLiteral</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#StringLiteral">StringLiteral</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#RegularExpressionLiteral">RegularExpressionLiteral</a></pre>

<pre>   NullLiteral ::
       null</pre>

<pre>   BooleanLiteral ::
       true
       false</pre>

<pre>   NumericLiteral ::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#DecimalLiteral">DecimalLiteral</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#HexIntegerLiteral">HexIntegerLiteral</a></pre>

<pre>   DecimalLiteral ::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#DecimalIntegerLiteral">DecimalIntegerLiteral</a> . <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#DecimalDigits">DecimalDigits</a><sub>opt</sub> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#ExponentPart">ExponentPart</a><sub>opt</sub>
       . <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#DecimalDigits">DecimalDigits</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#ExponentPart">ExponentPart</a><sub>opt</sub>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#DecimalIntegerLiteral">DecimalIntegerLiteral</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#ExponentPart">ExponentPart</a><sub>opt</sub></pre>

<pre>   DecimalIntegerLiteral ::
       0 
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#NonZeroDigit">NonZeroDigit</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#DecimalDigits">DecimalDigits</a><sub>opt</sub></pre>

<pre>   DecimalDigits ::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#DecimalDigit">DecimalDigit</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#DecimalDigits">DecimalDigits</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#DecimalDigit">DecimalDigit</a></pre>

<pre>   DecimalDigit :: 以下之一 
       0 1 2 3 4 5 6 7 8 9</pre>

<pre>   NonZeroDigit:: 以下之一 
       1 2 3 4 5 6 7 8 9</pre>

<pre>   ExponentPart::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#ExponentIndicator">ExponentIndicator</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#SignedInteger">SignedInteger</a></pre>

<pre>   ExponentIndicator :: 以下之一 
       e E</pre>

<pre>   SignedInteger ::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#DecimalDigits">DecimalDigits</a>
       + <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#DecimalDigits">DecimalDigits</a>
       - <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#DecimalDigits">DecimalDigits</a></pre>

<pre>   HexIntegerLiteral ::
       0x <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#HexDigit">HexDigit</a>
       0X <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#HexDigit">HexDigit</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#HexIntegerLiteral">HexIntegerLiteral</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#HexDigit">HexDigit</a></pre>

<pre>   HexDigit :: 以下之一 
       0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F</pre>

<pre>   StringLiteral ::
       "<a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#DoubleStringCharacters">DoubleStringCharacters</a><sub>opt</sub> "
       '<a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#SingleStringCharacters">SingleStringCharacters</a><sub>opt</sub> '</pre>

<pre>   DoubleStringCharacters ::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#DoubleStringCharacter">DoubleStringCharacter</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#DoubleStringCharacters">DoubleStringCharacters</a><sub>opt</sub></pre>

<pre>   SingleStringCharacters ::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#SingleStringCharacter">SingleStringCharacter</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#SingleStringCharacters">SingleStringCharacters</a><sub>opt</sub></pre>

<pre>   DoubleStringCharacter ::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#SourceCharacter">SourceCharacter</a> 但非 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#double-quote">double-quote</a> " 或 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#backslash">backslash</a> \ 或 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#LineTerminator">LineTerminator</a>
       \ <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#EscapeSequence">EscapeSequence</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#LineContinuation">LineContinuation</a></pre>

<pre>   SingleStringCharacter ::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#SourceCharacter">SourceCharacter</a> 但非 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#single-quote">single-quote</a> ' 或 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#backslash">backslash</a> \ 或 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#LineTerminator">LineTerminator</a>
       \ <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#EscapeSequence">EscapeSequence</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#LineContinuation">LineContinuation</a></pre>

<pre>   LineContinuation ::
       \ <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#LineTerminatorSequence">LineTerminatorSequence</a></pre>

<pre>   EscapeSequence ::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#CharacterEscapeSequence">CharacterEscapeSequence</a>
       0 [lookahead ∉ <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#DecimalDigit">DecimalDigit</a>]
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#HexEscapeSequence">HexEscapeSequence</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#UnicodeEscapeSequence">UnicodeEscapeSequence</a></pre>

<pre>   CharacterEscapeSequence ::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#SingleEscapeCharacter">SingleEscapeCharacter</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#NonEscapeCharacter">NonEscapeCharacter</a></pre>

<pre>   SingleEscapeCharacter :: 以下之一 
       ' " \ b f n r t v</pre>

<pre>   NonEscapeCharacter ::
       SourceCharacter 但非 EscapeCharacter 或 LineTerminator</pre>

<pre>   EscapeCharacter ::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#SingleEscapeCharacter">SingleEscapeCharacter</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#DecimalDigit">DecimalDigit</a>
       x
       u</pre>

<pre>   HexEscapeSequence ::
       x <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#HexDigit">HexDigit</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#HexDigit">HexDigit</a></pre>

<pre>   UnicodeEscapeSequence ::
       u <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#HexDigit">HexDigit</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#HexDigit">HexDigit</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#HexDigit">HexDigit</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#HexDigit">HexDigit</a></pre>

<pre>   RegularExpressionLiteral ::
       / <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#RegularExpressionBody">RegularExpressionBody</a> / <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#RegularExpressionFlags">RegularExpressionFlags</a></pre>

<pre>   RegularExpressionBody ::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#RegularExpressionFirstChar">RegularExpressionFirstChar</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#RegularExpressionChars">RegularExpressionChars</a></pre>

<pre>   RegularExpressionChars ::
       [empty]
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#RegularExpressionChars">RegularExpressionChars</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#RegularExpressionChar">RegularExpressionChar</a></pre>

<pre>   RegularExpressionFirstChar ::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#RegularExpressionNonTerminator">RegularExpressionNonTerminator</a> 但非 * 或 \ 或 / 或 [ 
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#RegularExpressionBackslashSequence">RegularExpressionBackslashSequence</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#RegularExpressionClass">RegularExpressionClass</a></pre>

<pre>   RegularExpressionChar ::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#RegularExpressionNonTerminator">RegularExpressionNonTerminator</a> 但非 \ 或 / 或 [ 
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#RegularExpressionBackslashSequence">RegularExpressionBackslashSequence</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#RegularExpressionClass">RegularExpressionClass</a></pre>

<pre>   RegularExpressionBackslashSequence ::
       \ <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#RegularExpressionNonTerminator">RegularExpressionNonTerminator</a></pre>

<pre>   RegularExpressionNonTerminator ::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#SourceCharacter">SourceCharacter</a> 但非 <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#LineTerminator">LineTerminator</a></pre>

<pre>   RegularExpressionClass ::
       [ <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#RegularExpressionClassChars">RegularExpressionClassChars</a> ]</pre>

<pre>   RegularExpressionClassChars ::
       [ 空 ]
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#RegularExpressionClassChars">RegularExpressionClassChars</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#RegularExpressionClassChar">RegularExpressionClassChar</a></pre>

<pre>   RegularExpressionClassChar ::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#RegularExpressionNonTerminator">RegularExpressionNonTerminator</a> 但非 ] 或 \ 
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#RegularExpressionBackslashSequence">RegularExpressionBackslashSequence</a></pre>

<pre>   RegularExpressionFlags ::
       [ 空 ]
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#RegularExpressionFlags">RegularExpressionFlags</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#IdentifierPart">IdentifierPart</a></pre>


<h5>A.2 数字转换</h5>

<pre>   StringNumericLiteral :::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#StrWhiteSpace">StrWhiteSpace</a><sub>opt</sub>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#StrWhiteSpace">StrWhiteSpace</a><sub>opt</sub><a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#StrNumericLiteral">StrNumericLiteral</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#StrWhiteSpace">StrWhiteSpace</a><sub>opt</sub></pre>

<pre>   StrWhiteSpace :::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#StrWhiteSpaceChar">StrWhiteSpaceChar</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#StrWhiteSpace">StrWhiteSpace</a><sub>opt</sub></pre>

<pre>   StrWhiteSpaceChar :::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#WhiteSpace">WhiteSpace</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#LineTerminator">LineTerminator</a></pre>

<pre>   StrNumericLiteral :::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#StrDecimalLiteral">StrDecimalLiteral</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#HexIntegerLiteral">HexIntegerLiteral</a></pre>

<pre>   StrDecimalLiteral :::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#StrUnsignedDecimalLiteral">StrUnsignedDecimalLiteral</a>
       + <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#StrUnsignedDecimalLiteral">StrUnsignedDecimalLiteral</a>
       - <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#StrUnsignedDecimalLiteral">StrUnsignedDecimalLiteral</a></pre>

<pre>   StrUnsignedDecimalLiteral :::
       Infinity 
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#DecimalDigits">DecimalDigits</a> . <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#DecimalDigits">DecimalDigits</a><sub>opt</sub> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#ExponentPart">ExponentPart</a><sub>opt</sub>
       . <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#DecimalDigits">DecimalDigits</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#ExponentPart">ExponentPart</a><sub>opt</sub>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#DecimalDigits">DecimalDigits</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#ExponentPart">ExponentPart</a><sub>opt</sub></pre>

<pre>   DecimalDigits :::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#DecimalDigit">DecimalDigit</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#DecimalDigits">DecimalDigits</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#DecimalDigit">DecimalDigit</a></pre>

<pre>   DecimalDigit ::: 以下之一 
       0 1 2 3 4 5 6 7 8 9</pre>

<pre>   ExponentPart :::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#ExponentIndicator">ExponentIndicator</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#SignedInteger">SignedInteger</a></pre>

<pre>   ExponentIndicator ::: 以下之一 
       e E</pre>

<pre>   SignedInteger :::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#DecimalDigits">DecimalDigits</a>
       + <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#DecimalDigits">DecimalDigits</a>
       - <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#DecimalDigits">DecimalDigits</a></pre>

<pre>   HexIntegerLiteral :::
       0x <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#HexDigit">HexDigit</a>
       0X <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#HexDigit">HexDigit</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#HexIntegerLiteral">HexIntegerLiteral</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#HexDigit">HexDigit</a></pre>

<pre>   HexDigit ::: 以下之一 
       0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F</pre>


<h5>A.3 表达式</h5>

<pre>   PrimaryExpression :
       this 
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Identifier">Identifier</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Literal">Literal</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#ArrayLiteral">ArrayLiteral</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#ObjectLiteral">ObjectLiteral</a>
       ( <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Expression">Expression</a> )</pre>

<pre>   ArrayLiteral :
       [ <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Elision">Elision</a><sub>opt</sub> ]
       [ <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#ElementList">ElementList</a> ]
       [ <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#ElementList">ElementList</a> , <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Elision">Elision</a><sub>opt</sub> ]</pre>

<pre>   ElementList :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Elision">Elision</a><sub>opt</sub><a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#AssignmentExpression">AssignmentExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#ElementList">ElementList</a> , <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Elision">Elision</a><sub>opt</sub><a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#AssignmentExpression">AssignmentExpression</a></pre>

<pre>   Elision :
       ,
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Elision">Elision</a> ,</pre>

<pre>   ObjectLiteral :
       { } 
       { <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#PropertyNameAndValueList">PropertyNameAndValueList</a> }
       { <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#PropertyNameAndValueList">PropertyNameAndValueList</a> , }</pre>

<pre>   PropertyNameAndValueList :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#PropertyAssignment">PropertyAssignment</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#PropertyNameAndValueList">PropertyNameAndValueList</a> , <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#PropertyAssignment">PropertyAssignment</a></pre>

<pre>   PropertyAssignment :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#PropertyName">PropertyName</a> : <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#AssignmentExpression">AssignmentExpression</a>
       get <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#PropertyName">PropertyName</a>() { <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#FunctionBody">FunctionBody</a> }
       set <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#PropertyName">PropertyName</a>( <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#PropertySetParameterList">PropertySetParameterList</a> ) { <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#FunctionBody">FunctionBody</a> }</pre>

<pre>   PropertyName :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#IdentifierName">IdentifierName</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#StringLiteral">StringLiteral</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#NumericLiteral">NumericLiteral</a></pre>

<pre>   PropertySetParameterList :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Identifier">Identifier</a></pre>

<pre>   MemberExpression :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#PrimaryExpression">PrimaryExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#FunctionExpression">FunctionExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#MemberExpression">MemberExpression</a> [ <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Expression">Expression</a> ]
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#MemberExpression">MemberExpression</a> . <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#IdentifierName">IdentifierName</a>
       new <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#MemberExpression">MemberExpression</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Arguments">Arguments</a></pre>

<pre>   NewExpression :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#MemberExpression">MemberExpression</a>
       new <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#NewExpression">NewExpression</a></pre>

<pre>   CallExpression :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#MemberExpression">MemberExpression</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Arguments">Arguments</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#CallExpression">CallExpression</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Arguments">Arguments</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#CallExpression">CallExpression</a> [ <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Expression">Expression</a> ]
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#CallExpression">CallExpression</a> . <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#IdentifierName">IdentifierName</a></pre>

<pre>   Arguments :
       ( )
       ( <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#ArgumentList">ArgumentList</a> )</pre>

<pre>   ArgumentList :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#AssignmentExpression">AssignmentExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#ArgumentList">ArgumentList</a> , <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#AssignmentExpression">AssignmentExpression</a></pre>

<pre>   LeftHandSideExpression :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#NewExpression">NewExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#CallExpression">CallExpression</a></pre>

<pre>   PostfixExpression :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#LeftHandSideExpression">LeftHandSideExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#LeftHandSideExpression">LeftHandSideExpression</a> [ 此处无换行 ] ++ 
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#LeftHandSideExpression">LeftHandSideExpression</a> [ 此处无换行 ] --</pre>

<pre>   UnaryExpression :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#PostfixExpression">PostfixExpression</a>
       delete <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#UnaryExpression">UnaryExpression</a>
       void <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#UnaryExpression">UnaryExpression</a>
       typeof <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#UnaryExpression">UnaryExpression</a>
       ++ <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#UnaryExpression">UnaryExpression</a>
       -- <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#UnaryExpression">UnaryExpression</a>
       + <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#UnaryExpression">UnaryExpression</a>
       - <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#UnaryExpression">UnaryExpression</a>
       ~ <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#UnaryExpression">UnaryExpression</a>  ! <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#UnaryExpression">UnaryExpression</a></pre>

<pre>   MultiplicativeExpression :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#UnaryExpression">UnaryExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#MultiplicativeExpression">MultiplicativeExpression</a> * <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#UnaryExpression">UnaryExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#MultiplicativeExpression">MultiplicativeExpression</a> / <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#UnaryExpression">UnaryExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#MultiplicativeExpression">MultiplicativeExpression</a> % <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#UnaryExpression">UnaryExpression</a></pre>

<pre>   AdditiveExpression :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#MultiplicativeExpression">MultiplicativeExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#AdditiveExpression">AdditiveExpression</a> + <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#MultiplicativeExpression">MultiplicativeExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#AdditiveExpression">AdditiveExpression</a> - <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#MultiplicativeExpression">MultiplicativeExpression</a></pre>

<pre>   ShiftExpression :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#AdditiveExpression">AdditiveExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#ShiftExpression">ShiftExpression</a> << <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#AdditiveExpression">AdditiveExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#ShiftExpression">ShiftExpression</a> >> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#AdditiveExpression">AdditiveExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#ShiftExpression">ShiftExpression</a> >>> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#AdditiveExpression">AdditiveExpression</a></pre>

<pre>   RelationalExpression :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#ShiftExpression">ShiftExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#RelationalExpression">RelationalExpression</a> < <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#ShiftExpression">ShiftExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#RelationalExpression">RelationalExpression</a> > <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#ShiftExpression">ShiftExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#RelationalExpression">RelationalExpression</a> <= <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#ShiftExpression">ShiftExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#RelationalExpression">RelationalExpression</a> >= <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#ShiftExpression">ShiftExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#RelationalExpression">RelationalExpression</a> instanceof <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#ShiftExpression">ShiftExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#RelationalExpression">RelationalExpression</a> in <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#ShiftExpression">ShiftExpression</a></pre>

<pre>   RelationalExpressionNoIn :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#ShiftExpression">ShiftExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#RelationalExpressionNoIn">RelationalExpressionNoIn</a> < <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#ShiftExpression">ShiftExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#RelationalExpressionNoIn">RelationalExpressionNoIn</a> > <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#ShiftExpression">ShiftExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#RelationalExpressionNoIn">RelationalExpressionNoIn</a> <= <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#ShiftExpression">ShiftExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#RelationalExpressionNoIn">RelationalExpressionNoIn</a> >= <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#ShiftExpression">ShiftExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#RelationalExpressionNoIn">RelationalExpressionNoIn</a> instanceof <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#ShiftExpression">ShiftExpression</a></pre>

<pre>   EqualityExpression :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#RelationalExpression">RelationalExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#EqualityExpression">EqualityExpression</a> == <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#RelationalExpression">RelationalExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#EqualityExpression">EqualityExpression</a> != <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#RelationalExpression">RelationalExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#EqualityExpression">EqualityExpression</a> === <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#RelationalExpression">RelationalExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#EqualityExpression">EqualityExpression</a> !== <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#RelationalExpression">RelationalExpression</a></pre>

<pre>   EqualityExpressionNoIn :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#RelationalExpressionNoIn">RelationalExpressionNoIn</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#EqualityExpressionNoIn">EqualityExpressionNoIn</a> == <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#RelationalExpressionNoIn">RelationalExpressionNoIn</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#EqualityExpressionNoIn">EqualityExpressionNoIn</a> != <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#RelationalExpressionNoIn">RelationalExpressionNoIn</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#EqualityExpressionNoIn">EqualityExpressionNoIn</a> === <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#RelationalExpressionNoIn">RelationalExpressionNoIn</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#EqualityExpressionNoIn">EqualityExpressionNoIn</a> !== <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#RelationalExpressionNoIn">RelationalExpressionNoIn</a></pre>

<pre>   BitwiseANDExpression :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#EqualityExpression">EqualityExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#BitwiseANDExpression">BitwiseANDExpression</a> & <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#EqualityExpression">EqualityExpression</a></pre>

<pre>   BitwiseANDExpressionNoIn :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#EqualityExpressionNoIn">EqualityExpressionNoIn</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#BitwiseANDExpressionNoIn">BitwiseANDExpressionNoIn</a> & <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#EqualityExpressionNoIn">EqualityExpressionNoIn</a></pre>

<pre>   BitwiseXORExpression :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#BitwiseANDExpression">BitwiseANDExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#BitwiseXORExpression">BitwiseXORExpression</a> ^ <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#BitwiseANDExpression">BitwiseANDExpression</a></pre>

<pre>   BitwiseXORExpressionNoIn :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#BitwiseANDExpressionNoIn">BitwiseANDExpressionNoIn</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#BitwiseXORExpressionNoIn">BitwiseXORExpressionNoIn</a> ^ <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#BitwiseANDExpressionNoIn">BitwiseANDExpressionNoIn</a></pre>

<pre>   BitwiseORExpression :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#BitwiseXORExpression">BitwiseXORExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#BitwiseORExpression">BitwiseORExpression</a> | <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#BitwiseXORExpression">BitwiseXORExpression</a></pre>

<pre>   BitwiseORExpressionNoIn :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#BitwiseXORExpressionNoIn">BitwiseXORExpressionNoIn</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#BitwiseORExpressionNoIn">BitwiseORExpressionNoIn</a> | <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#BitwiseXORExpressionNoIn">BitwiseXORExpressionNoIn</a></pre>

<pre>   LogicalANDExpression :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#BitwiseORExpression">BitwiseORExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#LogicalANDExpression">LogicalANDExpression</a> && <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#BitwiseORExpression">BitwiseORExpression</a></pre>

<pre>   LogicalANDExpressionNoIn :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#BitwiseORExpressionNoIn">BitwiseORExpressionNoIn</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#LogicalANDExpressionNoIn">LogicalANDExpressionNoIn</a> && <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#BitwiseORExpressionNoIn">BitwiseORExpressionNoIn</a></pre>

<pre>   LogicalORExpression :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#LogicalANDExpression">LogicalANDExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#LogicalORExpression">LogicalORExpression</a> || <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#LogicalANDExpression">LogicalANDExpression</a></pre>

<pre>   LogicalORExpressionNoIn :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#LogicalANDExpressionNoIn">LogicalANDExpressionNoIn</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#LogicalORExpressionNoIn">LogicalORExpressionNoIn</a> || <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#LogicalANDExpressionNoIn">LogicalANDExpressionNoIn</a></pre>

<pre>   ConditionalExpression :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#LogicalORExpression">LogicalORExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#LogicalORExpression">LogicalORExpression</a> ? <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#AssignmentExpression">AssignmentExpression</a> : <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#AssignmentExpression">AssignmentExpression</a></pre>

<pre>   ConditionalExpressionNoIn :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#LogicalORExpressionNoIn">LogicalORExpressionNoIn</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#LogicalORExpressionNoIn">LogicalORExpressionNoIn</a> ? <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#AssignmentExpressionNoIn">AssignmentExpressionNoIn</a> : <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#AssignmentExpressionNoIn">AssignmentExpressionNoIn</a></pre>

<pre>   AssignmentExpression :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#ConditionalExpression">ConditionalExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#LeftHandSideExpression">LeftHandSideExpression</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#AssignmentOperator">AssignmentOperator</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#AssignmentExpression">AssignmentExpression</a></pre>

<pre>   AssignmentExpressionNoIn :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#ConditionalExpressionNoIn">ConditionalExpressionNoIn</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#LeftHandSideExpression">LeftHandSideExpression</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#AssignmentOperator">AssignmentOperator</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#AssignmentExpressionNoIn">AssignmentExpressionNoIn</a></pre>

<pre>   AssignmentOperator : 以下之一 
       = *= /= %= += -= <<= >>= >>>= &= ^= |= </pre>
<pre>
   Expression :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#AssignmentExpression">AssignmentExpression</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Expression">Expression</a> , <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#AssignmentExpression">AssignmentExpression</a></pre>

<pre>   ExpressionNoIn :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#AssignmentExpressionNoIn">AssignmentExpressionNoIn</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#ExpressionNoIn">ExpressionNoIn</a> , <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#AssignmentExpressionNoIn">AssignmentExpressionNoIn</a></pre>


<h5>A.4 语句</h5>

<pre>   Statement :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Block">Block</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#VariableStatement">VariableStatement</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#EmptyStatement">EmptyStatement</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#ExpressionStatement">ExpressionStatement</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#IfStatement">IfStatement</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#IterationStatement">IterationStatement</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#ContinueStatement">ContinueStatement</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#BreakStatement">BreakStatement</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#ReturnStatement">ReturnStatement</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#WithStatement">WithStatement</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#LabelledStatement">LabelledStatement</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#SwitchStatement">SwitchStatement</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#ThrowStatement">ThrowStatement</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#TryStatement">TryStatement</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#DebuggerStatement">DebuggerStatement</a></pre>

<pre>   Block :
       { <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#StatementList">StatementList</a><sub>opt</sub> }</pre>

<pre>   StatementList :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Statement">Statement</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#StatementList">StatementList</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Statement">Statement</a></pre>

<pre>   VariableStatement :
       var <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#VariableDeclarationList">VariableDeclarationList</a> ;</pre>

<pre>   VariableDeclarationList :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#VariableDeclaration">VariableDeclaration</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#VariableDeclarationList">VariableDeclarationList</a> , <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#VariableDeclaration">VariableDeclaration</a></pre>

<pre>   VariableDeclarationListNoIn :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#VariableDeclarationNoIn">VariableDeclarationNoIn</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#VariableDeclarationListNoIn">VariableDeclarationListNoIn</a> , <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#VariableDeclarationNoIn">VariableDeclarationNoIn</a></pre>

<pre>   VariableDeclaration :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Identifier">Identifier</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Initialiser">Initialiser</a><sub>opt</sub></pre>

<pre>   VariableDeclarationNoIn :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Identifier">Identifier</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#InitialiserNoIn">InitialiserNoIn</a><sub>opt</sub></pre>

<pre>   Initialiser :
       = <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#AssignmentExpression">AssignmentExpression</a></pre>

<pre>   InitialiserNoIn :
       = <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#AssignmentExpressionNoIn">AssignmentExpressionNoIn</a></pre>

<pre>   EmptyStatement :  ;</pre>

<pre>   ExpressionStatement :
       [lookahead ∉ {{, function}]<a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Expression">Expression</a> ;</pre>

<pre>   IfStatement :
       if ( <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Expression">Expression</a> ) <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Statement">Statement</a> else <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Statement">Statement</a>
       if ( <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Expression">Expression</a> ) <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Statement">Statement</a></pre>

<pre>   IterationStatement :
       do <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Statement">Statement</a> while ( <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Expression">Expression</a> ); 
       while ( <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Expression">Expression</a> ) <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Statement">Statement</a>
       for ( <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#ExpressionNoIn">ExpressionNoIn</a><sub>opt</sub>; <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Expression">Expression</a><sub>opt</sub> ; <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Expression">Expression</a><sub>opt</sub> ) <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Statement">Statement</a>
       for ( var <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#VariableDeclarationListNoIn">VariableDeclarationListNoIn</a>; <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Expression">Expression</a><sub>opt</sub> ; <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Expression">Expression</a><sub>opt</sub> ) <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Statement">Statement</a>
       for ( <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#LeftHandSideExpression">LeftHandSideExpression</a> in <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Expression">Expression</a> ) <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Statement">Statement</a>
       for ( var <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#VariableDeclarationNoIn">VariableDeclarationNoIn</a> in <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Expression">Expression</a> ) <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Statement">Statement</a></pre>

<pre>   ContinueStatement :
       continue [ 此处无换行 ]<a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Identifier">Identifier</a><sub>opt</sub> ;</pre>

<pre>   BreakStatement :
       break [ 此处无换行 ]<a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Identifier">Identifier</a><sub>opt</sub> ;</pre>

<pre>   ReturnStatement :
       return [ 此处无换行 ]<a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Expression">Expression</a><sub>opt</sub> ;</pre>

<pre>   WithStatement :
       with ( <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Expression">Expression</a> ) <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Statement">Statement</a></pre>

<pre>   SwitchStatement :
       switch ( <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Expression">Expression</a> ) <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#CaseBlock">CaseBlock</a></pre>

<pre>   CaseBlock :
       { <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#CaseClauses">CaseClauses</a><sub>opt</sub> } 
       { <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#CaseClauses">CaseClauses</a><sub>opt</sub><a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#DefaultClause">DefaultClause</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#CaseClauses">CaseClauses</a><sub>opt</sub> }</pre>

<pre>   CaseClauses :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#CaseClause">CaseClause</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#CaseClauses">CaseClauses</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#CaseClause">CaseClause</a></pre>

<pre>   CaseClause :
       case <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Expression">Expression</a> : <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#StatementList">StatementList</a><sub>opt</sub></pre>

<pre>   DefaultClause :
       default : <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#StatementList">StatementList</a><sub>opt</sub></pre>

<pre>   LabelledStatement :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Identifier">Identifier</a> : <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Statement">Statement</a></pre>

<pre>   ThrowStatement :
       throw [no<a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#LineTerminator">LineTerminator</a> here] <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Expression">Expression</a> ;</pre>

<pre>   TryStatement :
       try <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Block">Block</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Catch">Catch</a>
       try <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Block">Block</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Finally">Finally</a>
       try <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Block">Block</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Catch">Catch</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Finally">Finally</a></pre>

<pre>   Catch :
       catch ( <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Identifier">Identifier</a> ) <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Block">Block</a></pre>

<pre>   Finally :
       finally <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Block">Block</a></pre>

<pre>   DebuggerStatement :
       debugger ;</pre>


<h5>A.5 函数和程序</h5>

<pre>   FunctionDeclaration :
       function <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Identifier">Identifier</a> ( <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#FormalParameterList">FormalParameterList</a><sub>opt</sub> ) { <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#FunctionBody">FunctionBody</a> }</pre>

<pre>   FunctionExpression :
       function <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Identifier">Identifier</a><sub>opt</sub> ( <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#FormalParameterList">FormalParameterList</a><sub>opt</sub> ) { <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#FunctionBody">FunctionBody</a> }</pre>

<pre>   FormalParameterList :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Identifier">Identifier</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#FormalParameterList">FormalParameterList</a> , <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Identifier">Identifier</a></pre>

<pre>   FunctionBody :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#SourceElements">SourceElements</a><sub>opt</sub></pre>

<pre>   Program :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#SourceElements">SourceElements</a><sub>opt</sub></pre>

<pre>   SourceElements :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#SourceElement">SourceElement</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#SourceElements">SourceElements</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#SourceElement">SourceElement</a></pre>

<pre>   SourceElement :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Statement">Statement</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#FunctionDeclaration">FunctionDeclaration</a></pre>


<h5>A.6 统一资源定位符字符分类</h5>

<pre>   uri :::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#uriCharacters">uriCharacters</a><sub>opt</sub></pre>

<pre>   uriCharacters :::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#uriCharacter">uriCharacter</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#uriCharacters">uriCharacters</a><sub>opt</sub></pre>

<pre>   uriCharacter :::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#uriReserved">uriReserved</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#uriUnescaped">uriUnescaped</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#uriEscaped">uriEscaped</a></pre>

<pre>   uriReserved ::: 以下之一  ; / ? : @ & = + $ ,</pre>

<pre>   uriUnescaped :::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#uriAlpha">uriAlpha</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#DecimalDigit">DecimalDigit</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#uriMark">uriMark</a></pre>

<pre>   uriEscaped :::  % <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#HexDigit">HexDigit</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#HexDigit">HexDigit</a></pre>

<pre>   uriAlpha ::: 以下之一 
       a b c d e f g h i j k l m n o p q r s t u v w x y z
       A B C D E F G H I J K L M N O P Q R S T U V W X Y Z</pre>

<pre>   uriMark ::: 以下之一 
       - _ . ! ~ * ‘ ( )</pre>


<h5>A.7 正则表达式 </h5>

<pre>   Pattern ::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Disjunction">Disjunction</a></pre>

<pre>   Disjunction ::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Alternative">Alternative</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Alternative">Alternative</a> | <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Disjunction">Disjunction</a></pre>

<pre>   Alternative ::
       [ 空 ]
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Alternative">Alternative</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Term">Term</a></pre>

<pre>   Term ::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Assertion">Assertion</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Atom">Atom</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Atom">Atom</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Quantifier">Quantifier</a></pre>

<pre>   Assertion ::
       ^ 
       $ 
       \ b 
       \ B 
       ( ? = <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Disjunction">Disjunction</a> ) 
       ( ? ! <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Disjunction">Disjunction</a> )</pre>

<pre>   Quantifier ::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#QuantifierPrefix">QuantifierPrefix</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#QuantifierPrefix">QuantifierPrefix</a> ?</pre>

<pre>   QuantifierPrefix ::
       *
       +  ? 
       { <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#DecimalDigits">DecimalDigits</a> } 
       { <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#DecimalDigits">DecimalDigits</a> , } 
       { <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#DecimalDigits">DecimalDigits</a> , <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#DecimalDigits">DecimalDigits</a> }</pre>

<pre>   Atom ::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#PatternCharacter">PatternCharacter</a>
       .
       \ <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#AtomEscape">AtomEscape</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#CharacterClass">CharacterClass</a>
       ( <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Disjunction">Disjunction</a> ) 
       ( ? : <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#Disjunction">Disjunction</a> )</pre>

<pre>   PatternCharacter :: 
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#SourceCharacter">SourceCharacter</a> 但非以下之一 :
       ^ $ \ . * + ? ( ) [ ] { } |</pre>

<pre>   AtomEscape ::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#DecimalEscape">DecimalEscape</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#CharacterEscape">CharacterEscape</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#CharacterClassEscape">CharacterClassEscape</a></pre>

<pre>   CharacterEscape ::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#ControlEscape">ControlEscape</a>
       c <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#ControlLetter">ControlLetter</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#HexEscapeSequence">HexEscapeSequence</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#UnicodeEscapeSequence">UnicodeEscapeSequence</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#IdentityEscape">IdentityEscape</a></pre>

<pre>   ControlEscape :: 以下之一 
       f n r t v</pre>

<pre>   ControlLetter :: 以下之一 
       a b c d e f g h i j k l m n o p q r s t u v w x y z
       A B C D E F G H I J K L M N O P Q R S T U V W X Y Z</pre>

<pre>   IdentityEscape ::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#SourceCharacter">SourceCharacter</a> but not <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#IdentifierPart">IdentifierPart</a>
       <ZWJ>
       <ZWNJ></pre>

<pre>   DecimalEscape ::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#DecimalIntegerLiteral">DecimalIntegerLiteral</a> [lookahead ∉ <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#DecimalDigit">DecimalDigit</a>]</pre>

<pre>   CharacterClassEscape :: 以下之一 
       d D s S w W</pre>

<pre>   CharacterClass ::
       [ [lookahead ∉ {^}] <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#ClassRanges">ClassRanges</a> ] 
       [ ^ <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#ClassRanges">ClassRanges</a> ]</pre>

<pre>   ClassRanges ::
       [empty]
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#NonemptyClassRanges">NonemptyClassRanges</a></pre>

<pre>   NonemptyClassRanges ::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#ClassAtom">ClassAtom</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#ClassAtom">ClassAtom</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#NonemptyClassRangesNoDash">NonemptyClassRangesNoDash</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#ClassAtom">ClassAtom</a> – <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#ClassAtom">ClassAtom</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#ClassRanges">ClassRanges</a></pre>

<pre>   NonemptyClassRangesNoDash ::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#ClassAtom">ClassAtom</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#ClassAtomNoDash">ClassAtomNoDash</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#NonemptyClassRangesNoDash">NonemptyClassRangesNoDash</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#ClassAtomNoDash">ClassAtomNoDash</a> – <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#ClassAtom">ClassAtom</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#ClassRanges">ClassRanges</a></pre>

<pre>   ClassAtom ::
       - 
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#ClassAtomNoDash">ClassAtomNoDash</a></pre>

<pre>   ClassAtomNoDash ::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#SourceCharacter">SourceCharacter</a> 但非以下之一 \ 或 ] 或 - 
       \ <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#ClassEscape">ClassEscape</a></pre>

<pre>   ClassEscape ::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#DecimalEscape">DecimalEscape</a>
       b 
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#CharacterEscape">CharacterEscape</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#CharacterClassEscape">CharacterClassEscape</a></pre>


<h5>A.8 JSON</h5>


<h6>A.8.1 JSON 词法</h6>

<pre>   JSONWhiteSpace ::
       <TAB>
       <CR>
       <LF>
       <SP></pre>

<pre>   JSONString ::
       " JSONStringCharacters<sub>opt</sub> "</pre>

<pre>   JSONStringCharacters ::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#JSONStringCharacter">JSONStringCharacter</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#JSONStringCharacters">JSONStringCharacters</a><sub>opt</sub></pre>

<pre>   JSONStringCharacter ::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#SourceCharacter">SourceCharacter</a> 但非 双引号 " 或反斜杠 \ 或 U+0000 抑或是 U+001F
       \ <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#JSONEscapeSequence">JSONEscapeSequence</a></pre>

<pre>   JSONEscapeSequence ::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#JSONEscapeCharacter">JSONEscapeCharacter</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#UnicodeEscapeSequence">UnicodeEscapeSequence</a></pre>

<pre>   JSONEscapeCharacter :: 以下之一 
       " / \ b f n r t</pre>

<pre>   JSONNumber ::
       -<sub>opt</sub><a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#DecimalIntegerLiteral">DecimalIntegerLiteral</a> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#JSONFraction">JSONFraction</a><sub>opt</sub> <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#ExponentPart">ExponentPart</a><sub>opt</sub></pre>

<pre>   JSONFraction ::
       . <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#DecimalDigits">DecimalDigits</a></pre>

<pre>   JSONNullLiteral ::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#NullLiteral">NullLiteral</a></pre>

<pre>   JSONBooleanLiteral ::
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#BooleanLiteral">BooleanLiteral</a></pre>


<h6>A.8.2 JSON 语法</h6>

<pre>   JSONText :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#JSONValue">JSONValue</a></pre>

<pre>   JSONValue :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#JSONNullLiteral">JSONNullLiteral</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#JSONBooleanLiteral">JSONBooleanLiteral</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#JSONObject">JSONObject</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#JSONArray">JSONArray</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#JSONString">JSONString</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#JSONNumber">JSONNumber</a></pre>

<pre>   JSONObject :
       { } 
       { <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#JSONMemberList">JSONMemberList</a> }</pre>

<pre>   JSONMember :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#JSONString">JSONString</a> : <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#JSONValue">JSONValue</a></pre>

<pre>   JSONMemberList :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#JSONMember">JSONMember</a> 
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#JSONMemberList">JSONMemberList</a> , <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#JSONMember">JSONMember</a></pre>

<pre>   JSONArray :
       [ ] 
       [ <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#JSONElementList">JSONElementList</a> ]</pre>

<pre>   JSONElementList :
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#JSONValue">JSONValue</a>
       <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#JSONElementList">JSONElementList</a> , <a href="http://www.w3.org/html/ig/zh/wiki/ES5/附录#JSONValue">JSONValue</a></pre>


<!--<h4>附录 B 兼容性</h4>-->


<h4>附录 C ECMAScript 的严格模式ⒹⒺ</h4>

<p><b>严格模式下的限制说明</b></p>

<ul>
  <li>在严格模式下的代码中，"<b>implements</b>", "<b>interface</b>", "<b>let</b>", "<b>package</b>", "<b>private</b>", "<b>protected</b>", "<b>public</b>", "<b>static</b>", 和 "<b>yield</b>" 都被作为未来可能会使用到的保留字（7.6.12）。</li>

  <li>符合规范的实现中，当处理严格模式下的代码时，不应该像 B.1.1 中描述地那样将 OctalIntegerLiteral 扩展到 NumericLiteral（7.8.3）的语法中。</li>

  <li>符合规范的实现中，当处理严格模式下的代码时，不应该像 B.1.2 中描述地那样将 OctalEscapeSequence 扩展到 EscapeSequence 的语法中。</li>

  <li>无法注册一个未定义的标识符或者其他无法解析的引用到全局对象下。当在严格模式下进行一个简单注册时，它左部不能解析为一个无法解析的引用。如果是无法解析的，那么就会抛出一个 ReferenceError 异常。左部也不能是一个数据属性的引用，</li>

  <li>eval 或者 arguments 不能出现在一个注册操作（11.13）或者一个 Postfix 表达式的左部，也不能作为 Prefix Increment（11.4.4）或者 prefix decrement 操作（11.4.5）上面的一元表达式操作。</li>

  <li>严格模式下的 arguments 对象定义了不可配置的存取属性，包括“caller”和“callee”，如果访问这两个对象则会抛出一个类型错误。</li>

  <li>严格模式下的 Arguments 对象不会动态共享它们的数组索引值，这些索引值包含了函数绑定时对应格式的参数。</li>

  <li>严格模式下的函数中，如果一个参数对象绑定了作用域内的 arguments 标识符来获取参数对象，那么这个参数对象是不可变的，并在之后也不能进行注册操作。</li>

  <li>在严格模式下，如果代码包含了一个含有一个以上任意数据属性的定义，那么这就是一个语法错误。</li>

  <li>在严格模式下，如果 eval 或者 argument 出现在属性参数列表中，那么这就是一个语法错误</li>
</ul>

<!--
<h4>附录 D 第 5 版的更正以及澄清与第 3 版的兼容影响</h4>-->


<h4>附录 E 第 5 版内容的增加与变化，介绍第 3 版不兼容问题</h4>

<p>7.1：Unicode 格式控制字符在受到处理之前不再从 ECMAScript 源文本中剥离。在第五版中，如果这样一个字符在字符串字面量或者正则表达式字面量中出现，这个字符会被合并到字面量中，而在第三版里，这个字符不会被合并。</p>

<p>7.2：Unicode 字符 <BOM> 现在是作为空格使用，如果它出现在本该是一个标识符的位置的中间，则会产生一个语法错误，而在第三版里不会。</p>

<p>7.3：换行符以前是作为转义字符处理，而现在允许换行符被包含在字符串字面量标记中。这在第三版中会产生一个语法错误。</p>

<p>7.8.5：现在的正则表达式字面量在字面量解析执行的时候都会返回一个唯一的对象。这个改变可以被任意测试字面量值的对象 ID 或者一些敏感的副作用的程序检测到。</p>

<p>7.8.5：第五版要求提前抛出任意可能的正则表达式结构错误，这些结构错误会在将正则表达式字面量转换成正则表达式对象的时候产生。在第五版之前的实现允许延迟抛出 [TypeError]，直到真正执行到这个对象。</p>

<p>7.8.5：在第五版中，未转义的 "/" 字符可以作为 <b>CharacterClass</b> 存在于正则表达式字面量中。在第三版里，这样的字符是作为字面量的最后一个字符存在。</p>

<p>10.4.2：在第五版中，间接调用 eval 函数会将全局对象作为 <a href="http://es5.github.com/#eval-code">执行代码 </a>的变量环境和 <a href="http://es5.github.com/#x10.2">词法环境 </a>。在第三版中，[eval] 函数的间接调用者的变量和 <a href="http://es5.github.com/#x10.2">词法环境 </a>是作为 <a href="http://es5.github.com/#eval-code">执行代码 </a>的环境使用。</p>

<p>15.4.4：在第五版中，所有 <a href="http://es5.github.com/#x15.4.3.1">Array.prototype</a> 下的方法都是通用的。在第三版中，<b>toString</b> 和 <b>toLocaleString</b> 方法不是通用的，如果被非 Array 实例调用时会抛出一个<b>TypeError</b> 的异常。</p>

<p>10.6：在第五版中，argument 对象与实际的参数符合，它的数组索引属性是可枚举的。在第三版中，这些属性是不可枚举的。</p>

<p>10.6：在第五版中，一个 arguments 对象的 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=Class&action=edit&redlink=1">Class</a> 内置属性值是“<b>Arguments</b>”。在第三版中，它是“<b>Object</b>”。当对 argument 对象调用 <b>toString</b> 的时候</p>

<p>12.6.4：当 <b>in</b> 表达式执行一个 <b>null</b> 或者 <b>undefined</b> 时 ,for-in 语句不再抛出 <b>TypeError</b>。取而代之的是将其作为不包含可枚举属性的对象执行。</p>

<p>15：在第五版中，下面的新属性都是在第三种中已存在的内建对象中定义，<b>Object.getPrototypeOf, Object.getOwnPropertyDescriptor, Object.getOwnPropertyNames, Object.create, Object.defineProperty, Object.defineProperties, Object.seal, Object.freeze, Object.preventExtensions, Object.isSealed, Object.isFrozen, Object.isExtensible, Object.keys, Function.prototype.bind, Array.prototype.indexOf, Array.prototype.lastIndexOf, Array.prototype.every, Array.prototype.some, Array.prototype.forEach, Array.prototype.map, Array.prototype.filter, Array.prototype.reduce, Array.prototype.reduceRight, String.prototype.trim, Date.now, Date.prototype.toISOString, Date.prototype.toJSON</b>。</p>

<p>15：实现现在要求忽略内建方法中的额外参数，除非明确指定。在第三版中，并没有规定额外参数的处理方式，实现中明确允许抛出一个 TypeError<b>Bold text</b> 错误。</p>

<p>15.1.1：全局对象的值属性 <b>NaN</b>，<b>Infinity</b> 和 <b>Undefined</b> 改为只读属性。</p>

<p>15.1.2.1：实现不再允许约束非直接调用 eval 的方式。另外间接调用 eval 会使用全局对象作为变量环境，而不是使用调用者的变量环境作为变量环境。</p>

<p>15.1.2.2：<b>parseInt</b> 的规范不再允许实现将 0 开头的字符串作为 8 进制值。</p>

<p>15.3.4.3：在第三版中，如果传入 <a href="http://es5.github.com/#x15.3.4.3">Function.prototype.apply</a> 的第二个参数不是一个数组对象或者一个 arguments 对象，就会抛出一个 <b>TypeError</b>。在第五版中，参数也可以是任意类型的含有 <b>length</b> 属性的类数组对象。</p>

<p>15.3.4.3，15.3.4.4：在第三版中，在 <a href="http://es5.github.com/#x15.3.4.3">Function.prototype.apply</a> 或者 <a href="http://es5.github.com/#x15.3.4.4">Function.prototype.call</a> 中传入 <b>undefined</b> 或者 <b>null</b> 作为第一个参数会导致 <a href="http://es5.github.com/#x15.1">全局对象 </a>被作为一个个参数传入，间接导致目标函数的 [this] 会指向全局变量环境。如果第一个参数是一个 <a href="http://es5.github.com/#primitive_value">原始值 </a>，在 <a href="http://es5.github.com/#primitive_value">原始值 </a>上调用 <a href="http://es5.github.com/#x9.9">ToObject</a> 的结果会作为 <b>this</b> 的值。在第五版中，这些转换不会出现，目标函数的 <b>this</b> 会指向真实传入的参数。这个不同点一般情况下对已存在的遵循 ECMAScript 第三版的代码来说不太明显，因为相应转换会在目标函数生效之前执行。然而，基于不同的实现，如果使用 <b>apply</b> 或者 <b>call</b> 调用函数时，这个不同点就会很明显。另外，用这个方法调用一个标准的内建函数，并使用 <b>null</b> 或者 <b>undefined</b> 作为参数时，很可能会导致第五版标准下的实现与第三版标准下的实现不同。特别是第五版中代表性地规定了需要将实际调用的传入的 <b>this</b> 值作为对象的内建函数，在传入 <b>null</b> 或者 <b>undefined</b> 作为 <b>this</b> 值时，会抛出一个 <b>TypeError</b> 异常。</p>

<p>15.3.5.2：在第五版中，函数实例的 <b>prototype</b> 属性是不可枚举的。在第三版中，是可以枚举的。</p>

<p>15.5.5.2：在第五版中，一个字符串对象的 <a href="http://www.w3.org/html/ig/zh/wiki/index.php?title=PrimitiveValue&action=edit&redlink=1">primitiveValue</a> 的单个字符可以作为字符串对象的数组索引属性访问。这些属性是不可泄也不可配置的，并会影响任意名字相同的继承属性。在第三版中，这些属性不会存在，ECMAScript 代码可以通过这些名字动态添加和移除可写的属性并访问以这些名字继承的属性。</p>

<p>15.9.4.2：<a href="http://es5.github.com/#x15.9.4.2">Date.parse</a> 方法现在不要求第一个参数首先作为 ISO 格式字符串解析。使用这个格式但是基于特定行为实现（包括未来的一些行为）或许会表现的不太一样。</p>

<p>15.10.2.12：在第五版中，<b>\s</b> 现在可以匹配 <BOM> 了</p>

<p>15.10.4.1：在第三版中，由 <b>RegExp</b> 构造器创建的对象的 <b>source</b> 字符串的精确形式由实现定义。在第五版中，字符串必须符合确定的指定条件，因此会和第三版标准的实现的结果不一样。</p>

<p>15.10.6.4：在第三版中，<a href="http://es5.github.com/#x15.10.6.4">RegExp.prototype.toString</a> 的规则不需要由 RegExp 对象的 <b>source</b> 属性决定。在第五版中，结果必须由 <b>source</b> 属性经由一个指定的规则，因此会和第三版实现的结果不一样。</p>

<p>15.11.2.1，15.11.4.3：在第五版中，如果一个错误对象的 <b>message</b> 属性原始值没有通过 <b>Error</b> 构造器指定，那么这个原始值就是一个空的字符串。在第三版中，这个原始值由实现决定。</p>

<p>15.11.4.4：在第三版中，<b>Error.prototype.toString</b> 的结果是由实现定义的。在第五版中，有完整的规范指定，因此可能会和第三版的实现不同。</p>

<p>15.12： 在第五版中，<b>JSON</b> 是在全局环境中定义的。第三版中，测试这个名词的存在会发现它是 undefined，除非这个程序或者实现定义了这个名词。</p>



<h4>附录 F 5.1 版中技术上的重大更正和阐明</h4>

<p>7.8.4: CV 定义追加了 DoubleStringCharacter :: LineContinuation 与 SingleStringCharacter :: LineContinuation.</p>

<p>10.2.1.1.3：参数 S 是不能被忽略的。它控制着试图设置一个不可改变的绑定时是否抛出异常。</p>

<p>10.2.1.2.2：在算法的第 5 步，真被传递后最后一个参数为 [[DefineOwnProperty]]。</p>

<p>10.5：当重定义全局函数使，原算法步骤 5.E 调整为现在的 5.F，并加入一个新的步骤 5.E 用来还原与第三版的兼容性。</p>

<p>11.5.3：在最后符号项，指定使用 IEEE754 舍入到最接近模式。</p>

<p>12.6.3：在步骤 3.a.ii 的两种算法中修复缺失的 ToBoolean。</p>

<p>12.6.4：在最后两段的额外最后一句中，阐明某些属性枚举的规定。</p>

<p>12.7，12.8，12.9：BNF 的修改为阐明 continue 或 break 语句没有一个 Identifier 或一个 return 语句没有一个 Expression 时，在分号之前可以有一个 LineTerminator 。</p>

<p>12.14：算法 1 的步骤 3 算法 3 的步骤 2.a 中，纠正这样的值域 B 是作为参数传递而不是 B 本身。</p>

<p>15.1.2.2：在算法的步骤 2 中阐明 S 可能是空字符串。</p>

<p>15.1.2.3：在算法的步骤 2 中阐明 trimmedString 可以是空字符串。</p>

<p>15.1.3：添加注释阐明 ECMAScript 中的 URI 语法基于 <a href="http://tools.ietf.org/html/rfc2396">RFC 2396</a> 和较新的 <a href="http://tools.ietf.org/html/rfc3986">RFC 3986</a>。</p>

<p>15.2.3.7：在算法步骤 5 和 6 中更正使用变量 P。</p>

<p>15.2.4.2：第五版处理 undefined 和 null 值导致现有代码失败。规范修改为保持这样的代码的兼容性。在算法中加入新的步骤 1 和 2。</p>

<p>15.3.4.3：步骤 5 和 7 版 5 算法已被删除，因为它们规定要求 argArray 参数与泛数组状对象的其它用法不一致。</p>

<p>15.4.4.12：在步骤 9.A，用 actualStart 替换不正确 relativeStart 引用。</p>

<p>15.4.4.15：阐明 fromIndex 的默认值是数组的长度减去 1。</p>

<p>15.4.4.18：在算法的第 9 步，undefined 是现在指定的返回值。</p>

<p>15.4.4.22：在步骤 9.c.ii 中，第一个参数的 [[Call]] 内部方法已经改变为 undefined，保持与 Array.prototype.reduce 定义的一致性。</p>

<p>15.4.5.1：在算法步骤 3.l.ii 和 3.l.iii 中，变量的名字是相反的，导致一个不正确的相反测试。</p>

<p>15.5.4.9：规范要求每有关规范等效字符串删除，算法从每一个段落都承接 ，因为它在注 2 中被列为建议的。</p>

<p>15.5.4.14：在 split 算法步骤 11.A 和 13.a，SplitMatch 参数的位置顺序已修正为匹配 SplitMatch 的实际参数特征。在步 13.a.iii.7.d，lengthA 取代 A.length。</p>

<p>15.5.5.2：在首段中，删除的单个字符属性访问“array index”语义的含义。改进算法步骤 3 和 5，这样它们不执行“array index”的要求。</p>

<p>15.9.1.15：为缺失字段指定了合法值范围。淘汰“time-only”格式。所有可选字段指定默认值。</p>

<p>15.10.2.2：算法步骤编号为第二步所产生的内部闭包被错误的编号，它们是额外的算法步骤。</p>

<p>15.10.2.6：在步骤 3 中的列表中抽象运算符 IsWordChar 的第一个字符是“a”而不是“A”。</p>

<p>15.10.2.8：在闭包算法返回抽象运算符 CharacterSetMatcher 中 ，为了避免与一个闭包的形参名称冲突，步骤 3 中定义的变量作为参数传递在第 4 步更名为 ch。</p>

<p>15.10.6.2：步骤 9.e 被删除，因为它执行了 I 的额外增量。</p>

<p>15.11.1.1：当 message 参数是 undefined 时，撤销 message 自身属性设置为空字符串的要求。</p>

<p>15.11.1.2：当 message 参数是 undefined 时，撤销 message 自身属性设置为空字符串的要求。</p>

<p>15.11.4.4：步骤 6-10 修改 / 添加正确处理缺少或空的 message 属性值。</p>

<p>15.11.1.2: Removed requirement that the message own property is set to the empty String when the message argument is undefined.</p>

<p>15.12.3：在 JA 的内部操作的第一步 10.b.iii，串联的最后一个元素是 “]”。</p>

<p>B.2.1：追加注释，说明编码是基于 <a href="http://tools.ietf.org/html/rfc1738">RFC 1738</a> 而不是新的 <a href="http://tools.ietf.org/html/rfc3986">RFC 3986</a>。</p>

<p>附录 C：增加了 FutureReservedWords 在标准模式下的相应内容到 7.6.12 节。</p>



<h4>参考书目</h4>

<ol>
  <li>ANSI/IEEE Std 754-1985: IEEE Standard for Binary Floating-Point Arithmetic. Institute of Electrical and Electronic Engineers, New York (1985) </li>

  <li>The Unicode Consortium. The Unicode Standard, Version 3.0, defined by: The Unicode Standard, Version 3.0 (Boston, MA, Addison-Wesley, 2000. <a href="http://www.w3.org/html/ig/zh/wiki/Special:BookSources/0201616355">ISBN 0-201-61635-5</a>) </li>

  <li>Unicode Inc. (1998), Unicode Technical Report #15: Unicode Normalization Forms </li>

  <li>ISO 8601:2004(E) Data elements and interchange formats – Information interchange -- Representation of dates and times </li>

  <li><a href="http://tools.ietf.org/html/rfc1738">RFC 1738</a> “Uniform Resource Locators (URL)”, available at <<a href="http://tools.ietf.org/html/rfc1738">http://tools.ietf.org/html/rfc1738</a>> </li>

  <li><a href="http://tools.ietf.org/html/rfc2396">RFC 2396</a> “Uniform Resource Identifiers (URI): Generic Syntax”, available at <<a href="http://tools.ietf.org/html/rfc2396">http://tools.ietf.org/html/rfc2396</a>> </li>

  <li><a href="http://tools.ietf.org/html/rfc3629">RFC 3629</a> “UTF-8, a transformation format of ISO 10646”, available at <<a href="http://tools.ietf.org/html/rfc3629">http://tools.ietf.org/html/rfc3629</a>> </li>

  <li><a href="http://tools.ietf.org/html/rfc4627">RFC 4627</a> “The application/json Media Type for JavaScript Object Notation (JSON)“ , available at <<a href="http://tools.ietf.org/html/rfc4627">http://tools.ietf.org/html/rfc4627</a>></li>
</ol>